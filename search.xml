<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #564 (Div. 1) 自闭记]]></title>
    <url>%2F2019%2F06%2F08%2FCodeforces-Round-564-Div-1-%E8%87%AA%E9%97%AD%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Codeforces Round 564 (Div. 1)Overview Status A B C1 C2 D E F Contest 01:08 01:34 Attempt +1 + * * * AC count 462 461 213 70 22 0 0 Tag 模拟 简单数学 期望 期望 构造 Coding 2031 1094 1959 1959 1079 ? ? Thinking Easy Easy+ Mid- Mid- Mid ? ? Stars ★ ★ 注：$\mathcal O$ 表示口头通过。 Solved during contest: 2/6 Upsolved: 4/6 Orally upsolved: 4/6 Rank: 396/553 Rating: (-8) 又是一个中国场，又是一个 Div. 1，又是一个被签到题吊打系列。。。题目质量还不错，可是不知道为什么，每次打 Div. 1 老是签到签不稳，这根本不行啊。然后 C 题都想对了，但是没时间写了。 Contest MaterialsContest ID: 1172 Contest Link Problemset Link Editorial Link (en) Editorial Link(zh) TutorialsProb A. 麻烦的签到题Description共有 $2n$ 张牌，其中有 $n$ 张是 0 ，另外 n 张分别是 $1,2, \ldots, n$ 。牌桌上有一个某 $n$ 张牌组成的队列，你手中则拿着剩下的 $n$ 张牌。你每次操作都是将手中的一张牌加入队列末尾，并且把队列头的牌加入手牌中。问至少需要几次可以使得队列中的牌从队列头到队列尾恰好为 $1,2,\ldots,n$ 。 Solution很令人讨厌的签到题，费了我一个小时时间，还 RE 了一次。我写的是贪心+大模拟，每一时刻都检查能否顺着把序列排列出来，如果可以，立即果断行动。否则，如果手中有0就打出0 ，没有 0 就打出最大的牌。可以证明次数不超过 $2n$ ，因此模拟即可。注意特判这种情况： 12350 0 0 0 05 1 2 3 4 Code点击显示/隐藏代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* * Author : YangDavid * Created Time : 2019年06月07日 星期五 20时31分52秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 222222;int my[maxn], n, pile[maxn], start = -1, zero, tim, match;set&lt;int, greater&lt;int&gt; &gt; st;deque&lt;int&gt; q;void ins(int x) &#123; if(x == 0) zero++; else st.insert(x);&#125;int main() &#123; scanf("%d", &amp;n); rep(i, n) scanf("%d", &amp;my[i]); rep(i, n) scanf("%d", &amp;pile[i]); bool ok = true; againqaq:; st.clear(); while(!q.empty()) q.pop_back(); rep(i, n) q.push_back(pile[i]); zero = 0; rep(i, n) &#123; if(pile[i] == 1) &#123; for(int j= i + 1; j &lt;= n; ++j) if(pile[j] != j - i + 1) ok = false; if(ok) &#123; match = n - i + 1; break; &#125; else tim = max(tim, -pile[i] + i + 1); &#125; if(pile[i]) tim = max(tim, -pile[i] + i + 1); &#125; rep(i, n) &#123; if(my[i] == 0) zero++; else st.insert(my[i]); &#125; int now = 0, ans = 0; if(now &lt; tim) match = 0; while(now &lt; tim) &#123; if(zero) &#123; zero--; q.push_back(0); ins(q.front()); q.pop_front(); &#125; else &#123; int po = *st.begin(); st.erase(po); q.push_back(po); tim = max(tim, now + n - po + 1); &#125; now++, ans++; &#125; while(match &lt; n) &#123; if(!st.count(match + 1)) &#123; ok = false; now = ans = match = 0; goto againqaq; &#125; st.erase(match + 1); q.push_back(match + 1); ins(q.front()); q.pop_front(); match++, now++, ans++; &#125; printf("%d\n", ans); return 0;&#125; Prob B. 简单数学水题。 点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * Author : YangDavid * Created Time : 2019年06月07日 星期五 21时26分05秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 222222, MOD = 998244353;inline int muln(int x, int y) &#123; return 1LL * x * y % MOD;&#125;int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;vector&lt;int&gt; G[maxn];int n, xp, yp, sz[maxn], ans, fac[maxn], sons[maxn];void dfs(int v, int fa) &#123; sz[v] = 1; for(auto g : G[v]) if(g != fa) &#123; sons[v]++; dfs(g, v); sz[v] += sz[g]; ans = muln(ans, fac[sons[g] + 1]); &#125; if(v == 1) ans = muln(ans, fac[sons[v]]); //ans = muln(ans, fac[sons]);&#125;int main() &#123; fac[0] = 1; for(int i = 1; i&lt;= 200010; ++i) fac[i] = muln(fac[i - 1], i); scanf("%d", &amp;n), ans = n; for(int i = 1;i &lt; n; ++i) &#123; scanf("%d%d", &amp;xp, &amp;yp); G[xp].push_back(yp); G[yp].push_back(xp); &#125; dfs(1, -1); printf("%d\n", ans); return 0;&#125; Prob C. 概率结论一猜就中。暴力 dp 即可 $O(m^2)$ 。 点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * Author : YangDavid * Created Time : 2019年06月07日 星期五 21时59分19秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 222222, maxm = 3333, MOD = 998244353;int muln(int x, int y ) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int inverse(int x) &#123; return qpow(x, MOD - 2); &#125;int a[maxn], w[maxn], n, m, like, diss, tot, dp[maxm][maxm], _inv[maxm * 5];int ans[maxn];inline int inv(int x) &#123; return _inv[x - tot + m]; &#125;inline void upd(int &amp;x, int y) &#123; x += y; if(x &gt;= MOD) x -= MOD;&#125;int mo(int x) &#123; if(x &gt;= MOD) return x - MOD; if(x &lt; 0) return x + MOD; return x;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); rep(i, n) scanf("%d", &amp;a[i]); rep(i, n) scanf("%d", &amp;w[i]); rep(i, n) a[i] ? (like += w[i]) : (diss += w[i]); tot = like + diss; for(int i = max(0, tot-m); i &lt;= tot+m; ++i) _inv[i - tot + m] = inverse(i); dp[0][0] = 1; for(int i = 0; i &lt; m; ++i) &#123; for(int add = 0; add &lt;= i; ++add) &#123; int sub = i - add, nlike = like+add, ndiss = diss-sub; int ntot = nlike + ndiss, ntot_inv = inv(ntot); upd(dp[i + 1][add], muln(dp[i][add], muln(ndiss, ntot_inv))); upd(dp[i + 1][add + 1], muln(dp[i][add], muln(nlike, ntot_inv))); &#125; &#125; int exp_add = 0, exp_sub = 0; for(int add = 0; add &lt;= m; ++add) &#123; upd(exp_add, muln(dp[m][add], add)); upd(exp_sub, muln(dp[m][add], m-add)); &#125; exp_add = muln(exp_add, inverse(like)); exp_sub = muln(exp_sub, inverse(diss)); for(int i = 1;i &lt;= n; ++i) &#123; if(a[i]) printf("%d\n", mo(w[i] + muln(w[i], exp_add))); else printf("%d\n", mo(w[i] - muln(w[i], exp_sub))); &#125; return 0;&#125; Prob D. 构造Description在一个 $n\times n$ 的网格里放传送门，指定从第 $i$ 行进从第 $r_i$ 行出，从第 $i$ 列进从第 $c_i$列出，r, c 都是排列，求构造放置传送们的一种方案。 Solution考虑数学归纳法，只需要解决到第一行的和到第一列的。 如果恰好第一行要到达第一行，第一列要到达第一列，那么就不用管，直接看下一行下一列； 否则记第 r 行将要到达第一行，第 c 列将要到达第一列，那么我就在 (r, 1) 和 (1, c) 这两个地方放传送门，并且将第 r 行的目标从第一行改为第一行的目标，把第 c 列的目标改为第一列的目标即可（这个过程本质是链表的删除操作）。由此归纳即可。 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * Author : YangDavid * Created Time : 2019年06月11日 星期二 22时43分05秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef pair&lt;pii, pii&gt; ppp;typedef long long ll;const int maxn = 1111;int go_r[maxn], go_c[maxn], n, which_r[maxn], which_c[maxn];int main() &#123; scanf("%d", &amp;n); rep(i, n) &#123; scanf("%d", &amp;go_r[i]); which_r[go_r[i]] = i; &#125; rep(i, n) &#123; scanf("%d", &amp;go_c[i]); which_c[go_c[i]] = i; &#125; vector&lt;ppp&gt; ans; for(int i = 1; i &lt;= n; ++i) &#123; if(which_r[i] == i &amp;&amp; which_c[i] == i) continue; int r = which_r[i], c = which_c[i]; ans.push_back(&#123;&#123;which_r[i], i&#125;, &#123;i, which_c[i]&#125;&#125;); which_r[go_r[i]] = r; which_c[go_c[i]] = c; go_r[r] = go_r[i]; go_c[c] = go_c[i]; &#125; int sz = ans.size(); printf("%d\n", sz); for(auto g : ans) printf("%d %d %d %d\n", g.first.first, g.first.second, g.second.first, g.second.second); return 0;&#125; Prob E.Prob F.]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年ACM-ICPC陕西省赛游记]]></title>
    <url>%2F2019%2F06%2F02%2F2019%E5%B9%B4ACM-ICPC%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[游记夺冠了！作为和 nocriz，hdmmblz 一起组队打的第一场比赛，这也算是一个开门红吧，这次的解题策略与团队合作等诸多方面都做得还不错，出的锅也不算特别多。不过这也仅仅是一个省赛，仅仅是一个起点，以后的路还长，以后的目标需要远大！我们有了方向，有了动力，更有了顶天立地的决心。 不过这次去除两个高中打星队我们才夺的冠，那两个队一个 11 题，一个 10 题，还是被高中省队爷吊打了啊，感觉还是要提高啊。（被“丁教练”教育了qaq） 准备上午 06:40 就早早地起床，集合，前往 XDU。路上水掉了 wzk 讲的一个张好风出的构造题，感觉海星。 到了 XDU ，拿好衣服之后打了一个极为自闭的热身赛。首先是发现电脑的 Ubuntu 双系统里面居然没有 vim，没有各种常见编辑器，打算换用 gedit 之后，发现居然没有网络，无法查看题面。一阵忙乱之中我们又改用 windows + Dev-cpp，结果发现电脑又没有 python，g++也没有加入 PATH 环境变量里。这时开始看热身赛的题目，wzk 几分钟秒掉了 A ，我提出了 B 题最短路+欧拉回路的做法，然而没有人熟悉欧拉回路怎么写！！！稍微讨论回忆了一下，构思好代码之后 wzk 开始写。cyy 和我思博了，一直对着 C 题自闭。最后 B 没写出来， C 也没做出来。结果 wzk 赛后直接一眼秒掉了 C。总的来看，热身赛什么环境也没来得及测，题目也只 A 了一道，感觉主要就是用来 rp++ 了。 下图是我们比赛的机位： 正赛参加完豪华（简单）的露天开幕式之后马上就要正赛了，感觉心里还蛮没底的。稍微调整了下状态，比赛开始了（喂，比赛没开始为什么大家都开始启封试题册了啊！）。wzk 悄悄以惊人的手速 10 分钟 1A 了三道签到题EFL 并拿到了 E 题的一血，简直太强了，这三道题我场上甚至根本没看。 之后开始多线程， wzk 看 C 写 C，结果 wa 了；这大概经过了 20 分钟，与此同时我和 cyy 互相交换了 H，I，J 三道题的题意。I 题稍微讨论了一下就会了，wzk 打印了 C 题代码，cyy 给 wzk 讲了 I ，wzk 开始写。我发现 H 是擅长的构造，我又发现这题和华东师大校赛的 C 题极为相似，于是决定仔细想 H，过了一会儿就会做了，给 cyy 讲了做法，cyy 觉得很正确，于是我仔细构思了下代码，觉得很好写。wzk 写好 I了，可是 wa 了，找出了好几个细节错误。打印代码后，我上机写 H。cyy 和 wzk 一起小黄鸭，发现了所有错误，改了之后提交，总算通过了 I 题，并拿到了一血。过了一会儿，我写完了 H ，测了测样例，手测几组数据，觉得稳得很，于是提交，1A了 H 题，并且还拿到了这道题一血。这时我们的士气很高涨，排在 rank 1，I，H 题仅仅有我们队通过，第二名仅仅才 4 道题，拿了两个一血，时间也才仅仅过去 74 分钟。 继续多线程，wzk 发现交大“免费赠送AC帽”队拿到了 B 题的一血，于是跟了下榜，发现是思博题，于是开始写。cyy 提出几种 J 做法，感觉找到了靠谱做法了，于是又屯下一题。wzk A掉了 B 题，cyy 开始给 wzk 讲 J 题，我把没看的题目都看了一遍，主要在想 D 题。wzk 开写 B 了，cyy 提出 K 题解法，但是我有点怀疑正确性。wzk J 题神秘地 TLE 了，在我强烈要求下不辞辛劳把 cin 改为了 fread+getchar ，又手动开了 O3，Ofast，然后就神奇通过了 J 题。wzk 确认了 cyy K 题解法的正确性，cyy 上机写 K 题，用了 20 多分钟也写好过掉了 K 题 。 与此同时，我一直在试图对 D 题进入大型分类讨论。我分了一维三种情况以及二位的六种情况，都将思路整理到之上了。wzk 建议看一看 C ，这时我们才意识到 WA 了很久扔在那里的题目。wzk 打算写 A 题试一试，我和 cyy 想了 C 的一些假做法，最后得到的结论 wzk 说就是当时 wa 的代码的思路。我发现有个小情况忘记考虑了，加上去之后大家不太相信正确性，可是我觉得很稳，结果交上去就 AC 了C题。 这时已经封榜了，我们手上有DAG三道题，有 40 分钟的时间。D题所有情况已经讨论完成了，A 题wzk写好了，但是交上去铁定会 TLE。wzk 试图优化 A ，可是没什么头绪。 D 题代码量巨大，细节繁琐，我硬着头皮上去写，cyy 在旁别即时检查。结果最后 2 分钟终于写完了代码，可是没时间调试了，直接交上去 WA 了，本地测了下也过不了样例，没有办法了，被高中生吊打了。 比较幸运的是，正式选手中我们还是拿到了 rank 1，拿到了冠军奖杯。（免费赠送AC帽队第四，他们差点就也 9 题了，真为他们可惜 qwq） 总的来看： Solved during contest: 9/12 Upsolved: 9/12 Orally upsolved: 9/12 Rank: 1/105 (Official), 3/111 (Full rank) 出现的问题集锦： （热身赛）没有人会熟练实现欧拉回路 大数据读入时仍使用 cin C 题 wzk 开始想的是正解，结果因为小情况 wa 而误以为算法假了 最后一个小时还是划了，D 讨论得还是不全面，主要是没有信心，写代码的时候中途我掉线了。 A 题写好后以为会 TLE 就没有提交，但实际上复杂度是正确的。 做得比较好的地方集锦： 基本做到了多线程 让 wzk 去签到 快速做出了构造题 cyy 力排众议，写了 K 题看似无脑的做法通过了 每次提交前的检查还算仔细 附录Practice Link Score Board：]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一句话题解集锦]]></title>
    <url>%2F2019%2F06%2F01%2F%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[这篇博客主要用来记录平时偶然做到的比较有趣的杂题的简略题解。 2019.52019.05.31 (Virtual participation of Codeforces Round 562, solved 3/5, rank 118/454) CF1168A: 二分思博题。 CF1168B: 很有趣的暴力，复杂度证明用到这么一个结论：长度大于 9 的 01 串必定存在 $1\leq x,k \leq n$ 使得 $s_x=s_{x+k} = s_{s+2k}$ CF1168C: 按位考虑，在每一种数位如果转移一次不行，那么多次也不行。因此每个位置维护一个 $go_i$ 表示转移到的第一个第 $i$ 位是 1 的数的位置，$O(n\log^2 n)$ 即可预处理。询问时随便找到目标数 y 的一个数位，看原数这个数位要转移到的位置是否小于等于 y 即可。 2019.06.01AtCoder M-SOLUTIONS Programming Contest AB: 思博题 C： 答案是这么一个式子：$$\frac{1}{1-c} \sum_{k=N}^{2N-1} \binom{k-1}{N-1} (A’^N B’^{k-N} + A’^{k-N}B’^{N})$$D: dfs一遍，每次回溯时给这个点标上当时最小的标号即可。 E：很 tricky 的一道题，除以 $d^k$ 之后变成：$$(\frac xd) \cdot (\frac xd+1) \cdot (\frac xd+2) \cdots \cdot (\frac xd+n-1)$$然后注意到模数是 $10^6+3$ ，因此 $\frac xd$ 这个分数可以表示为模意义整数，之后就是个前缀积水题了。 2019.06.11补掉了 CF1172D 构造题。 口胡了 BZOJ1046 ，打算有时间开一个最长上升子序列的专题 Blog。 目前已有的题目： Comet OJ #0 E Problem setter: tangjz，牛逼题。 HDU 6824 上次省赛训练时碰到的题目，和 Comet OJ 的那道题很相似。 Codeforces 1097E Hello 2019 的题目，早就该补了，但是一直咕咕咕。]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gym 102192 训练报告]]></title>
    <url>%2F2019%2F05%2F26%2FGym-102192-%E8%AE%AD%E7%BB%83%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[2018 Chinese Multi-University Training, Nanjing U ContestOverview Status A B C D E F G H I J K L Contest 1:25 (7) 2:16 0:17 4:55 2:35 4:56 Attempt +1 *7 +1 + + + + AC count 308 55 2 270 811 2 12 1 20 329 18 39 Tag 容斥 几何 构造 模拟 SAM LIS 贪心 Coding Easy ? ? Easy 1239 ? ? ? Mid Mid ? 1586 Thinking Easy+ ? ? Mid- Easy ? ? ? ? ? ? Easy+ Stars ★ ★★ 注：$\mathcal O$ 表示口头通过。 真·第一次正式训练，感觉合作得还蛮愉快的。不过最后半个小时有点没有按照正式比赛要求，三人三机了。以后还是一定要避免这种问题，协商好上机时间，严格三人单机。 Solved during contest: 6/12 Upsolved: 7/12 Orally upsolved: 7/12 Rank: 25/824 Contest MaterialsContest Link Statements Official Editorial Replay开场我从中间看了 E，发现是个签到的模拟题，就开始写，17 分钟过了 E。 cyy 说 J 是思博题，于是上机写，我和 wzk 看了 A ，中途 wzk 提出 C 题的很难写的一种做法。又看了下 D，没什么思路，决定集中精力想 A 。 wzk 反应过来是一道容斥原理裸题，经过验证是正确的。于是让 cyy 下机小黄鸭，wzk 写 A ，但是交上去 WA 了。我提醒了一个可能爆 int 的地方，改了之后就 AC 了。 wzk 想要写 C，可是场上没什么人过；cyy 继续下机小黄鸭。我和 wzk 讨论起了 D 。对于都是偶数的情况，首先我提出了 $\max(h,w)$ 的显然构造，wzk 迅速提出了一种更优的 $\max (h,w) + \lfloor \frac{\min(h,w)}{2}\rfloor$ 的构造，我稍微魔改了一下，得到了稍微更优秀一些的 $\max (h,w) + \lceil\frac{\min(h,w)}{2}\rceil$ 的构造。我们一致认为已经足够优秀，于是写了一下这种做法，可是交上去还是 WA 了。wzk 马上反应出在最上面添加形如 (((( 一行，最下面添加形如 )))) 的一行更加优秀，答案变成了 $h+w-4$ 。这次的构造已经非常优秀了，于是魔改之后，我们过了 D。cyy J 题总算也调完了，交上去一发过了 J。这时排名大概 60 左右，感觉还不怎么行。 下面又进入了一段机位空出来的时间，没有新的题可以做了。wzk 打算写 C 题，场上 B 题过了一大片，可是没想好怎么做。和 cyy 大致讨论了一些情况，可是谁都没有底去写。 wzk 说 C 题快调试完了，就没去管。我给 cyy 说了字符串题 I 题，cyy 提出了 SAM 建出后缀树树链剖分，再加一个线段树维护答案的不可写做法。 cyy 将其简化为了广义 SAM + 虚树 + 线段树合并 + 线段树的 同样不可写的 做法， cyy 开始构思代码。我发现榜上 L 题通过人数增长很快，费了好大力气读懂了题目，发现可能直接贪心就完事了。和 cyy 讨论了一下，发现和校赛 B 有点类似，可能直接用一个 map 维护就可以了。可是需要支持一个类似平衡树 split 的一个毒瘤操作，感觉有点坨屎。后来我发现直接暴力删除，复杂度就是对的，构思了下代码，觉得很可写。这时已经 4:20 ，wzk 的 C 题莫名奇妙地 RE 了。这时分歧出现了，我要写 L 题，cyy 想写 I 题，wzk 想调试 C 题。由于时间不多，只好三人三机了一会儿。最后 4:55 左右，我和 cyy 同时写完了。我一发过了样例，稍微小黄鸭一下改了一个很傻的错误，心里很没底就交了。 cyy 稍微靠前 1 分钟的时候交了。这时 cf 返回了两个 AC，过掉了I和L两道题 。于是最终排名看起来还行。 比赛过程出现的锅： A 题有个地方忘记开 long long J 题没有想好就开始写，浪费不少机时 B 题思博题，没有人想去写，结果最后就没有过 中期一直卡在 C 题上，花费了不少机时，最后 IL 两道题都比较有思路，只得三人三机了一会儿。正式比赛还-是要避免这种问题。 Tutorials已知的题目难度顺序： Very Easy：E Easy: A, D, J Mid Easy: L Mid Hard: I Prob A. 容斥 Solved by nocriz at 01:25 (+1) Description给定 $n,m,k$ 求多项式：$$(1+x+x^2+\cdots+x^{n-1})^m$$的 $k$ 次方项的值。 数据范围：多组询问，$T\leq 400 ,n,m,k\leq 10^5, \sum n, \sum m,\sum k \leq 2\cdot 10^6$ Solution考虑组合意义，$m$ 个 $[0,n-1]$ 之间的数要凑出 k 的方案数。假如没有 $n-1$ 的限制多简单啊，直接答案就是组合数 $\binom{k+m-1}{m-1}$。可是如果有限制，我们就可以考虑容斥原理。考虑至少有 $i$ 个数超过限制的方案数，那么首先把这 i 个数选出来之后，就是要凑出 $k-in$ 的方案数了。所以至少有 i 个数的答案为：$$f(i) = \binom{m}{i} \cdot \binom{k-in+m-1}{m-1}$$最终总的答案为：$$ans = \sum_{i=0}^{\lfloor \frac ik \rfloor} f(i) \cdot (-1)^i$$ Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int mod = 998244353;int add(int a,int b)&#123; return (a+b)&gt;=mod?a+b-mod:a+b;&#125;int sub(int a,int b)&#123; return (a-b)&lt;0?a-b+mod:a-b;&#125;int sq(int x)&#123;return 1ll*x*x%mod;&#125;int mul(int a,int b)&#123;return 1ll*a*b%mod;&#125;int pow(int a,int b)&#123;return b==0?1:((b&amp;1)?mul(a,sq(pow(a,b/2))):(sq(pow(a,b/2))));&#125;const int N = 200010;int fac[N],invfac[N];int C(int n,int m)&#123;return mul(fac[n],mul(invfac[m],invfac[n-m]));&#125;int main()&#123; fac[0] = 1; for(int i=1;i&lt;N;i++)&#123; fac[i] = mul(fac[i-1],i); &#125; invfac[N-1] = pow(fac[N-1],mod-2); for(int i=N-2;i&gt;=0;i--)&#123; invfac[i] = mul(invfac[i+1],i+1); &#125; //cout&lt;&lt;C(6,4)&lt;&lt;endl; int T; cin&gt;&gt;T; while(T--)&#123; int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int ans = 0; if(1ll*(n-1)*m&lt;k)&#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; for(int i=0;i*n&lt;=k;i++)&#123; if(i&amp;1)&#123; ans = sub(ans,mul(C(k-i*n+m-1,m-1),C(m,i))); &#125;else&#123; ans = add(ans,mul(C(k-i*n+m-1,m-1),C(m,i))); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Prob B.Prob C.Prob D. 构造好题 Solved by nocriz at 02:16 (+1) Description称一个括号矩阵的行是好的，当且仅当这一行从左往右读得到的括号序列是匹配的；称一个列是好的，当且仅当这一列从上往下读是匹配的。现在你需要构造一个 $h\times w$ 的括号矩阵，使得好的行的数目+好的列的数目最大。 Solution当行或者列有至少一个是奇数时，问题都变得很平凡。 当行或者列都是偶数时，特判掉一些小情况，然后对于大情况考虑下面的构造： 123456(((((((((()()())()()()()(()()())()()()())))))))) 即：第一行、最后一行、第一列、最后一列如上图那样，其他行没两行循环一次这样构造。可以看到只有第一行、最后一行、第一列、最后一列没有匹配，答案是 $h+w-4$ 。应当可以证明对于大情况，这种构造是最优的。 Code点击显示/隐藏代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;char ans[220][220] = &#123;0&#125;;int n,m,swped = 0;void mp(int i,int j,char c)&#123; if(swped)swap(i,j); ans[i][j] = c;&#125;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; swped = 0; memset(ans,0,sizeof(ans)); cin&gt;&gt;n&gt;&gt;m; //cerr&lt;&lt;"Case :"&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;endl; if(m%2 == 1 || (n%2 == 0 &amp;&amp; n&lt;m))&#123; swped = 1; swap(n,m); &#125; //cerr&lt;&lt;n&lt;&lt;' '&lt;&lt;m&lt;&lt;endl; for(int i=0;i&lt;n;i++)&#123; if(i&amp;1)&#123; for(int j=0;j&lt;m;j++)&#123; if(j&amp;1) mp(i,j,')'); else mp(i,j,'('); &#125; &#125;else&#123; mp(i,0,'('); for(int j=0;j&lt;m-2;j++)&#123; if(j&amp;1) mp(i,j+1,')'); else mp(i,j+1,'('); &#125; mp(i,m-1,')'); &#125; &#125; if(m&gt;6 &amp;&amp; n%2 == 0)&#123; for(int i=0;i&lt;m;i++)mp(0,i,'('); for(int i=0;i&lt;m;i++)mp(n-1,i,')'); &#125; if(swped)&#123; for(int i=0;i&lt;m;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; &#125;else&#123; for(int i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl; &#125; &#125; return 0;&#125; Prob E. 模拟 Solved by YangDavid at 00:17 (+) 模拟题意即可。 点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * Author : YangDavid * Created Time : 2019年05月26日 星期日 21时32分31秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;int n;char a[10][10], op[10];void Clock(char&amp; a, char&amp; b, char &amp;d, char &amp;e) &#123; swap(a, d); swap(d, e); swap(e, b); &#125;void rc(char &amp;a, char &amp;b, char &amp;d,char &amp;e) &#123; swap(b, e); swap(d, e); swap(d, a);&#125;void solve() &#123; scanf("%d", &amp;n); rep(i, 3) scanf("%s", a[i] + 1); rep(i, n) &#123; scanf("%s", op); if(op[0] == '1') &#123; if(op[1] == 'C') &#123; Clock(a[1][1], a[1][2], a[2][1], a[2][2]); &#125; else rc(a[1][1], a[1][2], a[2][1], a[2][2]); &#125; else if(op[0] == '2') &#123; if(op[1] == 'C') &#123; Clock(a[1][2], a[1][3], a[2][2], a[2][3]); &#125; else rc(a[1][2], a[1][3], a[2][2], a[2][3]); &#125; else if(op[0] == '3') &#123; if(op[1] == 'C') &#123; Clock(a[2][1], a[2][2], a[3][1], a[3][2]); &#125; else rc(a[2][1], a[2][2], a[3][1], a[3][2]); &#125; else if(op[0] == '4') &#123; if(op[1] == 'C') &#123; Clock(a[2][2], a[2][3], a[3][2], a[3][3]); &#125; else rc(a[2][2],a[2][3], a[3][2], a[3][3]); &#125; &#125; rep(i, 3) printf("%s\n", a[i] + 1);&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; solve(); &#125; return 0;&#125; Prob F.Prob G.Prob H.Prob I. 广义后缀自动机 Solved by hdmmblz at 04:55 (+) Description待更。 Solution待更。 Code点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;const int mod=1e9+7;struct suffix_automaton&#123; string s; int son[1000005][26],pre[1000005],step[1000005],last,total,rt[1000005]; void push_back(int v) &#123; step[++total]=v; &#125; void init() &#123; total=last=0; memset(son,0,sizeof(son)); memset(pre,0,sizeof(pre)); memset(step,0,sizeof(step)); pre[0]=-1; &#125; void extend(int ch)&#123; push_back(step[last]+1); int p=last,np=total,q,nq; rt[np]++; for(;!son[p][ch]&amp;&amp;p!=-1;p=pre[p])son[p][ch]=np; if(p==-1)pre[np]=0; else &#123; q=son[p][ch]; if(step[q]!=step[p]+1) &#123; push_back(step[p]+1); nq=total; memcpy(son[nq],son[q],sizeof(son[q])); pre[nq]=pre[q]; pre[q]=pre[np]=nq; rt[nq]=rt[q]; for(;son[p][ch]==q;p=pre[p])son[p][ch]=nq; &#125; else pre[np]=q; &#125; last=np; &#125;&#125;suf;ll quickpow(ll x,ll n)&#123; if(n==0)return 1; ll res=quickpow(x*x%mod,n/2); if(n%2)res=res*x%mod; return res;&#125; int n,m,p,mxlen; string str[1000005];ll ans[1000005],h[1000005],val[1000005];int vis[1000005];ll fac[1000005],inv[1000005],pw;int main()&#123; int i,j; suf.init(); scanf("%d",&amp;n); for(i=0;i&lt;n;i++)cin&gt;&gt;str[i],mxlen=max(mxlen,(int)str[i].size()); for(i=0;i&lt;n;i++)scanf("%lld",&amp;h[i]); pw=1; for(i=1;i&lt;=mxlen;i++) &#123; pw=pw*26%mod; fac[i]=(fac[i-1]+pw)%mod; inv[i]=quickpow(fac[i],mod-2); &#125; for(i=0;i&lt;n;i++) &#123; suf.last=0; for(j=0;j&lt;str[i].size();j++) &#123; int np=suf.son[suf.last][str[i][j]-'a']; if(np==0||suf.step[np]!=j+1) suf.extend(str[i][j]-'a'); else suf.last=np; &#125; &#125; for(i=0;i&lt;n;i++) &#123; p=0; for(j=0;j&lt;str[i].size();j++) &#123; p=suf.son[p][str[i][j]-'a']; int prep=p; while(prep!=-1) &#123; if(vis[prep]==i+1) break; vis[prep]=i+1; if(!val[prep]) val[prep]=h[i]; else val[prep]=val[prep]*h[i]%mod; prep=suf.pre[prep]; &#125; &#125; &#125; for(i=suf.total;i&gt;=1;i--) &#123; (ans[suf.step[suf.pre[i]]+1]+=val[i])%mod; (ans[suf.step[i]+1]-=val[i])%mod; &#125; for(i=1;i&lt;=mxlen;i++)ans[i]=(ans[i]+ans[i-1]+mod)%mod; for(i=1;i&lt;=mxlen;i++)ans[i]=(ans[i]+ans[i-1]+mod)%mod; scanf("%d",&amp;m); while(m--) &#123; int len; scanf("%d",&amp;len); len=min(len,mxlen); printf("%lld\n",ans[len]*inv[len]%mod); &#125; return 0;&#125; Prob J. LIS Solved by hdmmblz at 02:35 (+) Description待更。 Solution待更。 Code点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;using namespace std;const long long int mod = 1e9 + 7;int n,q,i,Q,s1[200005],T,m,s2[200005],sq,ans[200005],val[200005],stk[200005],bag,a[200005];struct node&#123; int pos,num,id;&#125;query[200005];bool cmp(node a, node b)&#123; return a.pos&gt;b.pos;&#125;int fin(int *gg, int l, int r, int x)&#123; int mid; if (gg[r]&lt;=x)return r; while (l &lt; r) &#123; mid=(l+r+1)&gt;&gt;1; if (gg[mid] &lt;= x)l=mid; else r=mid-1; &#125; return l;&#125;int main()&#123; scanf("%d",&amp;T); while (T--) &#123; scanf("%d%d",&amp;n,&amp;q); memset(ans,0,sizeof(ans)); memset(s1,0,sizeof(s1)); memset(s1,0,sizeof(s2)); memset(s1,0,sizeof(val)); memset(s1,0,sizeof(stk)); memset(s1,0,sizeof(a)); bag=n; sq=0; int last=-1; for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); if (last&lt;a[i]) &#123; s1[++sq]=i;s2[sq]=a[i];last=a[i]; &#125; val[i]=sq; &#125; for(i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;query[i].pos,&amp;query[i].num); query[i].id=i; &#125; s2[0]=-1e9;s1[0]=0;s1[sq+1]=s2[sq+1]=1e9; sort(query+1,query+1+q,cmp); for (i=n,Q=1;i&gt;=1;) &#123; if (query[Q].pos == i) &#123; int &amp;res = ans[query[Q].id]; res=0; int left; if (s1[sq]&lt;query[Q].pos) &#123; left= sq; &#125; else left=fin(s1,0,sq,i); if(s1[left]==i)left--; res=left; if (s2[left]&lt;query[Q].num)res++; else &#123; query[Q].num=s2[left]; &#125; if (stk[bag]&gt;query[Q].num) &#123; res+=n-bag+1; &#125; else &#123; if(stk[n]&gt;query[Q].num) &#123; int pps=fin(stk,bag,n,query[Q].num); res+=n-pps; &#125; &#125; Q++; &#125; else &#123; if(stk[bag]&gt;a[i]) &#123; stk[--bag]=a[i--]; continue; &#125; int pos=fin(stk,bag,n,a[i]); stk[pos]=a[i--];bag=pos; &#125; &#125; for (i=1;i&lt;=q;i++)printf("%d\n",ans[i]); &#125; return 0;&#125; Prob K.Prob L. 贪心 Solved by YangDavid at 04:56 (+) Description你开着一家公司生产电脑，一共有 $k$ 天，但是每一天的行情都会有所变化。具体来说，第 $i$ 天收到的客户需求为 $d_i$ 台电脑，购买 1 份原件的价格为 $c_i$ ，将 1 份原件组装成一台电脑的成本 $m_i$ ，每天最多组装 $p_i$ 台电脑。为了起到一定缓冲作用，公司拥有一个仓库，可以无限存放原件，但是从第 $i$ 天到第 $i+1$ 天的时间段里最多存放 $e_i$ 台电脑，并且存放 1 份原件需要 $R_i$ 的费用，存放 1 台电脑需要 $E_i$ 的费用。 现在把上面的信息都给你，你能够满足客户的需求吗？如果可以，你所花费的最小成本是多少？ 数据范围：$T \leq 200$ 组数据，每组 $k\leq 50000$ ，其他值的值域 $[0, 10000]$ Solution这道题直接贪心即可。能否满足客户需求是很平凡的问题，下面具体叙述贪心求最小成本的过程。 首先因为原件没有容量限制，每天买电脑的成本是可以贪心的。第 $i$ 天买电脑的最优成本为 ：$$best_i = \min (c_i, \min_{1\leq j&lt;i} (best_j + \sum_{k=j}^{i-1} R_k))$$实际上直接用一个变量维护一个之前的最优答案即可。 之后用类似于校赛 B 题的做法，我们考虑把电脑购买成本塞进map 里，即直接用 map 维护所有决策，电脑的购买成本。map[i]=j 表示单价为 $i$ 的电脑有 $j$ 个。每次处理需求就是从 map 删去前 $d_i$ 小，然后加进答案；处理仓库缩小的情况就是删去多余的大的元素。这两个直接暴力就可以了，因为每一天最多在 map 里插入一个元素。由此均摊下来复杂度是 $O(T\cdot k\log k)$ 的，可以轻松通过此题。 Code点击显示/隐藏代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* * Author : YangDavid * Created Time : 2019年05月26日 星期日 17时55分19秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define int llconst int maxn = 333333;int k, c[maxn], d[maxn], m[maxn], p[maxn], e[maxn], R[maxn], E[maxn], n;int pref[maxn];map&lt;int, int&gt; mp;void solve() &#123; mp.clear(); int _tot = 0; scanf("%lld", &amp;n); rep(i, n) scanf("%lld%lld%lld%lld", &amp;c[i], &amp;d[i], &amp;m[i], &amp;p[i]); for(int i = 1; i &lt; n; ++i) scanf("%lld%lld%lld", &amp;e[i], &amp;R[i], &amp;E[i]); for(int i = 1; i &lt;= n; ++i) &#123; _tot = min(_tot, e[i - 1]); _tot += p[i]; _tot -= d[i]; if(_tot &lt; 0) &#123; puts("-1"); return ; &#125; &#125; int best = 0x3f3f3f3f; for(int i = 1; i &lt;= n; ++i) &#123; c[i] = min(c[i], best + R[i-1]); best = c[i]; &#125; pref[1] = E[1]; for(int i = 2; i &lt;= n; ++i) pref[i] = pref[i - 1] + E[i]; ll ans = 0; _tot = 0; for(int i = 1; i &lt;= n; ++i) &#123; int np = m[i] + c[i] - pref[i - 1], del = d[i]; mp[np] += p[i], _tot += p[i]; while(del) &#123; auto it = mp.begin(); int elim = min(it-&gt;second, del); del -= elim, it-&gt;second -= elim; _tot -= elim; ans += 1LL * elim * (it-&gt;first + pref[i - 1]); if(it-&gt;second == 0) mp.erase(it); &#125; del = max(0LL, _tot - e[i]); while(del) &#123; auto it = mp.rbegin(); int elim = min(it-&gt;second, del); del -= elim, it-&gt;second -= elim; _tot -= elim; if(it -&gt; second == 0) mp.erase(it-&gt;first); &#125; &#125; printf("%lld\n", ans);&#125;signed main() &#123; int T; scanf("%lld", &amp;T); while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治学习笔记]]></title>
    <url>%2F2019%2F05%2F23%2F%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2019年ACM-ICPC全国邀请赛（陕西）游记]]></title>
    <url>%2F2019%2F05%2F19%2F2019%E5%B9%B4ACM-ICPC%E5%85%A8%E5%9B%BD%E9%82%80%E8%AF%B7%E8%B5%9B%EF%BC%88%E9%99%95%E8%A5%BF%EF%BC%89%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2019年ACM-ICPC全国邀请赛（陕西）Overview Status A B C D E F G H I J K L M Contest 0:03 2:44 3:17 1:46 1:35 Upsolve OK OK OK OK OK Attempt + + +1 + + AC count 363 3 275 153 12 1 0 10 2 41 0 347 220 Tag Coding ? ? ? ? ? ? ? ? ? ? ? ? ? Thinking ? ? ? ? ? ? ? ? ? ? ? ? ? Stars 注：$\mathcal O$ 表示口头通过。 第一次参加线下真正意义上的 ICPC，拿了个位次中等的银奖。还是太菜了啊，比赛经验不够丰富，比赛战略不是很对，后期一直在卡题造成了后两个小时的全面划水，一道真正有价值、有技术含量的题目都没有做出来。 Solved during contest: 5/13 Upsolved: 5/13 Orally upsolved: 5/13 Rank: 79/362 Contest MaterialsNothing yet Replay 开始签掉了 A 题，但是马上我就把 M 题读错了，以为是路程之和，然后写了个特别麻烦的二分，结果过不了样例，发现事实上是路程的最大值，就是个极其思博的二分，60行搞定，总算 1A 了。L 题 sl 和 whr 找到了正确结论但是没有证明，可是我觉得不太靠谱没让他们交，结果过掉 M 之后 L 胡乱交了一下也过掉了。这两出合计浪费了近60分钟的宝贵前期时间，奠定了爆炸了基础。 之后 C 题发现是思博题，然后 D 题一看也是个弱智背包，但可能会略卡常数，就先写 C 了。结果 C 题死活过不去样例，正当焦急之时才看到 Clarification 把样例改了，提交上去 1A 了。这中间又浪费了 10 分钟时间。D 题写得还蛮快，后面又发现可以 bitset 优化，大概总共只写了20分钟的样子，进行了仔细的检查，却没有发现 bitset 开小了，荣获一个 WA 。好在 5 分钟左右反应了过来，改掉了，AC了。 之后就是无比自闭的后期。我一下口胡了当时场上过得最多的 J 题，就是个点分治裸题。可是尴尬的是我们三个没有一个人会写点分治。最后打算试着写一写，把剩下的时间都押在这道题上，于是就凉了，写得一塌糊涂，最后放弃治疗。 感觉问题最大的出在后期，我只看了 J 题这一道题，别的题目都没有进行深入的思考，这么做是极不明智的。其实当时还有 H 题是个蛮简单的题目，可是就是没有看到。后期的战术还是很关键的。 经验教训： 前期一定要又快又稳，必须把题目读清楚，最好手算样例。 后期千万不要三个人都卡在同一道题目上面，还是要分好工。 交代码前、过不了样例时仔细看 Clarification。 继续保持交题之前检查代码的习惯，争取所有题目都一遍过。（这一次比赛我们总共就提交了 6 次代码，5 个AC） Tutorials解题/补题顺序： Prob A. 签到排序之后从小到大能选就选，贪心即可。 Prob B.Prob C. 签到假的几何题，总共就两种情况，分类讨论即可。 Prob D. DP显然的 dp 是可以通过的。因为每个 $c_i$ 都是 100 的倍数！这道题感觉就是出题人在逗你玩。并且这种 DP 是可行性 DP，可以用 bitset 加速。 复杂度 $O(T \cdot \frac{n \cdot c}{100} \frac{n}{w})$ ，甚至不到 $10^7$ Prob E.Prob F.Prob G.Prob H.Prob I.Prob J.Prob K.Prob L. 分类讨论按照 4 的余数分类讨论即可。 Prob M. 二分 二分思博题。]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam Round 2 游记]]></title>
    <url>%2F2019%2F05%2F19%2FGoogle-Code-Jam-Round-2-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Google Code Jam Round 2Overview Status A B C D Contest 22 - 26 (0) Upsolve Attempt + +2 AC count 1052 269 171 73 Tag 思维 类欧几里得 Coding Easy ? Mid- ? Thinking Easy+ ? Easy+ ? Stars ★ ★ 注：$\mathcal O$ 表示口头通过。 Solved during contest: 2/4 48/100 pt Upsolved: 2/4 48/100 pt Orally upsolved: 2/4 48/100 pt Rank: 315/3600 C 题撞大运了，正好就是之前写过的在有理数开区间内寻找分母最小的有理数的模板题，套模板就 AC 了。 所以。。可以拿到一件 Google 衬衫了？感觉海星。 P.S. 正式比赛前不要打其他比赛！！！真的会 rp– ！！！第二天陕西邀请赛就炸飞了，从来没有碰见过前期读错题的情况有没有！ Contest Materials比赛及题解链接 Replay打省赛之前要打 GCJ ，从 22:00 到 00:30 ，也真的是有点刺激。 开场看了 A ，和 CYY 稍微讨论了一下发现是思博题，一发 AC 了。 看了眼 B，感觉是个乱搞、调参数的交互题。 CYY 提议看 C，开始没懂题目要干什么，后来发现就是给定一个有理数开区间，要在这个区间里找到一个分母最小的有理数。这不就是模板题吗？我打开博客，复制了 Opentrains 1513 训练报告 里的模板，仔细写了一会儿，交了之后一发 AC 了。可是 cyy wa 了。分析原因可能是 INF 开得过大了，我顿时发现我也开得有点大，有很大概率会 FST。于是改成 $10^9 +7$ 交了一发，又有点担心，于是把所有数都改成 __int128 试了一下，好在最后也是 AC 了。 CYY 提议 D 题写高斯消元法，可是特殊情况有点多，后期没来得及写完。于是就两道题 48 分滚粗了。可是貌似 C 题会正解的人不多？所以排名看来也还可以，可以轻易拿到 GCJ 的 T 恤了啊，感觉海星。但是这对第二天的 debuff 可不小啊 QAQ，省赛就打得一坨屎。 TutorialsProb A. 去重Description你要给两种化学元素赋上质量 $v_1,v_2$，给你了 $n$ 种分子，由二元组 $(c_1,c_2)$ 表示，代表有 $c_1$ 个 1 号原子，有 $c_2$ 个 2 号原子构成，然后分子的质量为 $c_1 \cdot v_1+c_2\cdot v_2$。问赋值之后分子按照价值从小到大排序之后按照分子名称编号组成的排列有多少种不同的方式。 Solution显然可以直接钦定 $v_2=kv_1,v_1=1$，然后把 $k$ 当横坐标，每一种分子质量代表纵坐标，则每一分子都可以用一条直线表示。这些直线位于 y 轴右侧交点的横坐标去重后的个数加上 1 即为答案。至于找直线交点，两两枚举然后暴力即可。 每一个测试的时间复杂度 $O(n^2 \log n)$ Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pii;const int maxn = 666;int n, kase;pii pt[maxn];void solve() &#123; set&lt;pii&gt; se; scanf("%d", &amp;n); rep(i, n) scanf("%lld%lld", &amp;pt[i].first, &amp;pt[i].second); for(int i = 1; i &lt;= n; ++i) for(int j = i + 1; j &lt;= n; ++j) &#123; if((pt[i].first-pt[j].first)*(pt[i].second-pt[j].second)&gt;=0) continue; ll nu = abs(pt[i].first - pt[j].first); ll de = abs(pt[i].second - pt[j].second); ll d = __gcd(nu, de); nu /= d, de /= d; if(se.count(&#123;nu, de&#125;)) continue; else &#123; se.insert(&#123;nu, de&#125;); &#125; &#125; printf("Case #%d: %d\n", ++kase, int(se.size()+ 1));&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125; Prob B.留坑。 Prob C. 类欧几里得Description和 A 题相同的背景，这一次我们给出了分子的排列，要你找到任何一种合法的院子质量分配方案 $v_1,v_2$ 使得排列中的分子按照质量从小到大的顺序排列。要求尽量使 $v_1$ 最小，在多组 $v_1$ 已经最小的答案里要求 $v_2$ 最小。 Solution还是和 A 题类似的钦定方法，那么排列的任何两个相邻元素都满足左边小于等于右边，就可以列出来一个一次不等式，解出来会得出一个形如 $x&gt; \frac pq$ 或者 $x&lt;\frac pq$ 的条件，然后把这些条件综合起来即可将问题转化为下面的： 在有理数开区间 $(\frac mn,\frac pq)$ 中找到一个有理数 $\frac xy$ ，使它的分母尽量地小，与此同时分子也尽量地小。 这就是类欧几里得算法论文题！ Opentrains 1513 训练报告 里有这个模板，这里再不厌其烦地把这个算法的内容阐述（摘抄）一遍： 首先，如果 $\frac mn$与 $\frac pq$ 之间有整数，那么问题已经解决了； 否则，一定有$r-l\leq1$。两个数同时减去 $l$ 的整数部分 $[l]$，得到的答案也是等价的。即：问题转化为$m&lt;n,p\leq q$ 的情况。 这时，要让 $y$ 最小， $x$ 一定也要最小，因此，可以两边直接取倒数，得到：$\frac qp &lt; \frac xy &lt; \frac nm$ 这样递归下去即可。可以看到左右边界化为小于1的步骤相当于取模，分子分母量级会减小一半，因此复杂度为 $\log \min(n, q)$。 还要注意一个细节：题目所有数据都是 $10^9$ 的，因此 INF 设为 $10^9+7$ 即可。如果 INF 设得过大，可能反而会溢出，产生意料不到的错误。 每一组测试数据的时间复杂度是 $O(n + \log 10^9)$。 Code点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef __int128 ll;typedef pair&lt;ll, ll&gt; pii;#define ABS(x) ( (x)&gt;0 ? (x) : (-(x)) )#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;struct frac &#123; ll nu, de; frac(ll a = 0, ll b = 1): nu(a), de(b) &#123; simplify(); &#125; void simplify() &#123; if(de &lt; 0) de = -de, nu = -nu; ll g = __gcd(ABS(nu), ABS(de)); nu /= g, de /= g; &#125; void flip() &#123; swap(nu, de); &#125; frac operator + (const frac&amp; rhs) const &#123; ll d = de * rhs.de / __gcd(ABS(de), ABS(rhs.de)); ll u = nu * (d / de) + rhs.nu * (d / rhs.de); return frac(u, d); &#125; frac operator - (const frac&amp; rhs) const &#123; ll d = de * rhs.de / __gcd(ABS(de), ABS(rhs.de)); ll u = nu * (d / de) - rhs.nu * (d / rhs.de); return frac(u, d); &#125; frac operator * (const frac&amp; rhs) const &#123; frac res = frac(nu * rhs.nu, de * rhs.de); res.simplify(); return res; &#125; frac operator - () const &#123; frac ret = *this; if(de &lt; 0) ret.de = -de; else ret.nu = -nu; return ret; &#125; frac operator / (const frac&amp; rhs) const &#123; return *this * frac(rhs.de, rhs.nu); &#125; bool operator &lt; (const frac&amp; rhs) const &#123; return nu * rhs.de &lt; rhs.nu * de; &#125; bool operator == (const frac&amp; rhs) const &#123; return nu * rhs.de == rhs.nu * de; &#125; bool operator &lt;= (const frac&amp; rhs) const &#123; return nu * rhs.de &lt;= rhs.nu * de; &#125; bool operator &gt; (const frac&amp; rhs) const &#123; return nu * rhs.de &gt; rhs.nu * de; &#125; ll floor() &#123; return nu / de; &#125; ll ceil() &#123; return nu / de + (nu % de != 0); &#125;&#125;;frac SearchBetween(frac l, frac r) &#123; l.simplify(), r.simplify(); ll lb = l.floor(); if(lb &gt; 0) l.nu -= lb * l.de, r.nu -= lb * r.de; if(r.nu &gt; r.de) return frac(1 + lb, 1); frac res = SearchBetween(frac(r.de, r.nu), frac(l.de, l.nu)); res.flip(); return frac(lb, 1) + res;&#125;int kase = 0, n;pii pt[6666];frac low(0, 1), high(100000000000LL, 1);void solve() &#123; low = frac(0, 1), high = frac(100000000000LL, 1); printf("Case #%d: ", ++kase); scanf("%d", &amp;n); rep(i, n) read(pt[i].first, pt[i].second); for(int i = 1; i &lt; n; ++i) &#123; ll val = (pt[i].second-pt[i+1].second)*(pt[i].first-pt[i+1].first); if(val == 0) &#123; if(pt[i+1].first &gt; pt[i].first || pt[i+1].second &gt; pt[i].second) continue; else &#123; puts("IMPOSSIBLE"); return; &#125; &#125; else if(val &gt; 0) &#123; if(pt[i+1].first &gt; pt[i].first) continue; else &#123; puts("IMPOSSIBLE"); return; &#125; &#125; else if(val &lt; 0) &#123; if(pt[i+1].second &gt; pt[i].second) &#123; low = max(low, frac(pt[i].first - pt[i+1].first, pt[i+1].second - pt[i].second)); &#125; else if(pt[i+1].second &lt; pt[i].second) &#123; high = min(high, frac(pt[i].first - pt[i+1].first, pt[i+1].second - pt[i].second)); &#125; &#125; &#125; // printf("&gt; low = %lld/%lld, high = %lld/%lld\n", low.nu, low.de, high.nu, high.de); low.simplify(), high.simplify(); if(low &gt; high || low == high) &#123; puts("IMPOSSIBLE"); return; &#125; frac ans = SearchBetween(low, high); write(ans.de); putchar(' '); write(ans.nu); putchar('\n');&#125;int main() &#123; #ifdef FREOPEN freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); #endif int T; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125; Prob D.留坑。]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>类欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSCPC 2018 训练实录]]></title>
    <url>%2F2019%2F05%2F16%2FJSCPC-2018-%E8%AE%AD%E7%BB%83%E5%AE%9E%E5%BD%95%2F</url>
    <content type="text"><![CDATA[2018江苏大学生程序设计竞赛（JSCPC）Overview Status A B C D E F G H I J K Contest 0:13 1:45 2:58 1:01 1:17 4:10 0:45 Attempt +1 + + +1 + + + AC count 122 58 27 95 86 30 120 Tag 模拟 二分 莫队 排序 贪心 思维 容斥 Coding 508 518 2620 ? ? 947 1409 ? ? 817 648 Thinking Easy Easy+ Mid ? ? Easy Easy ? ? Mid Easy Stars ★ Template Red blue green OK * ? $\mathcal{O}$ (0) ★ 注：$\mathcal O$ 表示口头通过。 Solved during contest: 7/11 Upsolved: 7/11 Orally upsolved: 7/11 Rank: 8/156 Contest Materials比赛链接 Tutorials题目难度： Very Easy: A, FEasy: B, G, KMedium Easy: C, J Prob A. 签到 Solved at 00:13 (+1) 模拟题意即可。不要看错题意。由于前三道题目是一个系列，这里把定义的 $h$ 值概念摘抄如下： The h-index of an author is the largest h where he has at least h papers with citations not less than h. 点击显示/隐藏代码 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 444444;int a[maxn], n;ll mn[maxn];int main() &#123; while(~scanf("%d", &amp;n)) &#123; for(int i = 0; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = n; i ; --i) mn[i] = (a[i] + mn[i+1]); for(int i = n; i &gt;= 0; --i) if(i &lt;= mn[i]) &#123; printf("%d\n", i); break; &#125; &#125; return 0;&#125; Prob B. 奇怪的二分 Solved at 01:45 (+) 首先可以看到最大的 $h$ 满足二分性质：小于这个数的所有 $h$ 都可行，大于的都不可行。 考虑二分，考虑如何验证一个 $h$ 是否合法。我们先放上 $h$ 个论文，每篇论文只工作一小时，作为满足要求的 h 篇。然后如果剩下的时间只放在这 $h$ 篇上，这时至少需要的时间是：$$\lceil \frac{h-1-a}{a}\rceil + \lceil \frac{h-2-a}{a}\rceil + \lceil \frac{h-3-a}{a}\rceil + \cdots + \lceil \frac{1-a}{a}\rceil$$但是我们还可以增加一些水论文，即增加一篇工作 $1$ 的论文，然后引用上面的 h 篇。可以发现加过一篇水论文之后，至少需要的时间刚好减去了上式的第一项，即变为了：$$\lceil \frac{h-2-a}{a}\rceil + \lceil \frac{h-3-a}{a}\rceil + \cdots + \lceil \frac{1-a}{a}\rceil$$每增加一篇水论文都会使求和减少一项，而每一项求和只要不小于 0，就至少为 1，因此使用水论文永远是划算的。我们可以发现，检查 h 时，我们应当使用 $\min(0,h-a)$ 份水论文。 对于一个 h，需要的时间至少为 $h + \min(0,h-a)$ 。由此二分即可。 点击显示/隐藏代码 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;ll n, a;bool judge(ll h) &#123; return h + max(h - a, 0LL) &lt;= n;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; a) &#123; ll l = 0, r = n; while(l &lt; r) &#123; ll mid = (l + r) &gt;&gt; 1; if(l == r - 1) mid = r; if(judge(mid)) l = mid; else r = mid - 1; &#125; printf("%lld\n", l); &#125; return 0;&#125; Prob C. 莫队 Solved at 02:58 by YangDavid, thinking whr (+) Description给出数组 $a$ ，有 $q$ 个询问，求区间 $a[l,r]$ 的 $h$ 值。 数据范围：$n,q \leq 10^5$ Solution 1（莫队算法，904 ms / 2000 ms） 回顾求 $h$ 的过程，我们将论文引用次数装进一个计数数组，然后在这个计数数组中从后往前扫，扫到 i 位置时，比较后缀和 $\sum_{j=i}^n a_j$，与当前下标 i ，如果后缀和大的话，我们就找到了答案。 一个比较重要的性质是一个数组加入或删除一个元素之后，其 h 值最多变化 1。由此，根据上面的求 h 过程，我们可以直接 $O(1)$ 地插入删除元素，由此采用莫队算法即可做到 $O(n\sqrt n)$ 的复杂度。 Code 1点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(register int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = getchar(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = getchar();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = getchar();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 302000, maxB = 500;int a[maxn], n, m, pos[maxn], t = 0, lenb;int ans[maxn], cur_ans = 0;struct Query &#123; int l, r, id; &#125; q[maxn];inline bool cmp1(const Query &amp;q1, const Query &amp;q2) &#123;return q1.l &lt; q2.l; &#125;inline bool cmp2(const Query &amp;q1, const Query &amp;q2) &#123; return pos[q1.l] &lt; pos[q2.l] || (pos[q1.l] == pos[q2.l] &amp;&amp; q1.r &lt; q2.r);&#125;int vcnt[maxn], rsum = 0;int DealFirst(int l, int r) &#123;// printf("&gt; Deal First [%d, %d]: \n", l, r); for(int i = l; i &lt;= r; ++i) vcnt[a[i]]++; for(int res = n; res &gt;= 0; --res) &#123; rsum += vcnt[res]; if(rsum &gt;= res) return res; &#125; assert(false);&#125;void Ins(int x) &#123; vcnt[x]++; if(x &gt;= cur_ans) rsum++; if(rsum - vcnt[cur_ans] &gt;= cur_ans + 1) &#123; rsum -= vcnt[cur_ans]; cur_ans++; &#125;&#125;void Del(int x) &#123; vcnt[x]--; if(x &gt;= cur_ans) rsum--; if(rsum &lt; cur_ans) &#123; cur_ans--; rsum += vcnt[cur_ans]; &#125;&#125;void solve() &#123; memset(vcnt, 0, sizeof(int) * (n + 10)); cur_ans = rsum = 0; rep(i, n) read(a[i]); rep(i, m) &#123; read(q[i].l, q[i].r); q[i].id = i; &#125; sort(q + 1, q + m + 1, cmp1); t = sqrt(m + 0.5), lenb = m / t; for(int i = 1; i &lt;= m; ++i) pos[i] = (i - 1) / lenb + 1; sort(q + 1, q + m + 1, cmp2); cur_ans = DealFirst(q[1].l, q[1].r); ans[q[1].id] = cur_ans; int cur_l = q[1].l, cur_r = q[1].r; for(int qn = 2; qn &lt;= m; ++qn) &#123; int nl = q[qn].l, nr = q[qn].r;// printf("&gt; Deal [%d, %d]: \n", nl, nr); if(cur_r &lt; nr) for(int i = cur_r + 1; i &lt;= nr; ++i) Ins(a[i]); if(cur_r &gt; nr) for(int i = cur_r; i &gt; nr; --i) Del(a[i]); if(cur_l &gt; nl) for(int i = cur_l - 1; i &gt;= nl; --i) Ins(a[i]); if(cur_l &lt; nl) for(int i = cur_l; i &lt; nl; ++i) Del(a[i]); ans[q[qn].id] = cur_ans; cur_l = nl, cur_r = nr; &#125; rep(i, m) write(ans[i]), putchar('\n');&#125;int main() &#123; while(~scanf("%d%d", &amp;n, &amp;m)) solve(); return 0;&#125; Prob D.留坑。 Prob E.留坑。 Prob F. 排序 Solved at 01:01 (+1) 直接排序即可，但是可能炸 long long，需要用 __int128。思博题。 点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef __int128 ll;const int maxn = 33333;int n;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;struct item &#123; ll a, b, c; int id; bool operator &lt; (const item&amp; r) const &#123; ll lhs = (a + b) * (r.a + r.b + r.c); ll rhs = (r.a + r.b) * (a + b + c); if(lhs != rhs) return lhs &lt; rhs; else return id &lt; r.id; &#125; void qread() &#123; read(a), read(b), read(c); &#125;&#125; a[maxn];int main() &#123; while(~scanf("%d", &amp;n)) &#123; rep(i, n) a[i].qread(), a[i].id = i; sort(a + 1, a + n + 1); rep(i, n) printf("%d%c", a[i].id, " \n"[i == n]); &#125; return 0;&#125; Prob G. 模拟 首先，判断 c 的个数是否相同，然后判断 c 分割开的各个只由 a,b 组成的部分是否等价。 其次，如何判断两个只由 a,b 组成的部分是否等价？ab 可以交换为 ba，因此可以直接将两个部分排好序，变为若干个 a 加若干个 b 的形式。然后由于 aa, bb 可以直接消去，按照奇偶性， a, b 的奇偶相同则等价。 点击显示/隐藏代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 11111;string s, t;vector&lt;pii&gt; ss, tt;int main() &#123; while(cin &gt;&gt; s &gt;&gt; t) &#123; ss.clear(), tt.clear(); int a = 0, b = 0; for(auto g : s) &#123; if(g == 'c') &#123; ss.emplace_back(a&amp;1, b&amp;1); a = b = 0; &#125; else if(g == 'a') a++; else if(g == 'b') b++; &#125; ss.emplace_back(a&amp;1, b&amp;1); a = b = 0; for(auto g : t) &#123; if(g == 'c') &#123; tt.emplace_back(a&amp;1, b&amp;1); a = b = 0; &#125; else if(g == 'a') a++; else if(g == 'b') b++; &#125; tt.emplace_back(a&amp;1, b&amp;1); a = b = 0; if(ss.size() != tt.size()) &#123; puts("No"); continue; &#125; int sz = ss.size(), ok = true; for(int i = 0; i &lt; sz; ++i) &#123; if(ss[i].first != tt[i].first || ss[i].second != tt[i].second) &#123; puts("No"); goto tag; &#125; &#125; puts("Yes"); tag:; &#125; return 0;&#125; Prob H.留坑。 Prob I.留坑。 Prob J. 思维题明天再写。 点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 122222;const int MOD = 1000000007;int muln(int x, int y) &#123; return 1LL* x * y % MOD; &#125;int p2[maxn], n;string s;int main() &#123; p2[0] = 1; for(int i = 1; i &lt;= 102000; ++i) p2[i] = muln(p2[i-1], 2); while(cin &gt;&gt; n &gt;&gt; s) &#123; reverse(s.begin(), s.end()); while(int(s.length()) &lt; n) s += '0'; reverse(s.begin(), s.end()); int zero = 0, ans = 1; for(int i = 0; i &lt; n; ++i) &#123; if(s[i] == '0') zero++; else &#123; ans = muln(ans, muln(p2[zero]-1, p2[n-i-1])); &#125; &#125; printf("%d\n", ans % MOD); &#125; return 0;&#125; Prob K. 容斥毒瘤分类讨论容斥题，whr 写的，我没仔细看。 点击显示/隐藏代码 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;ll a,b,c,d;ll ans;int main() &#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d) &#123; ans=0; ll tmp1=d/2018-(c-1)/2018; ans+=tmp1*(b-a+1); ll tmp2=d/1009-(c-1)/1009; ans+=(tmp2-tmp1)*(b/2-(a-1)/2); ll tmp3=b/2018-(a-1)/2018; ans+=tmp3*(d-c+1); ll tmp4=b/1009-(a-1)/1009; ans+=(tmp4-tmp3)*(d/2-(c-1)/2); //cout&lt;&lt;tmp1&lt;&lt;" "&lt;&lt;tmp2&lt;&lt;" "&lt;&lt;tmp3&lt;&lt;" "&lt;&lt;tmp4; cout&lt;&lt;ans-tmp1*tmp4-tmp2*tmp3+tmp1*tmp3&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 559 (Div. 1) 比赛记录]]></title>
    <url>%2F2019%2F05%2F13%2FCodeforces-Round-559-Div-1-%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Codeforces Round 559 (Div. 1)Overview Status A B C D E F Contest 00:21 (2) 01:38 Upsolve OK AC OK AC Attempt + * +1 * AC count 415 204 258 77 2 1 Tag 贪心 构造 拓扑排序 结论 Coding 1577 489 2763 1307 ? ? Thinking Easy Mid- Easy+ Mid ? ? Stars ★ ★ ★ 又一次打 Div. 1，题目质量还不错。前期一直在写 C 题的线段树，结果 B 题构造题却没时间做了。猜了好几个结论，总算猜到正确的了，但是没来得及提交。还是有点遗憾的，微微掉了 5 分 rating ，不过也无妨，毕竟还是要在比赛中不断成长的。 Solved during contest: 2/6 Upsolved: 4/6 Orally upsolved: 4/6 Rank: 246/425 Rating: 2052 (-5) Contest Materials比赛编号：1158 比赛链接 官方题解连接 TutorialsProb A. 贪心模拟题意贪心即可。需要特判一些情况。 点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 555555;ll b[maxn], g[maxn], n, m, ming = 0x3f3f3f3f, maxb = 0;int main() &#123; read(n, m); rep(i, n) read(b[i]), maxb = max(maxb, b[i]); rep(i, m) read(g[i]), ming = min(ming, g[i]); if(maxb &gt; ming) &#123; puts("-1"); return 0; &#125; multiset&lt; int, greater&lt;int&gt; &gt; boys; ll ans = 0, rem = m - 1; for(int i = 1; i &lt;= n; ++i) ans += 1LL * b[i] * m, boys.insert(b[i]); if(m == 1) &#123; if(maxb == g[1]) printf("%lld\n", ans); else puts("-1"); return 0; &#125; else if(n == 1) &#123; if(ming == b[1]) printf("%lld\n", ans); else puts("-1"); return 0; &#125; for(int i = 1; i &lt;= m; ++i) if(g[i] &gt; maxb) &#123; if(boys.empty()) &#123; puts("-1"); return 0; &#125; ans += (g[i] - *boys.begin()); if(--rem == 0) &#123; boys.erase(boys.begin()), rem = m - 1; &#125; &#125; printf("%lld\n", ans); return 0;&#125; Prob B. 构造Description定义一个字符串 $s$ 的子串 $t$ 是好的，当且仅当这个子串仅仅在 $s$ 中出现了一次。 给定 $n,k$ ，要你构造出一个长度为 $n$ 的 01 串，使得好子串中长度最短的长度为 $k$。 数据范围：$n,k\leq 100000$，$n-k$ 是偶数。 Solution（目前还不清楚证明）令 $d=\frac {n-k}2$ ，当长度没达到 $n$ 的时候，不断尝试放入 $d$ 个 1，之后放入 1 个 0即可。具体实现参见下面代码。 证明留坑。 Code12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;int n , k;int main() &#123; cin &gt;&gt; n &gt;&gt; k; int dif = (n - k) / 2, t = 0; while(t &lt; n) &#123; for(int i = 0; i &lt; dif &amp;&amp; t &lt; n; ++i) &#123; putchar('1'), t++; &#125; if(t &lt; n) putchar('0'), t++; &#125; putchar('\n'); return 0;&#125; Prob C. 线段树优化建图+拓扑排序 或 思维+DFSDescription对于一个 $n$ 个数的排列 $p$，我们定义它在 $i$ 位置的 $next$ 值为 $[i+1,n]$ 范围内第一个大于 $p_i$ 的数，如果不存在，则为 $n+1$ 。如 {3,1,2,4} 的 next 值为 {4,2,4,5} 。 现在给你了一个残缺的 next 值数组，即有些位置的 next 值是不确定的。你需要根据 next 数组构造出任何一个满足条件的排列，或者报告没有可能的 next 数组。 数据范围 $n\leq 5\cdot 10^5$ Solution考虑建出大小关系图，让小数向大数连边。首先，显然 $i\to nxt(i)$ 之间一定是有边的。然后，可以发现 $\forall x\in [i+1,nxt(i)-1]$ ，i 没有与 x 连边，必然说明 $x&lt;i$ 。事实上连完这些边也足够了，跑一下拓扑排序即可得到最后结果。上面连边的过程用线段树优化建图即可完成。我场上的解法稍微观察了一些其他性质，发现每个位置最多连两条边，然后是用了个支持区间覆盖的线段树实现的。这类解法时间复杂度 $O(n\log n)$ ，十分显然。 线段树解法代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 555555;int n, a[maxn], nxt[maxn], fa[maxn];vector&lt;int&gt; G[maxn];#define lson (o &lt;&lt; 1)#define rson (o &lt;&lt; 1 | 1)int node[maxn * 4];void pushdown(int o) &#123; if(node[o] != 0) &#123; node[lson] = node[o]; node[rson] = node[o]; node[o] = 0; &#125;&#125;void modify(int o, int l, int r, int ql, int qr, int v) &#123; if(ql &gt; qr) return; if(ql &lt;= l &amp;&amp; r &lt;= qr) &#123; node[o] = v; return; &#125; pushdown(o); int mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid) modify(lson, l, mid, ql, qr, v); if(qr &gt; mid) modify(rson, mid + 1, r, ql, qr, v);&#125;void recover(int o, int l, int r, int *arr) &#123; if(l == r) &#123; arr[l] = node[o]; return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(o); recover(lson, l, mid, arr); recover(rson, mid + 1, r, arr);&#125;void solve() &#123; read(n); rep(i, n) read(a[i]), G[i].clear(); vector&lt;int&gt; indeg(n + 10, 0); G[n + 1].clear(); memset(nxt, -1, sizeof (int) * (n + 15)); modify(1, 1, n, 1, n, -1); set&lt;int&gt; bar; for(int i = 1; i &lt;= n; ++i) if(a[i] != -1) &#123; nxt[i] = a[i]; while(!bar.empty() &amp;&amp; i &gt;= *bar.begin()) bar.erase(bar.begin()); if(!bar.empty() &amp;&amp; a[i] &gt; *bar.begin()) &#123; puts("-1"); return; &#125; else &#123; modify(1, 1, n, i + 1, a[i] - 1, i); bar.insert(a[i]); &#125; &#125; recover(1, 1, n, fa); rep(i, n) &#123; if(nxt[i] != -1 &amp;&amp; nxt[i] != n + 1) G[i].push_back(nxt[i]), indeg[nxt[i]]++; if(fa[i] != -1 &amp;&amp; fa[i] != n + 1) G[i].push_back(fa[i]), indeg[fa[i]]++; &#125; queue&lt;int&gt; q; vector&lt;int&gt; ans(n + 10, 0); int cur = 0; rep(i, n) if(indeg[i] == 0) q.push(i); while(!q.empty()) &#123; int tp = q.front(); q.pop(); ans[tp] = ++cur; for(auto g : G[tp]) &#123; if(--indeg[g] == 0 &amp;&amp; g != n + 1) q.push(g); &#125; &#125; rep(i, n) printf("%d%c", ans[i], " \n"[i == n]);&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125; 另一类做法留坑。 Prob D. 优雅结论Description给定 $n$ 个点的位置以及长度为 $n-2$ 的仅包含 L R 两种字母的字符串，要求构造一个 $[1,n]$ 的排列，使得将点按照 $p_1 \to p_2 \to p_3 \to \cdots \to p_n$ 的顺序连线时，满足： 连的线互不相交 对于任意 $i\in \{2,3,\cdots,n-1\}$ ，如果 $s_{i-1}=L$ ，则 $p_{i-1} \to p_i \to p_{i+1}$ 这段折线是向左拐；否则是向右拐 如果无法构造出来，就输出 -1 。 数据范围：$n\leq 2000$ Solution我们断言永远可以构造得出这样的排列，构造方法如下： 取 $n$ 个点形成的凸包上的任何一点为起点（这一步可以直接取 y 坐标最小的），然后将剩下的点按照极角排序，如果这一步要求的是 L ，则选极角最大的点；否则选极角最小的点。显然这样做满足了左拐右拐的条件，并且容易归纳地证明这样的构造是不会相交的。 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * Author : YangDavid * Created Time : 2019年05月29日 星期三 18时12分50秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 2222;struct Point &#123; ll x, y; Point(ll xp=0, ll yp=0): x(xp), y(yp) &#123; &#125; Point operator - (const Point&amp; rhs) &#123; return Point(x-rhs.x, y-rhs.y); &#125; void scan() &#123; scanf("%lld%lld", &amp;x, &amp;y); &#125;&#125; p[maxn];int n, vis[maxn], cur;char s[maxn];ll cross(Point A, Point B) &#123; return A.x*B.y - A.y*B.x; &#125;bool Left(Point pt, Point O, Point A) &#123; return cross(A-O, pt-O) &gt; 0;&#125;bool Right(Point pt, Point O, Point A) &#123; return cross(A-O, pt-O) &lt; 0;&#125;int main() &#123; scanf("%d", &amp;n); rep(i, n) p[i].scan(); scanf("%s", s + 1); cur = 1; rep(i, n) if(p[i].y &lt; p[cur].y) cur = i; vector&lt;int&gt; ans; ans.push_back(cur); rep(i, n - 2) &#123; vis[cur] = true; int has = false, idx = -1; rep(j, n) if(!vis[j]) &#123; if(!has) has = true, idx = j; else &#123; if(s[i] == 'L' &amp;&amp; Right(p[j], p[cur], p[idx])) idx = j; else if(s[i] == 'R' &amp;&amp; Left(p[j], p[cur], p[idx])) idx = j; &#125; &#125; cur = idx; vis[cur] = true; ans.push_back(cur); &#125; rep(i, n) if(!vis[i]) ans.push_back(i); for(auto g : ans) printf("%d ", g); printf("\n"); return 0;&#125; Prob E.Prob F.]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>拓扑排序</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Comet OJ Contest #3 比赛报告]]></title>
    <url>%2F2019%2F05%2F10%2FComet-OJ-Contest-3-%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Comet OJ Contest #3Overview Status A B C D E F Contest 0:07 0:30 1:39 2:33 Upsolve OK OK OK OK Attempt + + +1 +1 AC count 559 272 49 14 4 1 Tag 暴力 贪心 dp 线性基 Coding Easy Easy blue blue ? ? Thinking Easy Easy Easy+ Easy+ ? ? Stars ★ ★ 注：$\mathcal O$ 表示口头通过。 Solved during contest: 4/6 Upsolved: 4/6 Orally upsolved: 4/6 Rank: 11/642 差点进前 10 拿小裙子系列。。感觉这一场是后期疯狂卡常数的比赛。C 题我的 dp 是 $O(nm\log m)$ 的，卡了下常数才通过；D 题是带修改区间线性基模板题（ CF587E ），我直接魔改了一下 CF 跑得最快的 whzzt 的代码就通过了。 Contest Materials比赛链接 ReplayTutorialsProb A.Prob B.Prob C.Prob D.Prob E.Prob F.]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 XJTU ACM 校赛游记]]></title>
    <url>%2F2019%2F05%2F09%2F2019-XJTU-ACM-%E6%A0%A1%E8%B5%9B%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Contest NameOverview Status A B C D E F G H I J K L M Contest Upsolve * * OK * OK OK OK OK OK Attempt AC count Tag 模拟 组合 Coding ? ? ? ? ? ? ? ? ? ? ? ? ? Thinking ? ? ? ? ? ? ? ? ? ? ? ? ? Stars ★ Template Red blue green OK * + ? $\mathcal{O}$ (0) ★ 校赛打自闭了。至少 2 道很简单的题目没有看，一直试图用 NTT 去卡 E 题的常数，导致后期崩盘。 Solved during contest: 6/13 Upsolved: 10/13 Rank: 3/180 Contest MaterialsTutorials解题/补题顺序： Very Easy: Prob A.Prob B.Prob C.Prob D.Prob E. NTT 或 组合数学题意csf 热爱运动，经常下去玩跑步，不仅练就了堪比埼玉的武功，还保护了自己一头乌黑浓密的头发…… 你在二维坐标中跑步，初始位置 $(0,0)$ ,然后你跑了 $n$ 步 从 $(i,0)$ 可以跑到 $(i+1,0),(i+1,1),(i+1,2),(i,0),(i-1,1),(i-1,2)$ 从 $(i,1)$ 可以跑到 $(i+1,0),(i+1,1),(i+1,2),(i,1),(i-1,0),(i-1,2)$ 从 $(i,2)$ 可以跑到 $(i+1,0),(i+1,1),(i+1,2),(i,2),(i-1,0),(i-1,1)$ 每次 csf 跑步都不想跑的太远，于是csf想考考你，有多少种跑步方式使得你的 $x$ 坐标最后落在 $[-m,m]$ 答案对 $998244353$ 取模输出。 数据范围：$n, m \le 10^6$ 题解首先，三种 $y$ 坐标可以转移到的状态都是对称的，因此可以直接忽略 $y$ 坐标的影响，只关注有 1 种方式使得坐标不变，3 种方式使之 +1，2 种方式使之 -1。写成生成函数的形式，我们得到简化版题意：求下面多项式的次数在 $[-m,m]$ 之间的所有系数之和。$$(3x+1+\frac{2}{x})^n$$这也就是求 $(3x^2+x+2)^n$ 在 $[n-m,n+m]$ 的系数之和。一种显然的做法就是将 $3x^2+x+2$ 视为 $2n$ 次多项式，直接进行快速傅里叶变换，然后对变换后的式子每个点都求快速幂。这么做时间复杂度是 $O(n\log n)$ 的，可是由于 NTT 常数稍大，毒瘤的出题人故意卡掉了这种做法。这也是我最后一小时没来得及看其它题目，被爆踩的原因。 【UPD】貌似手动加上 #pragma GCC optimize(&quot;O3&quot;, &quot;Ofast&quot;) 就可以 AC 了。。。自闭了。 点击查看NTT解法代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch)) &#123; if(ch == '-') f -1; ch = gc(); &#125; while( isdigit(ch)) &#123;x = x * 10 + ch - 48; ch = gc(); &#125; x *= f;&#125;template&lt;typename T, typename ... Args&gt; void read(T&amp; x, Args&amp;... args) &#123; read(x), read(args...);&#125;const int g = 3;const int MOD = 998244353;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;int inv(int x) &#123; return qpow(x, MOD - 2); &#125;const int ginv = inv(g);const int maxn = 12004000;int l, r[maxn], lim, liminv;void ntt(int* a, int dft) &#123; for(int i = 0; i &lt; lim; ++i) &#123; if(i &lt; r[i]) swap(a[i], a[r[i]]); &#125; for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; int wn = qpow(dft==1 ? g : ginv, (MOD-1)/(mid&lt;&lt;1)); for(int len = mid &lt;&lt; 1, j = 0; j &lt; lim; j += len) &#123; int w = 1; for(int k = 0; k &lt; mid; ++k, w = muln(w, wn)) &#123; int x = a[j + k], y = muln(w, a[j+k+mid]); a[j+k] = mo(x + y); a[j+k+mid] = mo(x - y); &#125; &#125; &#125; if(dft == -1) &#123; for(int i = 0; i &lt; lim; ++i) a[i] = muln(a[i], liminv); &#125;&#125;void ntt_init(int degA, int degB) &#123; lim = 1, l = 0; while(lim &lt;= degA + degB) lim &lt;&lt;= 1, l++; liminv = inv(lim); for(int i = 0; i &lt; lim; ++i) r[i] = ( (r[i&gt;&gt;1]&gt;&gt;1) | ( (i&amp;1) &lt;&lt; (l-1)));&#125;void ntt_qpow(int *A, int degA, int p) &#123; ntt(A, 1); for(int i = 0; i &lt; lim; ++i) A[i] = qpow(A[i], p); ntt(A, -1);&#125;void solve() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); ntt_init(2 * n, 0); int *a = new int[lim]; a[0] = 2, a[1] = 1, a[2] = 3; ntt_qpow(a, 2, n); int deg = 2 * n, ans = 0; for(int i = max(0, n-m); i &lt;= deg &amp;&amp; i &lt;= n + m; ++i) ans = mo(ans + a[i]); printf("%d\n", ans); delete[] a;&#125;int main() &#123; int T; T = 1; while(T--) solve(); return 0;&#125; 正解是线性时间复杂度的。我们直接对 $(3x^2+x+2)^n$ 按照多项式定理展开，推一推式子：$$\begin{aligned}ans &amp;= (\sum_{i+j+k=n} {\binom{n}{i,j,k}} 3^i 2^{n-i-j} x^{2i+j}) \text{‘s coefficients in [n-m,n+m]} \\ &amp;= \sum_{i=0}^n \sum_{j} \binom{n}{i,j,k} 3^i 2^{n-i-j}, \text{where } \max(0,n-m-2i) \leq j \leq \min(n+m-2i,n) \\ &amp;= \sum_{i=0}^n 3^i 2^{n-i} \binom{n}{i} \sum_{j} 2^{-j} \binom{n-i}{j}\end{aligned}$$约定 $g=2^{-1} \bmod 998244353$ ，我们单独处理后面的式子。记其为：$$A(st,ed,c) = \sum_{i=st}^{ed} \binom ci g^i$$再记录一个前缀函数，为：$$S(n,m) = \sum_{i=0}^{m} \binom {n}{i} g^i$$我们可以得到前缀函数的两个重要递推公式：$$\begin{align}S(n,m+1) &amp;= S(n,m) + \binom{n}{m+1}g^{m+1} \tag 1 \\S(n+1,m) &amp;= \sum_{i=0}^{m} \binom{n+1}{i} g^{i} \\ &amp;= \sum_{i=0}^{m} \binom{n}{i} g^{i} + \sum_{i=1}^{m}\binom{n}{i-1}g^i\\ &amp;= S(n,m) + g\sum_{i=0}^{m-1}\binom n{i-1} g^{i-1}\\ &amp;=(g+1)S(n,m) - 2\binom{n}{m}g^{m+1} \tag 2\end{align}$$如果把 $n,m$ 视为区间的两个端点的话，有了上面的推导，我们可以 $O(1)$ 地将区间延长或缩短一个单位了。等等，这不就是莫队的基本思想吗？那么这道题我们把询问离线下来就可以莫队了！我们就有了 $O(n\sqrt{n})$ 的做法了。但事实上直接按顺序计算就可以保证复杂度，因为我们有更好的分析。这道题目左右端点都在递增，线段上每个点只会被加入区间或被删除一次，由此均摊下来就是 $O(1)$ 的。因此我们就得到了一种线性的优秀做法。 点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 1000020, MOD = 998244353;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int inv(int x) &#123; return qpow(x, MOD - 2); &#125;int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125;int fac[maxn], ifac[maxn];int C(int n, int m) &#123; if(n &lt; m) return 0; return muln(fac[n], muln(ifac[m], ifac[n-m]));&#125;const int INF = 0x3f3f3f3f;int p2[maxn], pi2[maxn], p3[maxn];int mm[2] = &#123;-INF, -INF&#125;, nn[2] = &#123;-1, -1&#125;, ans[2] = &#123;-1, -1&#125;;const int inv2 = inv(2);const int G = inv2 + 1, invG = inv(G);int brute(int n, int m) &#123; int res = 0; for(int i = 0; i &lt;= m; ++i) res = mo(res + muln(pi2[i], C(n, i))); return res; &#125;int S(int n, int m, int tp) &#123; if(m &lt; 0) &#123; mm[tp] = -1, nn[tp] = n; return ans[tp] = 0; &#125; if(m &gt; n) m = n; if(mm[tp] == -INF) &#123; mm[tp] = m, nn[tp] = n; return ans[tp] = brute(n, m); &#125; else &#123; for(; mm[tp] &lt; m; ++mm[tp]) ans[tp] = mo(ans[tp] + muln(pi2[mm[tp]+1], C(nn[tp],mm[tp]+1))); for(; mm[tp] &gt; m; --mm[tp]) ans[tp] = mo(ans[tp] - muln(pi2[mm[tp]], C(nn[tp],mm[tp]))+MOD); for(; nn[tp] &lt; n; ++nn[tp]) ans[tp] = mo(muln(ans[tp],G) - muln(C(nn[tp],mm[tp]),pi2[mm[tp]+1] + MOD)); for(; nn[tp] &gt; n; --nn[tp]) ans[tp] = muln(invG, mo(ans[tp]+muln(C(nn[tp]-1,mm[tp]),pi2[mm[tp]+1]))); return ans[tp]; &#125;&#125;int A(int st, int ed, int c) &#123; if(st &gt; ed) return 0; return mo(S(c, ed, 0) - S(c, st - 1, 1));&#125;void solve() &#123; int n, m, res = 0; scanf("%d%d", &amp;n, &amp;m); for(int i = 0; i &lt;= n; ++i) res = mo(res + muln(muln(muln(p3[i],p2[n-i]),C(n,i)), A(n-m-2*i, n+m-2*i, n-i))); printf("%d\n", res);&#125;int main() &#123; fac[0] = ifac[0] = p2[0] = pi2[0] = p3[0] = 1; for(int i = 1; i &lt;= 1000007; ++i) &#123; fac[i] = muln(fac[i-1], i); pi2[i] = muln(pi2[i-1], inv2); p2[i] = muln(p2[i-1], 2); p3[i] = muln(p3[i-1], 3); &#125; ifac[1000007] = inv(fac[1000007]); for(int i = 1000006; i &gt; 0; --i) ifac[i] = muln(ifac[i+1], i+1); int T = 1; while(T--) solve(); return 0;&#125; 拓展上面的莫队操作还蛮具有启发性的，我们有这么一道类似题目：HDU 6333 Prob F.Prob G.Prob H.Prob I.Prob J.Prob K.Prob L.Prob M.]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集合幂级数、FMT、FWT学习笔记]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0-FMT-FWT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[受这几天看到的不少高维前缀和题目的影响，我决定系统地学习一下集合幂级数的一套理论了。内容主要来自2015年吕凯风（VFleaKing）国家集训队论文《集合幂级数的性质与应用及其快速算法》（pdf版本会放在附录里），包括集合并卷积、集合对称差卷积、子集卷积、快速莫比乌斯变换、快速莫比乌斯反演、快速沃尔什变换及逆变换等，以及附带进行的一些练习。 [TODO] 把练习第一题搞清楚[TODO] 把第三道论文题学会 引言及定义类似数列的生成函数，对于集合，我们引入集合幂级数来解决一些有关集合的动态规划问题。 定义：设 $F$ 是一个域，则称函数 $f:2^U\to F$ 是 F 上的一个形式幂级数，记 $f_S=f(S)$ 为集合幂级数第 $S$ 项的系数。 我们记为：$$f=\sum_{S\subseteq 2^U} f_S x^S$$显然可以定义集合幂级数的加法：$(f+g)(S) = f(S)+g(S)$ ，减法也类似。这两种运算都是 $O(2^n)$ 的。 如何定义乘法？为了保证乘法对加法的分配律，若 $h=f\cdot g$ ，我们应该有：$$\sum_{S\in 2^U} h_S x^S = \big(\sum_{L\in2^U}f_Lx^L\big) \cdot (\sum_{R\in 2^U} g_R x^R) = \sum_{L\in 2^U} \sum_{R\in 2^U} (f_L x^L) \cdot (g_R x^R)$$因此我们只需要规定 $(f_L x^L) \cdot (g_R x^R)$ 的运算结果，我们希望它是以某种集合运算乘起来的。我们设一个 $2^U$ 中满足交换律、结合律、空集是单位元的二元运算 $\ast$ ，那么我们就可以定义 $(f_L x^L) \cdot (g_R x^R) = (f_L g_R) x^{L\ast R}$ 。至此集合幂级数形成了一个交换环，并且包含了整个 $F$ 作为子环。 常见定义 $\ast$ 为集合并运算、集合对称差运算以及子集卷积，我们一一解决。 集合并卷积（FWT_or）原理即给出两个集合幂级数 $f,g$ ，求 $h = f\ast g$ 满足：$$h_S = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cup R = S] f_L g_R \tag{1}$$怎么做呢？暴力做是 $O(4^n)$ 的，一种做法是分治乘法，可是总感觉在理论价值上面会逊色一些。有没有类似 FFT 的一种变换，使得变换后将卷积直接变成点乘呢？莫比乌斯变换做到了这一点。 我们定义集合幂级数 $f$ 的莫比乌斯变换 $\hat{f} $为：$$\hat{f_S} = \sum_{T\subseteq S} f_T$$反过来，如何求莫比乌斯逆变换呢（常常称为莫比乌斯反演）？有关反演看这里：《炫酷反演魔术》。很容易由容斥原理，我们又有：（这一步建议在纸上推导一下，要不然可能会觉得不直观）$$f_S = \sum_{T\subseteq S} (-1)^{|S|-|T|} \hat{f_T}$$现在，我们可以解决 (1) 中的问题了。对 (1) 式的左右两边同时做莫比乌斯变换$$\begin{aligned}\hat{h_S} &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cup R \subseteq S] f_L g_R\\&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\subseteq S][ R \subseteq S] f_L g_R\\&amp; = (\sum_{L\subseteq S}f_L) (\sum_{R\subseteq S}g_R)\\&amp; = \hat{f_S}\hat{g_S}\end{aligned}$$因此，我们想要的性质是成立的。只需要把 $f,g$ 做莫比乌斯变换，点乘起来，然后再做莫比乌斯反演即可得到集合并卷积。 如何进行莫比乌斯变换呢？可以使用递推，设 $\hat f^{(i)}_S$ 表示只考虑 $S\oplus T\subseteq \{1,\cdots,i\}$ 的子集 $T$ 时的莫比乌斯变换第 $S$ 项，令 $\hat f_S^{(0)} = f_S$ ，那么对于每个不包含 $i$ 的 $S$ 有：$$\hat{f_S^{(i)}} = \hat{f_S}^{(i-1)}\\\hat{f}_{S\cup\{i\}} ^{(i)} = \hat f_{S\cup\{i\}}^{(i-1)} + \hat f _S ^{(i-1)}$$由此递推计算即可。复杂度 $O(n2^n)$ 实现代码非常简短，dmt 变量为 1 时表示正变换，为 -1 时表示逆变换。 123456vector&lt;int&gt; fmt_or(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) A[S|(1&lt;&lt;i)] = mo(A[S|(1&lt;&lt;i)] + dmt*A[S]); return A;&#125; 集合交卷积（FWT_and）由于 $S\cap T = C_U(\bar S \cup \bar T)$，因此将S、T翻转之后，可以直接用FWT_or导出。可是实际上还有更简洁的实现，如下面代码所示。 复杂度 $O(n2^n)$ 123456vector&lt;int&gt; fmt_and(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) A[S] = mo(A[S] + dmt*A[S|(1&lt;&lt;i)]); return A;&#125; 集合对称差卷积（FWT_xor）原理这一回把 $\ast$ 定义为集合对称差。即给出两个集合幂级数 $f,g$ 求 $h = f\ast g$ ：$$h_S = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\oplus R=S] f_L g_R \tag 2$$分治乘法在这里也是可行的，但是对应的变换方法是什么呢？这次我们使用快速沃尔什变换及其逆变换（本质上是高维 FFT）。 快速沃尔什变换：$$\hat{f_S} = \sum_{T\subseteq 2^U} f_T (-1) ^{|S\cap T|}$$其逆变换为：（我没有找到靠谱证明）$$f_S = \frac {1}{2^n}\sum_{T\subseteq 2^U} \hat{f_T}(-1)^{|S\cap T|}$$沃尔什变换是具体如何解决（2）式的问题的呢？我们基于下面的事实：$$\frac {1}{2^n}\sum_{T\subseteq 2^U} (-1)^{|S\cap T|} = [S=\oslash]$$化简过程如下：$$\begin{aligned}h_S &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\oplus R\oplus S = \oslash] f_L g_R\\&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|S\cap (L\oplus R \oplus S)|} f_l g_R\\&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|T\cap L|} (-1)^{|T\cap R|}(-1)^{|T\cap S|} f_l g_R\\&amp; = \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|T\cap S|} \Big(\sum_{L\subseteq 2^U} (-1)^{|T\cap L|} f_L\Big)\Big(\sum_{R\subseteq 2^U} (-1)^{|T\cap R|} g_R\Big)\\&amp; = \frac{1}{2^n} \sum_{L\subseteq 2^U} (-1)^{|L\cap S|} \hat{f_S} \hat{g_S}\end{aligned}$$即： $\hat{h_S} = \hat{f_S} \cdot \hat{g_S}$ 注：在理论上，这种变换还有一个小问题，就是特征为2的 $F$ 上上述算法会失效，因为上述算法涉及乘以 $\frac {1}{2^n}$ 。不过一般情况下不会成问题。 接下来考虑如何计算快速沃尔什变换。依然可以使用递推，设 $\hat f^{(i)}_S$ 表示只考虑 $S\oplus T\subseteq \{1,\cdots,i\}$ 的子集 $T$ 时的沃尔什变换第 $S$ 项，令 $\hat f_S^{(0)} = f_S$ ，那么对于每个不包含 $i$ 的 $S$ 有：$$\hat{f_S^{(i)}} = \hat{f_S}^{(i-1)}+\hat{f}_{S\cup\{i\}}^{(i-1)}\\\hat{f}_{S\cup\{i\}} ^{(i)} = \hat f _S ^{(i-1)} - \hat f_{S\cup\{i\}}^{(i-1)}$$由此递推计算即可。复杂度 $O(n2^n)$ 实现123456789101112131415vector&lt;int&gt; fwt_xor(vector&lt;int&gt; A, int dmt = 1) &#123; int l, r; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = A[S], r = A[S|(1&lt;&lt;i)]; A[S] = mo(l + r); A[S|(1&lt;&lt;i)] = mo(l - r); &#125; if(dmt==-1) &#123; int inv2 = qpow(qpow(2, MOD-2), n); for(int S = 0; S &lt; m; ++S) A[S] = muln(A[S], inv2); &#125; return A;&#125; 子集卷积这一部分感觉论文讲得有点自闭，推荐 Dance Of Faith 的这篇博客 。 原理考虑这种形式的卷积如何处理：$$h_S = \sum_{T\subseteq S} f_T g_{S-T} \tag 3$$实际上，这种卷积等价于定义 $\ast$ 为不相交集合的并，即$$L \ast R =\begin{cases} \varnothing, &amp; L \cap R \neq \varnothing \\ L \cup R, &amp; \text{otherwise}\end{cases}$$我们稍微改写一下 （3） 式：$$\begin{aligned}h_S &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cap R = \varnothing] [L\cup R = S] f_L g_R \\&amp; =\sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [|L| + |R| = |S|][L\cup R = S] f_L g_R\end{aligned}$$我们只需要处理掉 $|L|+|R| = |S|$ 这一项。实际上我们直接加一维表示集合的大小，暴力处理即可。 具体来讲，初始时，我们先只把 $f_{pc(S),S}$ （pc(S) 表示 popcount ，即 S 二进制表示中有多少位是 1 ）的值赋成原来的 $f_{S}$（$g$ 也使用同样的操作），然后对每一个 $f_i$ 做一遍FMT，点值相乘时这么卷积：$h_{i, S} = \sum\limits_{j = 0}^{i} f_{j,S} * g_{i - j, S}$ 。代码很简洁，如下所示： 1234567891011121314151617vector&lt;int&gt; subset_conv(vector&lt;int&gt; A, vector&lt;int&gt; B) &#123; vector&lt;int&gt; H(Len); vector&lt; vector&lt;int&gt; &gt; siga(Base+1, vector&lt;int&gt;(Len,0)), sigb = siga, sigh = siga; for(int S = 0; S &lt; Len; ++S) siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S]; for(int i = 0; i &lt;= Base; ++i) &#123; fmt_or(siga[i], 1); fmt_or(sigb[i], 1); for(int S = 0; S &lt; Len; ++S) for(int j = 0; j &lt;= i; ++j) sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i-j][S])); fmt_or(sigh[i], -1); &#125; for(int S = 0; S &lt; Len; ++S) H[S] = sigh[pc[S]][S]; return H;&#125; 小结FWT_OR 12if FMT : f[S|(1&lt;&lt;i)] += f[S]if IFMT: f[S|(1&lt;&lt;i)] -= f[S] FWT_AND 12if FMT : f[S] += f[S|(1&lt;&lt;i)]if IFMT: f[S] -= f[S|(1&lt;&lt;i)] FWT_XOR： 12345l = f[S], r = f[S|(1&lt;&lt;i)]f[S] = l + rf[S|(1&lt;&lt;i)] = l - rif IFMT: f[S] /= qpow(2, n) 子集卷积： 123456789for i in range(0, n + 1): F[i] = FWT_OR(f[i]) G[i] = FWT_OR(g[i]) for S in range(0, Len): for j in range(0, i + 1): H[i][S] += F[j][S] * G[i-j][S] H[i] = IFWT_OR(H[i])for S in range(0, Len): h[S] = H[bc[S]][S] 完整板子代码如下，由于没有采用类似 FFT 蝴蝶操作的优化，效率不是很高，在LOJ的子集卷积模板题上跑了 4500/5000 ms。Luogu 4717 点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;// Template starts hereconst int MOD = 1000000009;inline int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;inline int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;int Len, Base; // Ensure these values are calculated!!!!vector&lt;int&gt; fmt_or(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) A[S|(1&lt;&lt;i)] = mo(A[S|(1&lt;&lt;i)] + dmt*A[S]); return A;&#125;vector&lt;int&gt; fmt_and(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) A[S] = mo(A[S] + dmt*A[S|(1&lt;&lt;i)]); return A;&#125;vector&lt;int&gt; fwt_xor(vector&lt;int&gt; A, int dwt = 1) &#123; int l, r; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = A[S], r = A[S|(1&lt;&lt;i)]; A[S] = mo(l + r); A[S|(1&lt;&lt;i)] = mo(l - r); &#125; if(dwt==-1) &#123; int inv2 = qpow(Len, MOD-2); for(int S = 0; S &lt; Len; ++S) A[S] = muln(A[S], inv2); &#125; return A;&#125;vector&lt;int&gt; conv(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B, vector&lt;int&gt;(*fn)(vector&lt;int&gt;,int)) &#123; vector&lt;int&gt; aa = fn(A, 1), bb = fn(B, 1); for(int i = 0; i &lt; Len; ++i) aa[i] = muln(aa[i], bb[i]); aa = fn(aa, -1); return aa;&#125;vector&lt;int&gt; pc;void get_popcount(int sz) &#123; pc.resize(sz, 0); for(int i = 1; i &lt; sz; ++i) pc[i] = pc[i &gt;&gt; 1] + (i &amp; 1);&#125;vector&lt;int&gt; subset_conv(vector&lt;int&gt; A, vector&lt;int&gt; B) &#123; get_popcount(Len); vector&lt;int&gt; H(Len); vector&lt; vector&lt;int&gt; &gt; siga(Base+1, vector&lt;int&gt;(Len,0)), sigb = siga, sigh = siga; for(int S = 0; S &lt; Len; ++S) siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S]; for(int i = 0; i &lt;= Base; ++i) &#123; siga[i] = fmt_or(siga[i], 1); sigb[i] = fmt_or(sigb[i], 1); for(int S = 0; S &lt; Len; ++S) for(int j = 0; j &lt;= i; ++j) sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i-j][S])); sigh[i] = fmt_or(sigh[i], -1); &#125; for(int S = 0; S &lt; Len; ++S) H[S] = sigh[pc[S]][S]; return H;&#125;// Template ends herevoid show(vector&lt;int&gt; v) &#123; int first = true; for(auto g : v) &#123; if(first) first = false; else putchar(' '); printf("%d", g); &#125; putchar('\n');&#125;int n, m;vector&lt;int&gt; a, b;int main() &#123; scanf("%d", &amp;n); m = Len = 1 &lt;&lt; n, Base = n; a.resize(m), b.resize(m); rep(i, m) scanf("%d", &amp;a[i]); rep(i, m) scanf("%d", &amp;b[i]); show(conv(a, b, fmt_and)); show(conv(a, b, fmt_or)); show(conv(a, b, fwt_xor)); show(subset_conv(a, b)); return 0;&#125; 练习[HAOI2015] 按位或Description刚开始你有一个数字0，每一秒钟你会随机选择一个 $[0,2^n-1]$ 的数字，与你手上的数字进行按位或操作。选择数字 $i$ 的概率是 $p_i$。保证 $0\leq p_i \leq1$，$\sum p_i = 1$。问期望多少秒后，你手上的数字变成 $2^n-1$。无穷输出 INF 数据范围：$n\leq 20$ Source: BZOJ4036 vfk论文第一道例题。 Solution留坑。 Day8 I. 岸边露伴的人生经验Description岸边露伴是一个天才漫画家，他经常用自己的替身天堂之门来查看别人的人生经历，为自己的漫画积累素材。最近他学会了将一个人的人生经历编码成一个 $10$ 维的向量，每一维取值为 $\{0,1,2\}$ 中的一个元素。定义向量$\overrightarrow{V}=(x_1,x_2,\cdots,x_{10})$ 的模长 $|\overrightarrow{V}|$ 为 $\sqrt{x_1^2+x_2^2+\cdots+x_{10}^2}$。令第 $i$ 个人的人生经历对应的向量为$\overrightarrow{V_i}$，则第ii个人和第 $j$ 个人的人生轨迹的差别可以用 $|\overrightarrow{V_i}-\overrightarrow{V_j}|$ 衡量。岸边露伴收集了 $n$ 个人的向量，他想要知道这些人里，人生轨迹差别相同的二元组有多少对，即有多少个四元组 $(i,j,k,l)(1 \le i,j,k,l \le n)$ 满足 $|\overrightarrow{V_i}-\overrightarrow{V_j}|=|\overrightarrow{V_k}-\overrightarrow{V_l}|$ 数据范围：$n\leq 10^5$ Source: CCPC-Wannafly Winter Camp Day8 (Div1, onsite) Day 8 Problem I Solution考虑每个向量取值只有 $\{0,1\}$ 的情况，每个人的向量为一个二进制数，装进桶里，直接进行自己卷积自己的异或 FWT ，这时集合幂级数的每一项都代表这个集合被异或出来的 可能方式。再扫一遍每一个状态，按照 bitcount 统计距离，加入另一个数组，平方一下即可。 考虑这道题，多了一个 $2$ ，我们只需要把每一个向量中一个数位拆成两个字符即可，将 1 变为 01 ，2 变为 10 ， 0 变为 00 ，然后把上一种做法求 bitcount 统计距离的方式稍微改一下就可以了。 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* Generated by powerful Codeforces Tool * Author: YangDavid * Time: 2019-04-28 19:15:38*/#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 202000, maxs = 1 &lt;&lt; 20, BB = 20, MOD = 998244353;int n, dif[10200];vector&lt;int&gt; a(maxs, 0), val(maxs, 0);int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;void fwt(int dwt) &#123; int l, r; for(int i = 0; i &lt; BB; ++i) &#123; int mask = (maxs-1) ^ (1&lt;&lt;i); for(int S = mask; S &gt;= 0; S = (S-1)&amp;mask) &#123; l = a[S], r = a[S | (1&lt;&lt;i)]; a[S] = mo(l + r); a[S|(1&lt;&lt;i)] = mo(l - r); if(S == 0) break; &#125; &#125; if(dwt == -1) &#123; int fac = qpow(qpow(2, MOD - 2), BB); for(int i = 0; i &lt; maxs; ++i) a[i] = muln(a[i], fac); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; int msk = 0, x; rep(j, 10) &#123; scanf("%d", &amp;x); msk &lt;&lt;= 2; if(x == 1) msk += 1; else if(x == 2) msk += 2; &#125; a[msk]++; &#125; fwt(1); for(int i = 0; i &lt; maxs; ++i) a[i] = muln(a[i], a[i]); fwt(-1); val[0] = 0, val[1] = 1, val[2] = 4, val[3] = 1; for(int S = 4; S &lt; maxs; S += 4) &#123; int t = val[S &gt;&gt; 2]; val[S] = t; val[S+1] = t + 1; val[S+2] = t + 4; val[S+3] = t + 1; &#125; for(int S = 0; S &lt; maxs; ++S) &#123; dif[val[S]] += a[S]; &#125; ll res = 0; for(int i = 0; i &lt;= 100; ++i) &#123; res = mo(res + 1LL * dif[i] * dif[i] % MOD); &#125; printf("%lld\n", res); return 0;&#125; CF1119 H. 难题，精妙的 FWTDescription给定 $a,b,c$ ，以及 $n$ 个 $k$ 位 bitmask $A_i,B_i,C_i$ ，求下面 $n$ 个集合幂级数的异或 FWT，即：$$\prod_{1\leq i\leq n} (ax^{A_i}+bx^{B_i}+cx^{C_i})$$数据范围：$n\leq 10^5,k\leq 17,0\leq A_i,B_i,C_i &lt; 2^k,$ Source: Codeforces Global Round 2 Problem H Solution按照正常的 FWT 思路，就是把这 $n$ 个集合幂级数分别求出 FWT，然后再点乘起来，然后再做 IFWT。复杂度是 $O(nk2^k)$ 的，无法通过此题。 但是这道题需要注意的一点是每一个集合幂级数都只有三项，并且 $a,b,c$ 是固定的。回顾 FWT 的公式：$$\hat{f}(S) = \sum_{T\subseteq 2^U} f(T) (-1)^{|S\cap T|}$$因此每个集合幂级数 FWT 之后也仅仅会有 $\pm a \pm b \pm c$ 这么 8 种项。为了使问题更加简单，我们进行这样的变换： $B_i:=B_i \oplus A_i,C_i := C_i \oplus A_i, A_i := 0$ 。变换之后我们得出的结果的第 $S$ 项就等价于答案的第 $S\oplus xorsum$ 项，其中 $xorsum = \oplus_{i=1}^n A_i$。可以发现，这样做之后只剩下 $a\pm b \pm c$ 这四项了。 我们的一个重要观察是，将 FWT 之后的这 $n$ 个集合幂级数乘起来的结果中，对于一个固定的位置 $S$ ，这一项的系数一定是 $(a+b+c)^x (a+b-c)^y (a-b+c)^z (a-b-c)^w$ 的形式。如果我们能够把 $x,y,z,w$ 解出来，整个问题就解决了。首先，我们有一个最朴素的关系式：$$x+y+z+w = n$$之后有两种说法，一种是官方题解所说的考虑所有 $n$ 个 FWT 之后的幂级数的第 $S$ 项之和，然后再多考虑一个条件即可得到四个方程；另一种则非常简洁、对称、优美，可是我对这种方法还没有简洁优美的证明。这种方法是这样的： 将 $A_i\oplus B_i$ 的值统计入一个数组 $f$，对 $f$ FWT之后，对于其第 $S$ 项有：$x+y-z-w=f[S]$。 将 $A_i\oplus C_i$ 的值统计入一个数组 $g$，对 $g$ FWT之后，对于其第 $S$ 项有：$x-y+z-w=g[S]$。 将 $B_i\oplus C_i$ 的值统计入一个数组 $h$，对 $h$ FWT之后，对于其第 $S$ 项有：$x-y-z+w=h[S]$。 然后消元法即可。 Code点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Generated by powerful Codeforces Tool * Author: YangDavid * Time: 2019-05-02 16:57:53*/#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 102000, MS = (1 &lt;&lt; 17) + 2, MOD = 998244353;int A[maxn], B[maxn], C[maxn], n, k, full;int AB[MS], AC[MS], BC[MS], ans[MS], out[MS];int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;const int inv2 = qpow(2, MOD - 2), inv4 = qpow(4, MOD - 2);void fwt(int* arr, int dwt = 1) &#123; int l, r; for(int i = 0; i &lt; k; ++i) for(int S = 0; S &lt; full; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = arr[S], r = arr[S|(1&lt;&lt;i)]; arr[S] = mo(l + r); arr[S|(1&lt;&lt;i)] = mo(l - r); &#125; int iv = qpow(full, MOD - 2); if(dwt == -1) for(int S = 0; S &lt; full; ++S) arr[S] = muln(arr[S], iv);&#125;int gg[4], a, b, c, xorsum;int gett(ll s, ll t, ll u, ll v) &#123; int x = muln(mo(mo(s+t)+mo(u+v)), inv4); int y = mo(muln(mo(s+t), inv2) - x); int z = mo(muln(mo(s+u), inv2) - x); int w = mo(muln(mo(s+v), inv2) - x); return muln( muln(qpow(gg[0],x),qpow(gg[1],y)) , muln(qpow(gg[2],z),qpow(gg[3],w)) );&#125;int main() &#123; scanf("%d%d%d%d%d", &amp;n, &amp;k, &amp;a, &amp;b, &amp;c); full = (1 &lt;&lt; k); gg[0] = mo(mo(a+b)+c), gg[1] = mo(mo(a+b)-c), gg[2] = mo(mo(a-b)+c), gg[3] = mo(mo(a-b)-c); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;A[i], &amp;B[i], &amp;C[i]); AB[A[i]^B[i]]++, AC[A[i]^C[i]]++, BC[B[i]^C[i]]++; xorsum ^= A[i]; &#125; fwt(AB), fwt(AC), fwt(BC); for(int S = 0; S &lt; full; ++S) &#123; ans[S] = gett(n, AB[S], AC[S], BC[S]); &#125; fwt(ans, -1); for(int S = 0; S &lt; full; ++S) out[S] = ans[S ^ xorsum]; for(int S = 0; S &lt; full; ++S) printf("%d%c", out[S], " \n"[S==full-1]); return 0;&#125; CF662C 超级好题Description你有一个 $n$ 行 $m$ 列的 01 矩阵，你可以进行翻转行与翻转列两种操作（翻转即 0 变 1，1 变 0）任意多次，问最后得到的矩阵的 1 的个数最少是多少。 数据范围：$n\leq 20,m\leq 100000$ Source: CROC 2016 - Final Round Problem C. Binary Table Solution注意 $n\leq 20$ 的条件。先考虑 $O(m2^n )$ 暴力怎么做。记第 $j$ 列的数的 bitmask 为 $A_j$ ，我们枚举行的翻转状态的 bitmask为 $S$ ，然后对于每一种状态 $S$，我们查看每一列，第 $j$ 列被变为了 $A_j \oplus S$。考虑这一列是否翻转，显见答案增加了 $\min\{pop(A_j \oplus S), n-pos(A_J\oplus S)\}$，其中 $pop(S)$ 是指 $S$ 二进制表示中 1 的个数。我们记$f(S) = \min\{pop(S),n-pop(S)\}$ ，那么对于行的枚举状态 $S$ 我们得到的答案就是这个：$$\sum_{i=1}^m f(S\oplus A_i)$$由于 $A_j$ 的值域也是 $2^n$，我们记 $A$ 中 $x$ 这个值出现的次数为 $c(x)$，那么上式可以改写为：$$\sum_{T \subseteq 2^n} f(T \oplus S) \cdot c(T)$$是不是有点 FWT 的形式了？进一步地：$$\begin{aligned}ans(S) &amp;= \sum_{T \oplus U = S} f(T) c(U)\end{aligned}$$这不正是 FWT 吗？于是我们求出 $f$ 与 $c$ 的异或 FWT，然后扫一边 ans 数组找最小值即可。 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxs = (1 &lt;&lt; 20) + 2333, MOD = 998244353;int c[maxs], g[maxs], n, m, full , pop[maxs];char s[22][101010];inline int mo(int x) &#123; if(x &gt;= MOD) return x-MOD; if(x &lt; 0) return x+MOD; return x; &#125;inline int muln(int x, int y) &#123; return (ll)x * y % MOD; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int Base, Len;int* fwt(int* A, int dwt = 1) &#123; int l, r; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = A[S], r = A[S|(1&lt;&lt;i)]; A[S] = mo(l + r); A[S|(1&lt;&lt;i)] = mo(l - r); &#125; if(dwt==-1) &#123; int inv2 = qpow(Len, MOD-2); for(int S = 0; S &lt; Len; ++S) A[S] = muln(A[S], inv2); &#125; return A;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); full = (1 &lt;&lt; n) - 1; for(int i = 0; i &lt; n; ++i) scanf("%s", s[i]); for(int i = 0; i &lt; m; ++i) &#123; int res = 0; for(int j = 0; j &lt; n; ++j) res = 2 * res + s[j][i] - '0'; c[res]++; &#125; for(int S = 1; S &lt;= full; ++S) &#123; pop[S] = pop[S&gt;&gt;1] + (S&amp;1); g[S] = min(pop[S], n - pop[S]); &#125; Len = 1&lt;&lt;n, Base = n; fwt(c, 1); fwt(g, 1); for(int S = 0; S &lt;= full; ++S) c[S] = muln(c[S], g[S]); fwt(c, -1); int ans = 0x3f3f3f3f; for(int S = 0; S &lt;= full; ++S) ans = min(ans, c[S]); printf("%d\n", ans); return 0;&#125; [HDU5909] [WC2018]州区划分]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>高维前缀和（FMT）</tag>
        <tag>快速沃尔什变换系列（FMT，FWT等）</tag>
        <tag>集合幂级数</tag>
        <tag>子集卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opentrains 1505 训练报告]]></title>
    <url>%2F2019%2F04%2F24%2FOpentrains-1505-%E8%AE%AD%E7%BB%83%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Petrozavodsk Summer-2017. Moscow IPT Contest.Overview Status A B C D E F G H I J K Contest 4:40 4:11 (0) 2:13 1:25 Upsolve OK $\mathcal O$ AC OK AC $\mathcal {O}$ OK OK Attempt + * +1 * +1 +1 AC count 15 45 2 14 6 10 63 32 52 86 71 Tag ? dp ? KMP ? 讨论 构造 思维 ? LIS 组合 Coding ? 988 ? ? ? 1300 1836 3408 ? cyy cyy Thinking ? Mid+ ? ? ? Mid Mid Mid- ? Easy cyy Stars ? ★★ ? ? ? ★ ★★ ★ ? ★ ★ 注：$\mathcal O$ 表示口头通过。 XHT Red Sun 队第一次（也许算正式？）训练（不过 wzk 去参加 JSOI 了，只有我和 cyy 打）。 Solved during contest: 4/11 Upsolved after contest: 6/11 Orially solved: 8/11 Rank: 55/94 难度顺序：$$J\to K \to G \to B \to H \to D,F,I$$几点感受： 开局还是需要稳健，签到题确认结论时应当想清楚结论的细节以及证明 感觉我赛时写 G 题的代码有点太慌张了，浪费了不少时间。 H 题不难，本应场上写出来的。 F 题直接大力分类讨论就好了。。。没有几种情况，但是榜上过的人比较少。感觉赛时没做有点失策。 TutorialProb B. FMT，高维前缀和，SOS dp Solved By hdmmblz at 04:40 (1 try) Description对于一个长度为 $n$ 的非负整数序列 $b_1,b_2,…,b_n$，定义这个序列的能量为：$$LP(b) = \max_{i=0,1,\cdots,n} (b_1 \oplus b_2 \oplus \cdots \oplus b_i) + (b_{i+1}\oplus\cdots\oplus b_n)$$其中 $\oplus$ 表示按位异或 (XOR)，给定一个长度为 $n$ 的非负整数序列 $\{a\} = a_1,a_2,…,a_n$， 请计算 a 的每个前缀的能量值。 数据范围： $n\leq 10^6, a_i\leq 10^6$ Solution首先，分析 LP 的性质，假设 $s_j = \oplus_{i=1}^j a_j$ ，很容易看到 $a$ 的前 $c$ 个元素组成的前缀 $pref_c$ 的 LP 值为：$$LP(pref_c) = \max_{i=0,1,\cdots,c} s_i + (s_c \oplus s_i)$$由于$x\oplus y = x - y + 2\text{ } (\text{~}x \&amp; y)$ ，可以推断得到：$$LP(pref_c) = s_c + 2\cdot \max_{i=0,1,\cdots,c}s_c \&amp;\text{~} s_i$$因此我们将这道题转化到下面的等价形式： 你有一个空集合 $A$，你需要进行以下两个操作： Query $x$ ，表示求 $\max\limits_{a\in A} a\&amp; x$ 。 Insert $x$，表示将 $x$ 插入集合 $A$ 中. 可是这个问题怎么解决呢？开始我的想法是将 $A$ 集合建 01-trie 树，从大到小考虑所有数位，碰到 $x$ 中 1 的数位就尽量往 trie 的 1 方向走。可是碰到 $x$ 中 0 的数位就会失效， trie 树的两个子树都要考虑，这样做可能会遍历整个 trie 树，复杂度必然会失效。 实际上，我们可以感觉到这个问题和前缀和有一定的相似之处。碰到 1 的情况就是尽量选，只有一条路；碰到 0 的情况无限制，有两条路。这里我们又注意到值域是 $\leq 10^6$ 的，因此我们可以将问题离线，之后使用黑科技——高维前缀和（不过这里是前缀 $\min$）。我们定义 $dp[mask]$ 表示 $s$ 中最小的下标 $x$，使得 $s_x$ 含有 $mask$ 的二进制表示中每一个数位 1 ，即 $s_i \&amp; mask = mask$。 我们可以先初始化 $dp[i]=\infty$ ，然后令 $dp[s_i]=i$ 作为初值条件，然后跑高维前缀 $\min$（FMT，Sum over Subset等等一系列等价说法）即可得到上面想要的 $dp[mask]$ 的性质。考虑如何回答询问，回答第 $i$ 个询问时，我们初始化 $mask=0$ ，然后依次从大到小考虑每一位进行贪心。如果这一位 $s_c$ 为 1，则尽量使mask这一位也变成 1，检查 $dp[mask]$ 是否超过 $i$。如果 $s_c$ 这一位是 0那就不考虑。这样就解决了问题。 时间复杂度 $\mathcal O (2^m \cdot m)$，$m$ 是值域的二进制最大位数，这里取 20。 Comment感觉这是一道牛逼题啊，2017 年 8 月的 Petrozavodsk 冬令营题，2017 年 11 月就成了 BZOJ 月赛题了。题号5092: [Lydsy1711月赛]分割序列。cyy 现场 29 分钟 AC，太强了 有关高维前缀和，我找到了以下资源： Codeforces 上的 SOS dp 教程 SPOJ Time limit exceeded CF 449D BZOJ4036 Code点击显示/隐藏代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int BUFF_SIZE = 1 &lt;&lt; 20;char BUFF[BUFF_SIZE],*BB,*BE;#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 4004000, bit = 20, full = 1048575;const int INF = 0x3f3f3f3f;int a[maxn], n, sum, dp[maxn];/* Question equiv to 2 ops: 1. Given a set A and number b, find b+2max(a&amp;~b)) 2. Insert number x in the set A.*/inline void upd(int&amp; x, int y) &#123; x = min(x, y); &#125;int main() &#123; memset(dp, 0x3f, sizeof dp); read(n); for(int i = 0;i &lt; n; ++i) &#123; read(a[i]); if(i) a[i] ^= a[i - 1]; upd(dp[a[i]], i); &#125; for(int d = 0; d &lt; bit; ++d) &#123; for(int S = full; S &gt;= 0; --S) if(S &gt;&gt; d &amp; 1) &#123; upd(dp[S ^ (1&lt;&lt;d)], dp[S]); &#125; &#125; for(int i = 0; i &lt; n; ++i) &#123; int b = a[i], c = ~b &amp; full, cur = 0; for(int j = bit-1; j &gt;= 0; --j) if(c&gt;&gt;j&amp;1) &#123; if(dp[cur | (1 &lt;&lt; j)] &lt; i) cur |= (1 &lt;&lt; j); &#125; write(b + 2 * cur); putchar(" \n"[i==n-1]); &#125; return 0;&#125; Prob F. 分类讨论 Upsolved by YangDavid (1 try) 直接分 6 种情况讨论即可。。。具体讨论过程见代码。 点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;ll n, m, k, n1, n0, m1, m0;int main() &#123; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;k); if(k == 1) &#123; if(n * m % 2 == 0) puts("0"); else printf("%lld\n", n * m); return 0; &#125; if(n &gt; m) swap(n, m); n1 = n / k, n0 = n % k; m1 = m / k, m0 = m % k; if(n1 == 1) &#123; if(m1 == 1) &#123; printf("%lld\n", (n-k+1) * (m-k+1)); return 0; &#125; else if(m1 == 2) &#123; printf("%lld\n", (n0+1) * max(0LL, 3LL*k-m-1)); return 0; &#125; else if(m1 == 3) &#123; printf("%lld\n", n0 + 1); return 0; &#125; &#125; else if(n1 == 2) &#123; if(m1 == 2) &#123; if(n0 == k - 1 || m0 == k - 1) &#123; puts("0"); return 0; &#125; /* We must do like this: (Destroy all of 4 blocks) XX- XX- --- */ printf("%lld\n", (k*3-m-1)*(k*3-n-1)); &#125; else if(m1 == 3) &#123; /* .X. X.. ..X ... ... .X. ... ... X.. ..X --- --- --- X-- --X Case 1 Case 2 */ if(n0 == k - 1) &#123; puts("0"); return 0; &#125; ll ans = k * 3 - n - 1; // Case 1 ans += 4 * (n - 2 * k + 1); // Case 2 printf("%lld\n", ans); return 0; &#125; &#125; else &#123; puts("1"); // Brute force to prove this. &#125; return 0;&#125; Prob G. 构造好题 Solved by YangDavid at 04:11 (2 tries) Description你需要构造这么一个 $n$ 位二进制串 $s$，（$n$ 是偶数）使得它的任何一个前缀 $pref_i$ 代表的二进制数 $\pmod n$ 两两互不同余。 Solution首先，显然可以把这道题转化为一个图论问题： 给出一张 $n$ 个节点的有向图，节点编号依次为 $0,1,\cdots,n-1$ 。其中 $i$ 号节点会与 $2i\bmod n, 2i+1\bmod n$ 这两个节点连边，请找出这个图中的一条哈密尔顿回路。 我们将两个相邻的小节点定义为一个大节点。具体说是 $\{0,1\},\{2,3\},\cdots,\{n-2,n-1\}$ 各组成一个大节点。我们规定若小节点 $i,j$ 之间有边，那么它们对应的大节点之间也会连边。于是我们发现第 $i$ 个大节点会向 $2i,2i+1$ 这两个大节点连边，每个大节点恰好连出去两条边，且连进来两条边，是一个欧拉图。找到欧拉回路之后，每个大节点出现两次，我们只需要确定两次大节点分别代表哪一个小节点就可以将欧拉回路改成要求的哈密尔顿回路。实际上根据大节点连边的特性，我们倒序考虑即可完成这件事情。细节见代码。 Comment碰到了喜欢的构造题，感觉海星。这道题又是一道构造哈密尔顿回路。前面提到的构造哈密尔顿回路用到的主要方法有随机化搜索、硬核构造、 Dirac 定理等等（如Google Code Jam Round 1A Problem A, AGC031 C题 )，不过这道题的方法则非常有趣，又给了我一种新的思路，即利用欧拉回路找到哈密尔顿回路的。 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2020;int n;int G[maxn][maxn], vis[maxn][maxn], hf;vector&lt;int&gt; ans;set&lt;int&gt; lf[maxn];void euler(int u) &#123; for(int v = 0; v &lt; hf; ++v) if(G[u][v] &amp;&amp; !vis[u][v]) &#123; vis[u][v] = true; euler(v); &#125; ans.push_back(u);&#125;void lk(int x, int y) &#123; x %= n, y %= n; x &gt;&gt;= 1, y &gt;&gt;= 1; G[x][y] = true;&#125; void build() &#123; for(int i = 0; i &lt; n; i += 2) &#123; lk(i, i * 2); lk(i + 1, i * 2 + 3); &#125;&#125;int main() &#123; scanf("%d", &amp;n); if(n == 2) &#123; puts("10"); return 0; &#125; hf = n / 2; build(); euler(0); for(int i = 0;i &lt; n; ++i) &#123; lf[i].insert(i * 2 + 1); lf[i].insert(i * 2); &#125; reverse(ans.begin(), ans.end()); ans.pop_back(); int cur = 0; string res = ""; for(auto it = ans.rbegin(); it != ans.rend(); ++it) &#123; auto g = *it; if(lf[g].count(cur / 2)) &#123; auto v = cur / 2; if(v * 2 == cur) res += '0'; else if(v * 2 + 1 == cur) res += '1'; cur = v; lf[g].erase(v); &#125; else if(lf[g].count((cur + n) / 2)) &#123; auto v = cur / 2 + n / 2; if(v * 2 % n == cur) res += '0'; else if((v*2+1) % n == cur) res += '1'; cur = v; lf[g].erase(v); &#125; else assert(false); &#125; reverse(res.begin(), res.end()); cout &lt;&lt; res &lt;&lt; '\n';&#125; Prob H. 扫描线+模拟 Upsolved by YangDavid on 2019.4.28 (1 try) Description给你一个 $n\times m$ 的表格，由 + 和 - 组成。一步操作可以选取一个位置，把它所在的行和列翻转，该元素本身仅被翻转一次。现在进行如下的操作：每轮把所有 + 的位置记录下来，然后对每个记录下来的位置进行一步操作，直到所有元素都为 -。问要进行多少步操作。 Solution首先，线段树+扫描线统计出来初始条件下每一行、每一列+号的奇偶性，之后就可以发现行与列奇偶性相同的方格一定会变为 - ，不同的一定会变为 + 。交换行列的顺序是不影响答案的，因此经过一次变换之后，经过一番操作，矩形将被分成四个小矩形，我们只需要记录有几个横行 + 的个数是奇数，几个纵列 + 的个数是奇数，最多只有 16 种状态，直接模拟即可。如果出现重复状态，那么就说明不可以。 Code点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 402000;int n, m, q, row[maxn], col[maxn];struct event &#123; int l, r, t; event(int L, int R, int T): l(L), r(R), t(T) &#123; &#125; bool operator &lt; (const event&amp; ev) const &#123; return t &lt; ev.t; &#125;&#125;;vector&lt;event&gt; erow, ecol;struct segtree &#123; vector&lt;int&gt; tag, sumv; #define lson (o &lt;&lt; 1) #define rson (o &lt;&lt; 1 | 1) void pushdown(int o, int l, int r) &#123; if(tag[o]) &#123; int mid = (l + r) &gt;&gt; 1; tag[lson] ^= 1; sumv[lson] = mid - l + 1 - sumv[lson]; tag[rson] ^= 1; sumv[rson] = r - mid - sumv[rson]; tag[o] = 0; &#125; &#125; void pushup(int o) &#123; sumv[o] = sumv[lson] + sumv[rson]; &#125; void flip(int ql, int qr, int o=1, int l=1, int r=100005) &#123; if(ql &lt;= l &amp;&amp; r &lt;= qr) &#123; tag[o] ^= 1; sumv[o] = r - l + 1 - sumv[o]; return; &#125; pushdown(o, l, r); int mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid) flip(ql, qr, lson, l, mid); if(qr &gt; mid) flip(ql, qr, rson, mid + 1, r); pushup(o); &#125; int query() &#123; return sumv[1]; &#125; segtree() &#123; tag = vector&lt;int&gt;(maxn, 0); sumv = vector&lt;int&gt;(maxn, 0); &#125;&#125; tr;int xf, yf, xs, ys;ll tot = 0;ll scan(vector&lt;event&gt; e, int* par, int lim) &#123; ll ret = 0; sort(e.begin(), e.end()); tr = segtree(); int sz = e.size(), curt = 1, cursum = 0; for(int i = 0; i &lt; sz; ) &#123; ret += 1LL * cursum * (e[i].t - curt); for(int t = curt; t &lt; e[i].t; ++t) par[t] = cursum &amp; 1; curt = e[i].t; while(curt == e[i].t) &#123; tr.flip(e[i].l, e[i].r); if(++i &gt;= sz) break; &#125; cursum = tr.query(); &#125; if(curt &lt;= lim) ret += 1LL * (lim - curt + 1) * cursum; return ret;&#125;int main() &#123; read(n, m, q); rep(i, q) &#123; read(xf, yf, xs, ys); erow.emplace_back(yf, ys, xf); erow.emplace_back(yf, ys, xs + 1); ecol.emplace_back(xf, xs, yf); ecol.emplace_back(xf, xs, ys + 1); &#125; tot = scan(erow, row, n); assert(tot == scan(ecol, col, m)); int r1 = 0, c1 = 0, r0, c0; rep(i, n) r1 += row[i]; rep(i, m) c1 += col[i]; set&lt; pair&lt;int, int&gt; &gt; st; while(r1 + c1 != 0) &#123; if(st.count(&#123;r1, c1&#125;)) &#123; puts("-1"); return 0; &#125; st.emplace(r1, c1); r0 = n - r1, c0 = m - c1; tot += 1LL * r1 * c0 + 1LL * r0 * c1; int nr1 = r1 * (c0&amp;1) + r0 * (c1&amp;1); int nc1 = c1 * (r0&amp;1) + c0 * (r1&amp;1); r1 = nr1, c1 = nc1; &#125; printf("%lld\n", tot); return 0;&#125; Prob J. LIS Solved by hdmmblz on 02:13 (2 tries) 简单题，直接将原来两个串的 LIS 的长度加起来就好了。证明： 首先，长度为两个LIS长度加起来的LIS是可以构造出来的。考虑合并两个串时用归并排序的策略归并两个 LIS 其次，如果有更长的，那么在其中一个序列中将会出现比 LIS 更长的上升子序列，矛盾。 点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll n,m,cnt=0,i,a[500005],b[500005],dp[500005],hd1,hd2,pos,ans=0;const ll inf=1e18;int main()&#123; scanf("%lld",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); scanf("%lld",&amp;m); for(i=1;i&lt;=m;i++)scanf("%lld",&amp;b[i]); dp[0]=0; for(i=1;i&lt;=n;i++)dp[i]=inf; for(i=1;i&lt;=n;i++) &#123; pos=lower_bound(dp,dp+n+1,a[i])-dp; dp[pos]=a[i]; &#125; for(i=n;i&gt;=0;i--)if(dp[i]&lt;inf)break; ans=i; dp[0]=0; for(i=1;i&lt;=m;i++)dp[i]=inf; for(i=1;i&lt;=m;i++) &#123; pos=lower_bound(dp,dp+m+1,b[i])-dp; dp[pos]=b[i]; &#125; for(i=m;i&gt;=0;i--)if(dp[i]&lt;inf)break; ans+=i; printf("%lld\n",ans); return 0; &#125; Prob K. 数学 Solved by hdmmblz on 01:25 (2 tries) 推一推式子就好了。 点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll n,m,k,i,fac[1000005],invfac[1000005],ans;const ll mod=1e9+7; ll pow(ll a,ll b)&#123; ll ans=1; while(b) &#123; if(b&amp;1LL)ans=ans*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;ll C(ll x,ll y)&#123; if(y==-1) &#123; if(x==-1)return 1; else return 0; &#125; return fac[x]*invfac[y]%mod*invfac[x-y]%mod;&#125;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;k,&amp;m); fac[0]=1; for(i=1;i&lt;=n;i++)fac[i]=fac[i-1]*i%mod; invfac[n]=pow(fac[n],mod-2LL); for(i=n-1;i&gt;=0;i--)invfac[i]=invfac[i+1]*(i+1)%mod; for(i=m;i&lt;n-(k-m);i++)ans=(ans+2LL*C(i-2LL,m-2LL)*(n-k+m-i))%mod; ans=(ans-(n-k)+mod)%mod; printf("%lld\n",ans); return 0&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>哈密尔顿路径</tag>
        <tag>Opentrains</tag>
        <tag>高维前缀和（FMT）</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小圆（球）覆盖学习笔记]]></title>
    <url>%2F2019%2F04%2F21%2F%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最小圆覆盖问题给出 $N$ 个点，让你画一个最小的包含所有点的圆。输出圆心、半径。 数据范围 $N\leq 10^5$ 模板提交链接：[Luogu 1742] [BZOJ 1337] [TODO] 随机增量法复杂度分析 解法一般有两种做法：随机增量法与模拟退火法。随机增量法是一种确定性算法，随机意义下均摊复杂度 $O(n)$ ，而且可以达到很高的精度（可达到 $10^{-10}$ 量级）；而模拟退火法是启发式算法，需要结合调整参数从而得到一定精度，精度一般只可以可达到 $10^{-5}$ 量级。 随机增量法为了保证随机情况下的均摊性质，我们首先将给出的点随机打乱。 然后基于下面的事实进行操作： 如果点 $p$ 不在集合 $S$ 的最小覆盖圆内，则 $p$ 一定在 $S\cup\{p\}$ 的最小覆盖圆上。 根据这个定理，我们可以分三次确定前 $i$ 个点的最小覆盖圆。 1.令前 $i-1$ 个点的最小覆盖圆为 $C$ 2.如果第 $i$ 个点在 $C$ 内，则前 $i$ 个点的最小覆盖圆也是 $C$ 3.如果不在，那么第 $i$ 个点一定在前 $i$个点的最小覆盖圆上，接着确定前 $i-1$ 个点中还有哪两个在最小覆盖圆上。因此，设当前圆心为 $P_i$，半径为 $0$，做固定了第 $i$ 个点的前 $i$ 个点的最小圆覆盖。 4.固定了一个点：不停地在范围内找到第一个不在当前最小圆上的点 $P_j$，设当前圆心为 $(P_i+P_j)/2$，半径为 $\frac{1}{2}|P_iP_j|$，做固定了两个点的，前 $j$ 个点外加第 $i$ 个点的最小圆覆盖。 5.固定了两个点：不停地在范围内找到第一个不在当前最小圆上的点 $P_k$，设当前圆为 $P_i,P_j,P_k $ 的外接圆。 核心代码非常简洁： 123456789101112131415161718mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());Circle MinCircle(vector&lt;Point&gt; pt) &#123; int sz = pt.size(); shuffle(pt.begin(), pt.end(), rng); Circle cc(pt[0], 0.0); for(int i = 0; i &lt; sz; ++i) if(cc.out(pt[i])) &#123; cc = Circle(pt[i], 0.0); for(int j = 0; j &lt; i; ++j) if(cc.out(pt[j])) &#123; cc = Circle((pt[i] + pt[j]) / 2.0, length(pt[i]-pt[j]) / 2.0); for(int k = 0; k &lt; j; ++k) &#123; if(cc.out(pt[k])) &#123; cc = Circle(pt[i], pt[j], pt[k]); &#125; &#125; &#125; &#125; return cc;&#125; 这种做法乍一看是 $O(n^3)$ 的，可是实际上均摊意义下他就是 $O(n)$ 的。证法我现在还不会，留坑。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 102000;const double eps = 1e-10;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; Point turn(double rad) &#123; return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); &#125; Point turn90() &#123; return Point(-y, x); &#125; void scan() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125;double angle(Vector A, Vector B) &#123; return acos(dot(A, B) / length(A) / length(B)); &#125;Point LLIntPV(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; assert(cross(v, w) != 0); double t = cross(w, u) / cross(v, w); return P + v * t;&#125; // Line: Point + Vector// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125; Circle(Point A, Point B, Point C) &#123; assert(sgn(cross(B-A, C-A)) != 0); Point mab = (A + B) / 2.0, ab = (B - A).turn90(); Point mbc = (B + C) / 2.0, bc = (C - B).turn90(); o = LLIntPV(mab, ab, mbc, bc); r = length(A - o); &#125; Point at(double theta) &#123; return o + Point(cos(theta)*r, sin(theta)*r); &#125; bool out(Point pt) &#123; return sgn(length(o-pt) - r) == 1;&#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());Circle MinCircle(vector&lt;Point&gt; pt) &#123; int sz = pt.size(); shuffle(pt.begin(), pt.end(), rng); Circle cc(pt[0], 0.0); for(int i = 0; i &lt; sz; ++i) if(cc.out(pt[i])) &#123; cc = Circle(pt[i], 0.0); for(int j = 0; j &lt; i; ++j) if(cc.out(pt[j])) &#123; cc = Circle((pt[i] + pt[j]) / 2.0, length(pt[i]-pt[j]) / 2.0); for(int k = 0; k &lt; j; ++k) &#123; if(cc.out(pt[k])) &#123; cc = Circle(pt[i], pt[j], pt[k]); &#125; &#125; &#125; &#125; return cc;&#125;int n;int main() &#123; scanf("%d", &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) p[i].scan(); Circle ans = MinCircle(p); printf("%.10f\n%.10f %.10f\n", ans.r, ans.o.x, ans.o.y); return 0;&#125; 模拟退火法原理模拟退火算法 ( Simulated annealing ) 是一种寻找函数全局最优解的一种算法，它的出发点是物理中固体物质的退火过程与一般组合优化问题之间的相似性。 寻找全局最优解是一个很麻烦的事情。有人可能说，在一个位置看到哪个方向函数上升，就走向哪个方向不就行了吗？这种方法称为爬山法，爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此可能会局限于局部的最优值。如何跳出局部最优呢？ 模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。 模拟退火算法描述： 若 $J( Y(i+1) ) \geq J( Y(i) )$ (即移动后得到更优解)，则总是接受该移动 若 $J( Y(i+1) )&lt; J( Y(i) )$ (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定），随着能量差的增大而降低。具体来说： 在温度为 $T$ 时，出现能量差为 $\Delta E$ 的降温的概率为 $P(\Delta E)$，表示为：$$P(\Delta E) = e^{\frac {\Delta E} {kT}}$$这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。 关于爬山算法与模拟退火，有一个有趣的比喻： 爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。 模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。 实现注意这么几件事情： 模拟退火一般需要进行调参，平衡运行时间、迭代次数、精度等因素 实现模拟退火时更是要注意各种精度损失。最小圆覆盖问题中，如果不考虑精度问题，求距离时多次调用 sqrt 函数将会损失非常多的精度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const double eps = 1e-12;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; Point turn(double rad) &#123; return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); &#125; Point turn90() &#123; return Point(-y, x); &#125; void scan() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double dist2(Point A, Point B) &#123; return dot(A - B, A - B); &#125;double cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125;double angle(Vector A, Vector B) &#123; return acos(dot(A, B) / length(A) / length(B)); &#125;// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125; Point at(double theta) &#123; return o + Point(cos(theta)*r, sin(theta)*r); &#125; bool out(Point pt) &#123; return sgn(length(o-pt) - r) == 1;&#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());double Eval(const vector&lt;Point&gt;&amp; pt, Point o) &#123; double res = 0; for(auto g : pt) res = max(res, dist2(g, o)); return res;&#125;uniform_real_distribution&lt;double&gt; rgen(0.0, 1.0);double Rand()&#123; return rgen(rng); &#125;Circle MinCircleAnneal(const vector&lt;Point&gt;&amp; pt, double T, double dec, double ed) &#123; Point pcur(0.0, 0.0), pbest, pnew; int sz = pt.size(); for(auto g : pt) pcur = pcur + g; pbest = pcur = pcur / sz; double vcur = Eval(pt, pcur), vnew, vbest = vcur; while(T &gt; ed) &#123; pnew = pcur + Point((Rand()*2.0-1) * T, (Rand()*2.0-1.0) * T); vnew = Eval(pt, pnew); if(vnew &lt;= vbest) vbest = vcur = vnew, pbest = pcur = pnew; if(vnew &lt;= vcur || Rand() &lt; exp(-(vnew-vcur)/T)) vcur = vnew, pcur = pnew; T *= dec; &#125; return Circle(pbest, sqrt(vbest));&#125;int n;int main() &#123; scanf("%d", &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) p[i].scan(); Circle ans = MinCircleAnneal(p, 100000.0, 0.997, 3e-11); printf("%.10f\n%.10f %.10f\n", ans.r, ans.o.x, ans.o.y); return 0;&#125; 应用Opentrains 1519 GDescription给你了 $n$ 个定义在区间 $[0,T]$ 上的一次函数 $f_i(x) = a_ix+b_i$ ，定义两个一次函数的距离为：$$dist(f,g) = \left(\max_{0\leq i\leq T} (f(i)-g(i))\right)^2 + \left(\min_{0\leq i\leq T}(f(i)-g(i))\right)^2$$你现在要找一个一次函数 $g(x) = cx+d$ 使得下面的值最小：$$\max_{1\leq i\leq n} dist(f_i, g)$$你只需要输出最小值就可以了。 数据范围 $1\leq n \leq 200000$ Solution乍一看，貌似要想一想。那个最大值与最小值一定在定义域的两个端点或者两个函数相交的地方取到。。。等等，不对啊，看清楚之后，我们会发现，那个平方是加在外面的，因此要我们求最值的函数就是 $f(x)-g(x)$ ，两个一次函数之差还是一次函数！那么最值一个在 $x=0$ 处取得，一个在 $x=T$ 处取得。 我们用 $f(0)$ 与 $f(T)$ 两个值来表征一个一次函数，可以发现，如果把 $\big(f(0),f(T)\big)$ 作为点画在二维平面上， $dist(f,g)$ 即为这两个点的欧几里得距离。把题中 $n$ 个点都画出来，我们要找一个点使得这个点到其他点的距离的最大值最小，这不就是最小圆覆盖吗！ 最小球覆盖那么考虑三维的情况，会是什么样子的呢？2018 ACM-ICPC 南京区域赛的 D 题正是最小球覆盖的裸题。 大致有两种方法，模拟退火法和三分套三分套三分。（我很奇怪为什么没有随机增量类似的方法了，不过很可能是三维情况下四点定球不是非常好写）。 模拟退火代码：（2018南京D） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const double eps = 1e-12;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y, z; Point(double xp=0, double yp=0, double zp=0): x(xp), y(yp), z(zp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y, z+rhs.z); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y, z-rhs.z); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k, z*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k, z/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y) || (x==rhs.x&amp;&amp;y==rhs.y&amp;&amp;z&lt;rhs.z); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0 &amp;&amp; sgn(z-rhs.z)==0; &#125; void scan() &#123; scanf("%lf%lf%lf", &amp;x, &amp;y, &amp;z); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y + x.z*y.z; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double dist2(Point A, Point B) &#123; return dot(A - B, A - B); &#125;// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());double Eval(const vector&lt;Point&gt;&amp; pt, Point o) &#123; double res = 0; for(auto g : pt) res = max(res, dist2(g, o)); return res;&#125;uniform_real_distribution&lt;double&gt; rgen(0.0, 1.0);double Rand()&#123; return rgen(rng); &#125;Circle MinCircleAnneal(const vector&lt;Point&gt;&amp; pt, double T, double dec, double ed) &#123; Point pcur, pbest, pnew; int sz = pt.size(); for(auto g : pt) pcur = pcur + g; pbest = pcur = pcur / sz; double vcur = Eval(pt, pcur), vnew, vbest = vcur; while(T &gt; ed) &#123; pnew = pcur + Point((Rand()*2.0-1) * T, (Rand()*2.0-1.0) * T, (Rand()*2.0-1) * T); vnew = Eval(pt, pnew); if(vnew &lt;= vbest) vbest = vcur = vnew, pbest = pcur = pnew; if(vnew &lt;= vcur || Rand() &lt; exp(-(vnew-vcur)/T)) vcur = vnew, pcur = pnew; T *= dec; &#125; return Circle(pbest, sqrt(vbest));&#125;int n;int main() &#123; scanf("%d", &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) p[i].scan(); double ans = 1e13; rep(i, 40) &#123; Circle cir = MinCircleAnneal(p, 100000.0, 0.999, 3e-7); ans = min(ans, cir.r); &#125; printf("%.10f\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小圆覆盖</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opentrains 1519 训练报告]]></title>
    <url>%2F2019%2F04%2F20%2FOpentrains-1519-%E8%AE%AD%E7%BB%83%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Petrozavodsk Winter-2018. Carnegie Mellon U Contest.Overview Status A B C D E F G H I J K Contest 0:44 4:05 (0) (1) Upsolve AC OK $\mathcal{O}$ OK $\mathcal{O}$ AC AC AC AC Attempt *10 + +5 * *3 *2 *1 AC count 44 126 74 71 14 109 27 85 39 67 8 Tag 线段树 签到 矩阵 结论 点分治 DS 最小圆覆盖 状压 背包 dp Coding 4857 1283 ? 916 ? ? 3039 923 2287 1233 ? Thinking Mid- Easy Mid Mid ? Easy Mid Mid- Mid Easy ? Stars ★ ★★ ★ ★ ★ 注：$\mathcal O$ 表示口头通过。 Dodo_kindergarten 队第一次三人正式训练，这一场打的有点自闭啊 ，过了签到题就没怎么想出题目了，但实际上还有很多签到题呢。cyy 和 wzk 一共做出来四道题。这一场说明了我还有许多算法没有做到熟练运用，看来需要努力补充一些短板的。 Solved during contest: 2/11 Upsolved: 7/11 Orally upsolved 9/11 Rank 114/137 新技能-最小圆（球）覆盖 get [UPD 2019.05.03] 补掉了大傻题 J 题，直接求 Zigzag 公共子序列就 AC 了，题意没说清楚。 [TODO1] Code Problem C, F[TODO2] Solve Problem E, K 一些资源： CYY写的题解，解决了剩下的历史遗留问题 比赛链接 Claris题解 BUAA题解 zbh对于I题的思考 Replay开局我看的是 H 题，whr 看 B，sl 看 J 题。发现 H 题数据范围不大，商量着要不写一个爆搜试一试，结果我写完之后本地测 $n=24$ 的数据，跑了五分钟都没有跑出来，弃疗了。 我和 whr 看了下 B，发现是可做题，我于是开始写，于 00:44 通过，可是榜上已经过了一大片了。 我发现 F 就是裸的二维数点问题，可是没有整理模板，就自闭了。wzk 几分钟就写完了。这个锅我背，除了线段树之外，我基本上都在做思维题之类的，都不知道多长时间没有写硬核的数据结构题了，这次比赛让我深刻认识到我的数据结构已经弱到了什么地步。 之后陷入无限期的自闭状态。sl 说了 D 题的结论，可是我不太相信。 whr 尝试写 H 题的模拟退火，可惜 WA 了。期间 cyy 他们过了 C 题，可是我没来得及仔细看。我又想写 H 题的另一种搜索，可是也没成功。这一阶段的状态特别不好，感觉什么题都做不出来。 sl 再次要求我听他讲 D 题的结论。我听完之后大致口胡出了一种证明，感觉挺对的。于是开始写，可是有点难写。纠结了好一会实现方式，终于我会了一种比较简单的写法。开工！03：34的时候我们交了第一发，结果 WA on test 160 ，心态炸了。自闭了好一会，发现有个细节的写法略有问题，稍微修改了一下，终于在04：05的时候获得了OK。 看了一会儿新题，感觉也没有别的心思来想题了，于是就跑路了。最后就只有两题滚粗了 QAQ。 Prob B. 签到，set题意一条直线上放了 $n$ 个球，每个球的坐标已知，最右边位置 $W$ 处是一堵坚实的墙壁。要求支持下面两种操作： 在 $p$ 位置放入新球，如果这个位置有球则忽略。 将最左边的球向右打。一个球如果碰到 $x$ 位置的另一个球，则它会在 $x-1$ 的位置停下，然后使 $x$ 位置的求开始向右运动，从而引发连锁反应。一个球撞击到墙则立即停止在 $W-1$ 处。 题解不妨设最左边球的位置是 $l$ ，稍加模拟即可知道操作本质是将区间 $[l,W]$ 向左循环移位了一个单位。模拟这个过程，只需要考虑将最左边的球加到墙的右边即可。如果要支持放入新球，只需要用一个 set 维护就可以了。 复杂度 $O((n+q)\log n)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 202000;int n, q, w, op, xp, tl;set&lt;int&gt; st;int main() &#123; read(n, q, w); rep(i, n) read(xp), st.insert(xp); while(q--) &#123; read(op); if(op == 1) &#123; int pos, d; read(pos); d = pos + tl; if(st.count(d) == 0) st.insert(d); &#125; else &#123; auto ed = *st.begin(); st.erase(ed); st.insert(w + tl); tl++; &#125; &#125; bool first = true; for(auto g : st) &#123; if(first) first = false; else putchar(' '); printf("%d", g - tl); &#125; putchar('\n'); return 0;&#125; Prob D. 结论，数学，模拟题意你有一个超八边形图，每个顶点度数都是 3 ，每条边都同时属于两个八边形环，如下图所示。 这个图中，每条边都有标号，是 $\{a,b,c\}$ 中的一种。标号满足下面的性质： 每个节点连出去的三条边的标号互不相同 每个八边形环上的标号序列恰好是交错的，即是与 $abababab$ 类似的 现在给出了一个标号序列，问在八边形图中能否找到一个对应的路径，使这个序列对应的边连成一个回路。 题解结论 我们断言，对于序列中我们尽量消除下面两种子串，那么有回路就等价于最后序列被删空了。 直接删除两个相同标号的重复出现的子串，如 $aa$ 将五元交错子串掐头去尾，如将 $ababa$ 变为 $bab$ 证明： 最开始，根据对称性，起点的选择显然是无关紧要的。 首先直观理解一下，第一种子串相当于走一个来回，第二种子串相当于将走得远的路径变成走得近的。事实上第二个操作也可以转化六元环与七元环，直接删除八元环。 然后考虑反证法，如果这两种情况都没出现，这个序列还是一个回路，那么这就说明这个回路走过的每一个环长度都不超过 $4$ ，但是这么走是不可能走回起点的。 实现 上述的做法实现起来还是略有难度，关键点是不重不漏，还要保证复杂度不爆炸。细节见代码吧，这份代码还算是写得非常简洁的。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 902000;int n, m = 0;char s[maxn], t[maxn];int main() &#123; scanf("%s", s); n = strlen(s); for(int i = 0; i &lt; n; ++i) &#123; if(m &gt; 0 &amp;&amp; t[m-1] == s[i]) m--; else &#123; t[m++] = s[i]; &#125; if(m &gt;= 5 &amp;&amp; t[m-1]==t[m-3] &amp;&amp; t[m-3]==t[m-5] &amp;&amp; t[m-2]==t[m-4] &amp;&amp; t[m-1] != t[m-2]) &#123; char t2 = t[m-2], t3 = t[m-3], t4 = t[m-4]; m -= 5; i -= 2; s[i] = t4; s[i+1] = t3; s[i+2] = t2; i--; &#125; while(m &gt; 1 &amp;&amp; t[m-1] == t[m-2]) m -= 2; &#125; if(m) puts("open"); else puts("closed"); return 0;&#125; 赛后补题Prob H. 状压 dpDescription你有 $n$ 个体积分别是 $w_i$ 的物品，现在要把它们装进最多装体积为 $S$ 的背包里，问至少需要几个背包才能把所有物品都装下。数据范围 $n\leq 24,w_i\leq 10^9$ Solution一种显然的想法是爆搜，或者模拟退火之类的玄学解法，可是貌似都不奏效。。。 一种比较好的方法是状压 dp 。为了避免后效性，我们给出一种比较强的定义状态的方式，我们采用将背包一个一个填满的方式，而不是几个背包同步填。 定义 $dp[S]$ 表示按照一定顺序删除 $S$ 中元素之后，至少使用的背包数量 $c$，与最后一个背包的剩余体积 $v$ 组成的二元组 $(c,v)$。 这样的话，dp就是可以合并的了，直接按照 $c$ 是第一关键字， $v$ 是第二关键字进行合并即可。转移是显然的。 复杂度 $O(n\cdot 2^n)$ Comment这道题的一大启示就是，在保证等价的前提下，定义状态的时候可以附加一定条件，使得 dp 转移更加方便高效。 Code1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 25, maxs = (1 &lt;&lt; 24) + 30;pii dp[maxs];int n, a[maxn], s, full;void up(pii &amp;p, pii x) &#123; if(x.first &lt; p.first) p = x; else if(x.first == p.first &amp;&amp; x.second &gt; p.second) p = x;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;s); rep(i, n) scanf("%d", &amp;a[i]); full = (1 &lt;&lt; n) - 1; memset(dp, 0x3f, sizeof dp); dp[0] = &#123;0, 0&#125;; for(int S = 0; S &lt; full; ++S) &#123; for(int j = 0; j &lt; n; ++j) if(~S &gt;&gt; j &amp; 1) &#123; int lft = dp[S].second - a[j]; pii upd; if(lft &gt;= 0) upd = &#123;dp[S].first, lft&#125;; else upd = &#123;dp[S].first + 1, s - a[j]&#125;; up(dp[S | (1&lt;&lt;j)], upd); &#125; &#125; printf("%d\n", dp[full].first); return 0;&#125; Prob G. 最小圆覆盖Description给你了 $n$ 个定义在区间 $[0,T]$ 上的一次函数 $f_i(x) = a_ix+b_i$ ，定义两个一次函数的距离为：$$dist(f,g) = \left(\max_{0\leq i\leq T} (f(i)-g(i))\right)^2 + \left(\min_{0\leq i\leq T}(f(i)-g(i))\right)^2$$你现在要找一个一次函数 $g(x) = cx+d$ 使得下面的值最小：$$\max_{1\leq i\leq n} dist(f_i, g)$$你只需要输出最小值就可以了。 数据范围 $1\leq n \leq 200000$ Solution乍一看，貌似要想一想。那个最大值与最小值一定在定义域的两个端点或者两个函数相交的地方取到。。。等等，不对啊，看清楚之后，我们会发现，那个平方是加在外面的，因此要我们求最值的函数就是 $f(x)-g(x)$ ，两个一次函数之差还是一次函数！那么最值一个在 $x=0$ 处取得，一个在 $x=T$ 处取得。 我们用 $f(0)$ 与 $f(T)$ 两个值来表征一个一次函数，可以发现，如果把 $\big(f(0),f(T)\big)$ 作为点画在二维平面上， $dist(f,g)$ 即为这两个点的欧几里得距离。把题中 $n$ 个点都画出来，那么所要求的就是最小圆覆盖！ 不过最小圆覆盖怎么求呢？随机增量法或者模拟退火法都可以实现，这里就用的是随机增量法。有关最小圆覆盖，我单独写了一篇博客，看这里 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 102000;const double eps = 1e-7;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; Point turn(double rad) &#123; return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); &#125; Point turn90() &#123; return Point(-y, x); &#125; void scan() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125;double angle(Vector A, Vector B) &#123; return acos(dot(A, B) / length(A) / length(B)); &#125;Point LLIntPV(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; assert(cross(v, w) != 0); double t = cross(w, u) / cross(v, w); return P + v * t;&#125; // Line: Point + Vector// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125; Circle(Point A, Point B, Point C) &#123; assert(sgn(cross(B-A, C-A)) != 0); Point mab = (A + B) / 2.0, ab = (B - A).turn90(); Point mbc = (B + C) / 2.0, bc = (C - B).turn90(); o = LLIntPV(mab, ab, mbc, bc); r = length(A - o); &#125; Point at(double theta) &#123; return o + Point(cos(theta)*r, sin(theta)*r); &#125; bool out(Point pt) &#123; return sgn(length(o-pt) - r) == 1;&#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());Circle MinCircle(vector&lt;Point&gt; pt) &#123; int sz = pt.size(); shuffle(pt.begin(), pt.end(), rng); Circle cc(pt[0], 0.0); for(int i = 0; i &lt; sz; ++i) if(cc.out(pt[i])) &#123; cc = Circle(pt[i], 0.0); for(int j = 0; j &lt; i; ++j) if(cc.out(pt[j])) &#123; cc = Circle((pt[i] + pt[j]) / 2.0, length(pt[i]-pt[j]) / 2.0); for(int k = 0; k &lt; j; ++k) &#123; if(cc.out(pt[k])) &#123; cc = Circle(pt[i], pt[j], pt[k]); &#125; &#125; &#125; &#125; return cc;&#125;int n, T, aa, bb;int main() &#123; scanf("%d%d", &amp;T, &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d %d", &amp;aa, &amp;bb); p[i] = Point(bb, T * aa + bb); &#125; Circle ans = MinCircle(p); printf("%.10f\n", ans.r * ans.r); return 0;&#125; Prob A. 线段树优化建图+Tarjan SCCSolution我们将连边 $a\to b$ 如果炸弹 $a$ 爆炸时能够引爆炸弹 $b$ 。每个炸弹影响的区域都是一个连续的区间，可以通过线段树优化建图将有向图建出来。然后缩点，把得到的 DAG 中入度为 0 的 SCC 最小权值加进答案即可。 怎么支持修改？实际上修改只修改权值，是不改变建出来的图的，只需要每一个SCC都用一个 multiset 维护SCC中的权值即可实现。 Comment对于这道题，真的不知道该说什么才好。。。基本上是一眼题，但是写起来是真心毒瘤。代码长度4857Byte，花了将近两个小时才写完，然后用了一个小时调试错误，最后才发现就是某一个数组开小了。 警示： 遇到RE，永远要首先检查数组大小是否都开足够。不管自己多么自信不会数组开销也要检查！！！ Windows下本机测试手动扩栈的方法：编译选项 -Wl,--stack,268435456 Code点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/* Generated by powerful Codeforces Tool * Author: YangDavid * Time: 2019-04-22 16:04:47*/#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int INF = 0x3f3f3f3f;const int maxn = 202000;using Graph = vector&lt; vector&lt;int&gt; &gt;;vector&lt;int&gt; sccno, dfn, low;stack&lt;int&gt; S;Graph G(maxn * 4), nG;// === template part ===namespace Tarjan &#123; // input Graph G and vertex number vc, (index starts with 1) // then call find_scc(). nG is the new graph, sc is number of vertices in nG // (index starts with 1) int vc, sc, dfs_clock; void Tarjan(int v) &#123; S.push(v); low[v] = dfn[v] = ++dfs_clock; for(auto u : G[v]) &#123; if(!dfn[u]) &#123; Tarjan(u); low[v] = min(low[v], low[u]); &#125; else if(!sccno[u]) low[v] = min(low[v], dfn[u]); &#125; if(low[v] == dfn[v]) &#123; sc++; for(;;) &#123; int p = S.top(); S.pop(); sccno[p] = sc; if(p == v) break; &#125; &#125; &#125; void find_scc(int sz = G.size() - 1) &#123; // returns &#123;new Graph, sccno&#125; sc = dfs_clock = 0; vc = sz; sccno = dfn = low = vector&lt;int&gt;(vc + 2); for(int i = 1; i &lt;= vc; ++i) if(!dfn[i]) Tarjan(i); nG.resize(sc + 1); for(int u = 1; u &lt;= vc; ++u) for(auto v : G[u]) if(sccno[u] != sccno[v]) nG[sccno[u]].push_back(sccno[v]); &#125;&#125;// === end of template ===struct mine &#123; int p, r, c, id; bool operator &lt; (const mine&amp; me) const &#123; return p &lt; me.p; &#125;&#125; a[maxn], as[maxn];int n, q, rk[maxn];multiset&lt;pii&gt; asc;multiset&lt; pii, greater&lt;pii&gt; &gt; des;multiset&lt;int&gt; w[maxn * 4];int vc;void link(int p, int ql, int qr, int o = 1, int l = 1, int r = vc) &#123; if(ql &lt;= l &amp;&amp; r &lt;= qr) &#123; G[p].push_back(o); return; &#125; int mid = (l + r) &gt;&gt; 1; if(ql &lt;= mid) link(p, ql, qr, o &lt;&lt; 1, l, mid); if(qr &gt; mid) link(p, ql, qr, o &lt;&lt; 1 | 1, mid + 1, r);&#125;int main() &#123; #ifdef FREOPEN freopen("in1.txt", "r", stdin); #endif read(n, q); rep(i, n) &#123; read(a[i].p, a[i].r, a[i].c); a[i].id = i; as[i] = a[i]; &#125; sort(as + 1, as + n + 1); for(int i = 1; i &lt;= n; ++i) &#123; asc.emplace(as[i].p, i); des.emplace(as[i].p, i); &#125; vc = 1; while(vc &lt; n) vc &lt;&lt;= 1; for(int i = 1; i &lt; vc; ++i) &#123; G[i].push_back(i &lt;&lt; 1); G[i].push_back(i &lt;&lt; 1 | 1); &#125; // as[i] &lt;-&gt; G[i+vc-1] for(int i = 1; i &lt;= n; ++i) &#123; int lp = as[i].p - as[i].r - 1; int rp = as[i].p + as[i].r + 1; int l = asc.upper_bound(&#123;lp, INF&#125;) -&gt; second; int r = des.upper_bound(&#123;rp, 0&#125;) -&gt; second; link(vc - 1 + i, l, r); &#125; Tarjan::find_scc(vc * 2- 1); int vnc = Tarjan::sc; vector&lt;int&gt; indeg(vnc + 10), mark(vnc + 10); auto BFS = [&amp;]() &#123; set&lt;int&gt; leftscc; for(int i = vc; i &lt; 2 * vc; ++i) leftscc.insert(sccno[i]); queue&lt;int&gt; qq; for(auto g : leftscc) qq.push(g); while(!qq.empty()) &#123; int tp = qq.front(); qq.pop(); for(auto g : nG[tp]) if(!indeg[g]) &#123; indeg[g] = true; qq.push(g); &#125; &#125; for(int i = 1; i &lt;= vnc; ++i) &#123; mark[i] = 1 - indeg[i]; &#125; &#125;; BFS(); for(int i = 1; i &lt;= n; ++i) if(mark[sccno[vc-1+i]]) w[sccno[vc-1+i]].insert(as[i].c); ll ans = 0; for(int i = 1; i &lt;= vnc; ++i) if(mark[i]) ans += *w[i].begin(); for(int i = 1; i &lt;= n; ++i) rk[as[i].id] = i; while(q--) &#123; int m, nc; read(m, nc); int wno = sccno[rk[m] + vc - 1]; if(mark[wno]) &#123; ans -= *w[wno].begin(); w[wno].erase(w[wno].find(a[m].c)); w[wno].insert(nc); ans += *w[wno].begin(); &#125; a[m].c = nc; write(ans); // printf(" q = %d", q); putchar('\n'); &#125; return 0;&#125; 以下部分纯属口胡~不过基本都是靠谱的。 Prob. I 背包神题Description给出 $n≤5000$ 个物品，第 $i$ 个物品的体积为 $v_i$ ，求所有体积和恰为 $1\leq V\leq5000$ 且物品数量最小的集合中，最小的平均体积，最小的中位数（偶数的中位数是中间靠左的一个），最小的众数个数，最小的极差 Solution Editorial by HDMMBLZ 下面我们一个一个说： 首先我们得做一遍普通背包得知体积恰为 $V$ 最少多少个物品，设为 $m$ 个 平均值：直接算，$O(1)$ 中位数： 算法一：做前缀背包和后缀背包并枚举中位数，检查是否合法时枚举集合种比中位数小的背包体积和，复杂度$O(nV)$,常数为 $3$ 算法二：二分中位数，把每个物品价值变成 $inf+(−1)[vi&lt;mid]$，做体积固定价值最小的背包，若结果大于m⋅midm·mid则当前中位数过小，否则过大。此方法虽然多一个 $log$，但巧妙地通过 $\inf $ 把物品数量最小的限制转化掉了，感觉挺有启发 众数： 算法一：二分答案然后做背包，复杂度 $O(nVlogn)$ 算法二：从小到达枚举众数，每次把可以增加的物品加入背包，复杂度 $O(nV)$ 极差： 极差是这道题目的精华，两个算法都很有启发性 算法一：将物品按照vivi排序后，考虑滑动窗口，滑动窗口里是要满足存在一个大小为 $m$ 的子集使得体积和为 $V$ ,我们现在这样支持添加物品和删除物品：维护两个栈，栈的每个元素都是一个长度为VV的代表背包的数组，共需要V2V2空间，当我们加入一个物品时，直接加在AA栈栈顶，用原来AA栈栈顶的背包更新构成新栈顶，如果我们要删除一个物品（这个物品是当前区间的第一位），这时如果栈BB不为空，说明要删除的东西是栈BB栈顶，那么直接将栈BB的栈顶弹出即可，如果栈BB是空的，说明要删除的物品是栈底，这时，我们将AA除了栈底以外的元素一个个弹出，并按照弹出的顺序一个个加入栈BB并做背包即可。 我们发现，栈 $A$ 从顶到底元素的 $v_i$ 减小，栈 $B$ 从底到顶元素的 $v_i$ 减小 要查询整个背包某一项，直接合并A、BA、B栈顶所代表的背包即可，合并一次复杂度 $O(V)$ 势能分析可得这样做维护两个栈背包的时间是 $O(nV)$ 以上方法可以处理所有滑动窗口背包、$n$次查询背包某一个值的问题 算法二：按照vivi从小到大加入背包，把物品价值设为inf−viinf−vi(更新dp[vi]dp[vi]时)，infinf（其他时候），枚举最大值直接查询即可，不得不说这个方法也很棒。 总复杂度 $O(nV)$ Code这里的实现很多都偷懒了，用的是带 log 的做法。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* Generated by powerful Codeforces Tool * Author: YangDavid * Time: 2019-04-23 09:30:51*/#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 5500, INF = 10008;int dp[maxn], n, xp, s, gg;int knapsack(const vector&lt;int&gt;&amp; V, const vector&lt;int&gt;&amp; W, int ss) &#123; int sz = V.size(); memset(dp, 0x3f, sizeof dp); dp[0] = 0; for(int i = 0; i &lt; sz; ++i) &#123; for(int j = ss; j &gt;= V[i]; --j) dp[j] = min(dp[j], dp[j - V[i]] + W[i]); &#125; return dp[ss];&#125;vector&lt;int&gt; ve, w, v;bool CheckMost(int x) &#123; int cur = -1, tim = 0; vector&lt;int&gt; W, V; for(auto g : ve) &#123; if(g == cur) &#123; if(++tim &gt; x) continue; &#125; else &#123; cur = g; tim = 1; &#125; W.push_back(1); V.push_back(g); &#125; return knapsack(V, W, s) == gg;&#125;bool CheckMedian(int x) &#123; vector&lt;int&gt; W; for(auto g : ve) &#123; if(g &lt;= ve[x]) W.push_back(INF - 1); else W.push_back(INF + 1); &#125; return knapsack(ve, W, s) &lt;= gg * INF;&#125;int Dif() &#123; memset(dp, 0x3f, sizeof dp); dp[0] = 0; int ans = 0x3f3f3f3f; for(int i = 0; i &lt; n; ++i) &#123; for(int j = s; j &gt; v[i]; --j) dp[j] = min(dp[j], dp[j - v[i]] + INF); dp[v[i]] = min(INF - v[i], dp[v[i]]); ans = min(ans, dp[s] + v[i]); &#125; return ans % INF;&#125;signed main() &#123; scanf("%d%d", &amp;n, &amp;s); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;xp); ve.push_back(xp); w.push_back(1); &#125; sort(ve.begin(), ve.end()); v = ve; gg = knapsack(ve, w, s); if(gg &gt; n) &#123; puts("-1"); return 0; &#125; printf("%.10f ", (double)s / (double)gg); int l = 0, r = n - 1; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(CheckMedian(mid)) r = mid; else l = mid + 1; &#125; printf("%d ", ve[l]); l = 1, r = n; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(CheckMost(mid)) r = mid; else l = mid + 1; &#125; printf("%d ", l); printf("%d\n", Dif()); return 0;&#125; Prob. C AC自动机+高斯消元 or 矩阵快速幂将这两个串的 AC 自动机建出来，然后问题就变为类似在这个有向图上（带 fail 链接）随机游走的问题。 Prob E. 点分治不会。]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
        <tag>Opentrains</tag>
        <tag>结论</tag>
        <tag>最小圆覆盖</tag>
        <tag>背包</tag>
        <tag>线段树优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何知识小结]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[还没有完成，先把目前的板子贴上来吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const double eps = 1e-10;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; Point turn(double rad) &#123; return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); &#125; void scan() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125;double angle(Vector A, Vector B) &#123; return acos(dot(A, B) / length(A) / length(B)); &#125;Point LineProjection(Point P, Point A, Point B) &#123; Vector v = B - A; return A + v * (dot(P-A, v) / dot(v, v));&#125;Point LineReflection(Point P, Point A, Point B) &#123; Point proj = LineProjection(P, A, B); return proj + proj - P;&#125;int Clockwise(Point O, Point A, Point B) &#123; /* Clockwise: -1 Counterclockwise: 1 Otherwise: 0 */ return sgn(cross(A - O, B - O));&#125;void SegCheck(Point a, Point b, Point p) &#123; Vector d = b - a, e = p - a; if(sgn(dot(d, e)) == -1) puts("ONLINE_BACK"); else if(sgn(length(e) - length(d)) == 1) puts("ONLINE_FRONT"); else puts("ON_SEGMENT");&#125;int JudgeLLParOrth(Point a1, Point a2, Point b1, Point b2) &#123; /* 2: parallel 1: orthogonal 0: otherwise */ Vector v = a2 - a1, w = b2 - b1; if(sgn(cross(v, w)) == 0) return 2; if(sgn(dot(v, w)) == 0) return 1; return 0;&#125;bool CheckSSProperIntersection(Point a1, Point a2, Point b1, Point b2) &#123; double c1 = cross(a1 - b1, b2 - b1), c2 = cross(a2 - b1, b2 - b1); double c3 = cross(b1 - a1, a2 - a1), c4 = cross(b2 - a1, a2 - a1); return sgn(c1) * sgn(c2) == -1 &amp;&amp; sgn(c3) * sgn(c4) == -1;&#125;bool OnSeg(Point P, Point A, Point B) &#123; // (A, B) Vector v = B - P, w = A - P; if(sgn(cross(v, w)) != 0) return false; return sgn(dot(v, w)) == -1;&#125;bool CheckSSIntersection(Point a1, Point a2, Point b1, Point b2) &#123; if(a1 == b1 || a1 == b2 || a2 == b1 || a2 == b2) return true; if(OnSeg(a1, b1, b2) || OnSeg(a2, b1, b2) || OnSeg(b1, a1, a2) || OnSeg(b2, a1, a2)) return true; return CheckSSProperIntersection(a1, a2, b1, b2);&#125;// Ensure lines intersect first!!! cross(v, w) != 0Point LLIntersection(Point a1, Point a2, Point b1, Point b2) &#123; Vector v = a2 - a1, w = b2 - b1, u = a1 - b1; assert(cross(v, w) != 0); double t1 = cross(w, u) / cross(v, w); return a1 + v * t1;&#125; // Line: 2 PointsPoint LLIntPV(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; assert(cross(v, w) != 0); double t = cross(w, u) / cross(v, w); return P + v * t;&#125; // Line: Point + Vectordouble PLDist(Point P, Point A, Point B) &#123; // Point-Line return fabs(cross(B - P, A - P) / length(A - B));&#125;double PSDist(Point P, Point A, Point B) &#123; // Point-Segment if(A == B) return length(P - A); if(sgn(dot(A-P, B-A)) == 1) return length(A - P); if(sgn(dot(B-P, B-A)) == -1) return length(B - P); return fabs(cross(B-P, A-P) / length(A-B));&#125;double SSDist(Point a1, Point a2, Point b1, Point b2) &#123; // segment - segment if(CheckSSIntersection(a1, a2, b1, b2)) return 0.0; return min(min(PSDist(a1,b1,b2), PSDist(a2,b1,b2)), min(PSDist(b1,a1,a2), PSDist(b2,a1,a2)));&#125;// Polygon Operationstypedef vector&lt;Point&gt; Polygon;double PolygonArea(const Polygon&amp; p) &#123; int sz = p.size(); double tot = 0.0; for(int i = 1; i &lt; sz - 1; ++i) tot += cross(p[i]-p[0], p[i+1]-p[0]); return fabs(tot / 2.0);&#125;int main() &#123; Point x; Polygon pol; int q; scanf("%d", &amp;q); while(q--) &#123; x.scan(); pol.push_back(x); &#125; printf("%.1f\n", PolygonArea(pol)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam Round 1A 翻车记（附题解）]]></title>
    <url>%2F2019%2F04%2F13%2FGoogle-Code-Jam-Round-1A-%E6%B8%B8%E8%AE%B0%EF%BC%88%E9%99%84%E9%A2%98%E8%A7%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天第一次打正式的Google Code Jam比赛，从开场思维混乱，前期血崩，时间过去一大半才写好A题的慌张，到发现B题是智障题的窃喜，再到B题奇怪地TLE、WA，以为读错题的恐惧，到没来得及写完C题的遗憾，再到最后发现过掉A题的人是最少的的信息，这次比赛的心路历程真的是一波三折啊！看来不管前期怎么样，都不要放弃希望啊！在这里就记录一下我的感受吧。 一些客观结果： Rank 942 out of 8440, Score 63 / 100 T1 Accepted (31 / 31, 1 try, 3266 byte) T2 Accepted (32 / 32, 3 tries, 1919 byte) T3 Not attempted (0 / 37, 0 try) (Upsolved, 1 try, 1487 byte) Replay之前没有看过以前 GCJ 的题目，一看只有三道题，有部分分，感觉有点 OI 赛制的意味啊，那就按顺序开题吧。 开场看了A题，发现是比较擅长的构造题。模拟了下题意，有一点思路了，但是还没有仔细想。往后瞄了一眼，发现C题好多人都过掉了，读了好几遍题意，结果还是没读懂。这又是字符串题，不算特别擅长。我有点自闭了，最后还是决定开 A 题。 想了5分钟，基本想出构造的框架了；可是有不少细节。一会我发现小范围需要暴力，一会我发现构造方法需要分奇偶性讨论，常常是我想出来一种解决方案，可是一会儿就被自己 hack 了。中途看了眼榜，发现榜单有 800 页人，可是我错以为是 800 个人了，自认为竞争不激烈，可以随便打。然后就开始休闲敲代码模式，写了改，改了写，不知道弄了多久，终于过自己的样例了，可是也不是多稳。先交一下吧，交上去果然也过 pretest 了。可是一看排名：You are ranked 3890. ？？？什么鬼？这时候我才发现 800 只是页数，我顿时开始慌了。一看当时太休闲了，已经过去 90 分钟了，只剩下 60 分钟解两道题，其中还有一道我读不懂，过 pretest 的题也大概率 FST。算了，这一场就是背，我心想。 不想看 C 题啊，于是我又迷迷糊糊看了一下 B 题，发现是道交互题。神志不清地想了一下，发现题目给的条件怪多，可是这不就是个 CRT 裸题吗？迅速敲完了代码，交上去，结果 TLE 。发现是调试语句忘删除了，删掉之后信心满满交了一发，结果 WA。这次我可是有点自闭了，我是不是读错题了？慌忙又读了一下题，没问题啊！看了眼代码，发现多组数据，有个数组忘记清空了。唉，我是智障，改了一下就过了。 看了下表，还有 28 分钟。 C 题应该是不难的吧，那么多人都过了。可是刚开始读题的阴影挥之不去，比赛时间也越来越少。耐下心来仔细读，总算把题目读懂了。还剩下 20 分钟，这题怎么做啊？我想到了一个很靠谱的贪心（本质和 trie 一样），但是中间需要用后缀数组求lcp 。这怎么可能写完？我想到用字符串哈希实现，结果发现那样做可能会炸复杂度。我唯独没有想到直接用 trie 树。只剩 6 分钟了，我突然发现，把字符串翻转之后扔进 trie 树，之后不就是遍历一下 trie 树的智障题了吗？可是实在是来不及写了。想着总要拿到 10 分部分分吧，可是也不会。最后只得在痛苦中迎来比赛的结束。 刷新了一下，前两道题都过了，可是还是 Rank 1738 。乖乖，连前 1500 都没进，真是状态太差了啊，还要看 Round 1B、Round 1C 的发挥了。唉，真是丢人啊。结果又刷新了一下，发现榜更新 system test 的数据了，排名回到了 942，总算是没崩太惨。看榜发现 C 题是场上通过率最高的题，A 题只有 10% 的人过 system test ！问了问 cyy, wzk 他们也都没有通过 A 题的 system test。就过掉的题目的难度来看，看来也许打得不算太崩？只是时间分配方面问题比较大了。 经验教训： 时间分配一定要做好，写代码也要不时看表，不要写得太休闲； 要相信自己做构造题的能力； 仔细读题，认真读题，不要读不懂题目就自闭。 TutorialProb A. 构造Description给你一个 $n \times m$ 的长方形棋盘，你需要在棋盘中构造出这么一条哈密尔顿路径（注意：不是回路），使得路径上任何相邻两个节点不在同一行、不在同一列，且不在同一对角线上。 Solution这道题大体上有两类思路。一种是硬核构造型的，另一种是大力随机化搜索型的。我场上想的是构造性的解法。 构造性解法我们主要的构造思路如下图所示： 我们先按照上图在棋盘上摆 $n$ 个珠子，按顺序依次访问这些点。然后我们我们重复 $m$ 次，每次按从上到下的顺序把某一行中的珠子向右移动一格，如果到了最右边，就把棋子挪回最左边。同时访问新珠子所在的位置。 读者可以思考一下，这样下去，如果棋盘足够大，那么我们每次相邻访问的位置总是纵坐标差1，横坐标差很多，或者横坐标差1，纵坐标差很多，或者走的是一个日字，都是可行操作。（注意此处的“很多”指的是上图中任何一段黑线的长度） 首先我们可以翻转棋盘，使得 $n\leq m$ 。事实上原原本本实现上面的想法也仅仅只遗漏了这几种情况： $n$ 是偶数，并且 $n=m$ ，这样从最底下是蓝线，访问完蓝线后，从最底下跳到最上面可能会经过斜对角线。 $n$ 和 $m$ 中存在小于 5 的数，这样上面分析中的“很多”就不多了，可能出现同对角线的情况。 对于第一种情况，比较难处理，我稍微改变了一下访问珠子的次序，并且当棋子到达最右侧时采用了另一种策略，对剩下的两列棋子分开处理。我的处理方式对于任何偶数 $n$ 都是成立的，不限于 $n=m$ 的情况。细节见代码。 对于第二种情况，可以发现 $n=2,m\leq 4$ 时无解， $n=3,m=3$ 时无解。剩下的情况基本上都可以用上面的策略完成，除了 $n=4,m=4$ 必须手动打表。 由此我们就讨论清楚了所有可能的情况，实现一下就好了。 总时间复杂度： $O(nm)$，已达到理论下界。（因为要输出方案） 搜索策略（待填坑）这个图中的哈密尔顿路径理应是非常多的，所以很多选手提交了随机化搜索的代码也得到了通过。 再谈哈密尔顿问题（待填坑）这个问题可以归约到哈密顿回路这一个著名的 NPC 问题，那么这里也拓展一下我所见到的哈密顿回路相关知识吧。 CYY提到了哈密尔顿回路问题中的 Dirac 定理，内容如下： 设一个无向图中有 $N$ 个节点，若所有节点的度数都大于等于 $N/2$ ，则哈密尔顿回路一定存在。 这个定理在这道题中还是蛮适用的，每个节点和大于 $nm-2n-2m$ 个节点连边，在 $n,m$ 都比较大的情况下是可以满足上面的条件的。而 Dirac 定理的证明是构造性的，我们也可以直接得到一条这样的哈密尔顿路径。 还有一个著名的定理是有关竞赛图的。竞赛图指的是给完全图每条边定向之后得到的有向图。 竞赛图必有哈密尔顿路径 竞赛图有哈密尔顿回路 $\Leftrightarrow$ 竞赛图强联通 证明： 先证明（1）。这个证明使用反证法。假如不存在哈密尔顿路径，那么我们一定能够找到这个图的最长路径，记为 $a\to b \to c \cdots \to e$。考虑不在最长路径的 $p$ 点，根据最长的性质，一定不能有 $p\to a, e \to p$ 的边。那么图就如下所示了。可是考虑红色笔画出的边该如何定向呢？无论红边如何定向，一定会存在 $a\to e$ 路径上的一点 $c$ ，使得有这么一条路径 $a\to c\to p\to c’ \to e$ ，从而与最长路的性质相矛盾。如下图所示。 有关的博文： 竞赛图的兰道定理 BZOJ 4727: POI2017 竞赛图相关 哈密顿回路相关总结 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int n, m, swp;vector&lt;pii&gt; ans;#define add(x, y) ans.emplace_back(x, y)void solve() &#123; swp = false; read(n, m); vector&lt;int&gt; nxt(n + 1); if(n &gt; m) swap(n, m), swp = true; if(n == 1) &#123; puts("IMPOSSIBLE"); return; &#125; else if(n == 2 &amp;&amp; m &lt;= 4) &#123; puts("IMPOSSIBLE"); return; &#125; else if(n == 3 &amp;&amp; m == 3) &#123; puts("IMPOSSIBLE"); return; &#125; if(n == 4) &#123; if(m == 4) &#123; add(1, 1); add(2, 3); add(3, 1); add(4, 3); add(1, 2); add(2, 4); add(3, 2); add(4, 4); add(1, 3); add(2, 1); add(3, 3); add(4, 1); add(2, 2); add(1, 4); add(4, 2); add(3, 4); &#125; else &#123; nxt[1] = nxt[3] = 3; nxt[2] = nxt[4] = 1; for(int i = 1; i &lt;= m - 2; ++i) &#123; add(1, nxt[1]++); add(4, nxt[4]++); add(3, nxt[3]++); add(2, nxt[2]++); &#125; add(4, m - 1); add(3, 1); add(2, m); add(1, 1); add(3, 2); add(4, m); add(2, m - 1); add(1, 2); &#125; &#125; else if(n &amp; 1) &#123; for(int i = 1; i &lt;= n; ++i) nxt[i] = (i&amp;1) ? 1 : 3; for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; add(j, nxt[j]); if(++nxt[j] == m + 1) nxt[j] = 1; &#125; &#125; &#125; else if(n % 2 == 0) &#123; for(int i = 1; i &lt;= n; ++i) nxt[i] = (i &amp; 1) ? 3 : 1; for(int i = 1; i &lt;= m - 2; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; add(j, nxt[j]++); &#125; &#125; add(n - 1, 1); add(n, m - 1); add(n - 1, 2); add(n, m); for(int r = n - 2; r &gt; 0; r -= 2) &#123; add(r, m - 1); add(r - 1, 1); add(r, m); add(r - 1, 2); &#125; &#125; puts("POSSIBLE"); for(auto g : ans) &#123; if(swp) printf("%d %d\n", g.second, g.first); else printf("%d %d\n", g.first, g.second); &#125; ans.clear();&#125;int main() &#123; int T; read(T); for(int kase = 1; kase &lt;= T; ++kase) &#123; printf("Case #%d: ", kase); solve(); &#125; return 0;&#125; Prob B. 中国剩余定理Solution显然，1到18中两两互质的数有 $16, 9, 5, 7, 11, 13, 17$，每次询问相同的18个数 $x$ 即可得到答案关于 $x$ 的余数。我们把前面的7个数都问一遍，然后用中国剩余定理合并即可得到解，并且解是唯一的。 这题可真的是一个一眼题，而且甚至连中国剩余定理都不需要，直接暴力合并都可以的，因为答案小于 $10^6$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int pr[] = &#123;16, 9, 5, 7, 11, 13, 17&#125;, rem[7];ll ans = 0, M = 1;void exgcd(ll a, ll b, ll&amp; d, ll&amp; x, ll&amp; y) &#123; if(b == 0) d = a, x = 1, y = 0; else exgcd(b, a % b, d, y, x), y -= x * (a / b);&#125;ll mo(ll x, ll mod) &#123; if(x &lt; 0) x = -x, x %= mod, x = mod - x; else x %= mod; return x;&#125;void china(ll r, ll m) &#123; ll c, t, d, k = r - ans, p; exgcd(m, M, d, c, t), p = m / d; if(k &lt; 0) c = -c, t = -t, k = -k; assert(k % d == 0); // else there will be no solution t = mo(t * (k / d), p); ans += t * M; M *= p; ans %= M;&#125;bool solve() &#123; ans = 0, M = 1; for(int i = 0; i &lt; 7; ++i) &#123; rep(j, 1) printf("%d%c", pr[i], " \n"[j == 18]); fflush(stdout); int x; rep(j, 1) scanf("%d", &amp;x), rem[i] += x; rem[i] %= pr[i]; china(rem[i], pr[i]); &#125; printf("%lld\n", ans); fflush(stdout); int verdict; cin &gt;&gt; verdict; return verdict == 1;&#125;int main() &#123; int T, n, m; read(T, n, m); for(int kase = 1; kase &lt;= T; ++kase) &#123; if(!solve()) return 0; &#125; return 0;&#125; Prob C. trie 树dpSolution把每个字符串翻转，加到 trie 树中，trie 树节点的 dp 值维护子树中尚未被使用的字符串个数。在末尾位置将 dp 值加 1。题中配对在 trie 上相当于选中一个节点，挑出其子树内 2 个未被使用的字符串。每个节点只能被选一次。这个操作是可以贪心的，直接 dfs 一遍 trie 树，顺便把能够选的节点都选上即可。状态转移方程：$$dp(v) = \sum_{s \in sons_v} dp(s)\\dp(v) = dp(v) - 2 \text{ if } dp(v) \geq 2$$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 100020;struct node &#123; int go[26], dp; node() &#123; memset(go, 0, sizeof go); dp = 0; &#125;&#125; trie[maxn];int tot, ans, n, rt = 1;string word[1020];void insert(const string&amp; s) &#123; int p = rt; for(auto g : s) &#123; int ch = g - 'A'; if(!trie[p].go[ch]) &#123; trie[p].go[ch] = ++tot; trie[tot] = node(); &#125; p = trie[p].go[ch]; &#125; trie[p].dp = 1;&#125;void dfs(int v) &#123; for(int i = 0; i &lt; 26; ++i) if(trie[v].go[i]) &#123; dfs(trie[v].go[i]); trie[v].dp += trie[ trie[v].go[i] ].dp; &#125; if(v != rt &amp;&amp; trie[v].dp &gt;= 2) trie[v].dp -= 2, ans += 2; // printf("dfs at node %d: dp = %d\n", v, trie[v].dp);&#125;void solve() &#123; tot = 1; trie[rt] = node(); ans = 0; cin &gt;&gt; n; rep(i, n) &#123; cin &gt;&gt; word[i]; reverse(word[i].begin(), word[i].end()); insert(word[i]); &#125; dfs(rt); printf("%d\n", ans);&#125;int main() &#123; int T; read(T); for(int kase = 1; kase &lt;= T; ++kase) &#123; printf("Case #%d: ", kase); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>哈密尔顿路径</tag>
        <tag>trie</tag>
        <tag>Google Code Jam</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 2 比赛报告]]></title>
    <url>%2F2019%2F04%2F06%2FCodeforces-Global-Round-2-%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Overview Status A B C D E F G H Contest 00:07 00:17 00:26 00:45 01:02 —— —— —— Upsolve OK OK OK OK OK AC AC Attempt + + + + + * *1 AC count 3866 3372 2631 1589 1054 4 7 5 Tag 贪心 入门 思维 DP 贪心 ? 构造 FWT Coding Easy- Easy- Easy Easy+ Easy ? Easy Mid Thinking Easy- Easy- Easy Easy Easy+ ? Hard Hard Stars ★★★ ★★ Rank 260 / 3138 Rating 2139 Master (+59) 总算上橙了哈哈 不过论做题体验来说，这一场的体验真的不怎么好。。。五个签到题，然后三个剩下的题只有个位数人通过。。。一看到 tourist 花了一个小时才AC掉F题，我瞬间就放弃治疗了。整场比赛就是靠着手速上的橙。 G 题是一道非常好的构造题。 H 题是个挺神仙的 cyy 小号 rank 264，再随便打一场也要橙了 [UPD 2019.05.02] 补掉了 H 题，是一道精妙的 FWT 题。 [TODO] Solve Problem F. TutorialsCheck-in签到题基本上都是一眼题，下面是一句话题解： Prob A.最远的那两个数中一定有一个在数组的最左侧，或者最右侧。贪心即可。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 5030000;int n, a[maxn], l[maxn], r[maxn];int main() &#123; int ans = 0; scanf("%d", &amp;n); rep(i, n) scanf("%d", &amp;a[i]); int p = n; while(a[p] == a[1]) p--; ans = max(ans, p - 1); p = 1; while(a[p] == a[n]) p++; ans = max(ans, n - p); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Prob B.二分答案即可。复杂度 $O(n\log^2 n)$ 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 202000;int n, h, a[maxn], b[maxn];bool judge(int x) &#123; rep(i, x) b[i] = a[i]; sort(b + 1, b + x + 1); ll tot = 0; for(int i = x; i &gt; 0; i -= 2) tot += b[i]; return tot &lt;= h;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;h); rep(i, n) scanf("%d", &amp;a[i]); int l = 1, r = n; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(l == r - 1) mid = r; // printf("BS at l = %d, r = %d, mid = %d\n", l, r, mid); if(judge(mid)) l = mid; else r = mid - 1; &#125; printf("%d\n", l); return 0;&#125; Prob C.首先将两个矩阵 $A,B$ 异或起来得到 $A\oplus B$，我们只需要判断能否从 $0$ 矩阵变换到 $A\oplus B$ 即可。那么什么样的矩阵满足条件呢？当且仅当 $A\oplus B$ 的每行、每列均只有偶数个 1。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 555;int a[maxn][maxn], b[maxn][maxn], n, m;int main() &#123; scanf("%d%d", &amp;n, &amp;m); rep(i, n) rep(j, m) scanf("%d", &amp;a[i][j]); rep(i, n) rep(j, m) scanf("%d", &amp;b[i][j]), a[i][j] ^= b[i][j]; rep(i, n) &#123; int x = 0; rep(j, m) x ^= a[i][j]; if(x == 1) &#123; puts("No"); return 0; &#125; &#125; rep(j, m) &#123; int y = 0; rep(i, n) y ^= a[i][j]; if(y == 1) &#123; puts("No"); return 0; &#125; &#125; puts("Yes"); return 0;&#125; Prob D.又是典型的分段线性函数问题。。。总共有两类事件：询问，以及斜率减小1 。按照时间给这些事件排序，然后按着时间线进行模拟即可。复杂度 $O((n+q)\log (n+q))$。当然了，这种做法是离线的，如果预处理斜率变化点，然后放进 set 里即可在线回答询问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;#define int llconst int maxn = 200020;int n, q;ll a[maxn], ans[maxn];struct event &#123; char tp; ll t; int id; event(char ch, ll tim, int d=0): tp(ch), t(tim), id(d) &#123; &#125; bool operator &lt; (const event &amp;e) const &#123; return t &lt; e.t; &#125;&#125;;multiset&lt;event&gt; line;signed main() &#123; read(n); rep(i, n) read(a[i]); sort(a + 1, a + n + 1); for(int i = 2; i &lt;= n; ++i) line.emplace('S', a[i] - a[i - 1]); read(q); rep(i, q) &#123; int l, r; read(l, r); line.emplace('Q', r - l + 1, i); &#125; ll cur = 0, sp = n, tim = 0; for(auto g : line) &#123; if(tim &lt; g.t) cur += sp * (g.t - tim), tim = g.t; if(g.tp == 'Q') ans[g.id] = cur; else if(g.tp == 'S') sp--; &#125; rep(i, q) printf("%lld%c", ans[i], " \n"[i==q]); return 0;&#125; Prob E. 贪心题意：给你边长为 $2^i$ 的边 $a_i$ 条（$0\leq i \leq n$），问最多可以摆出来多少个三角形。每条边最多只能用一次。 题解： 显然，能组成三角形的无序三元组必然长这样： $(2^i,2^j,2^j) \text{ where } i \leq j$ 考虑这样的贪心策略，在考虑长度为 $2^i$ 的边时（简称长边），记录有多少条边长小于 $2^i$ 的边（简称短边）还没有用，然后尽量多地形成 (短, 长, 长) 这样的三角形，再之后尽量形成 (长, 长, 长) 这样的三角形，剩下没用完的长边数量加到短边数量里即可。对所有 $i$ 重复这个过程即可完成此题。其实写起来就几行，详细步骤见代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 303000;ll a[maxn], n, tot = 0;int main() &#123; read(n); rep(i, n) read(a[i]); ll left = 0; for(int i = 1; i &lt;= n; ++i) &#123; int cons = min(left, a[i] / 2); tot += cons; a[i] -= cons * 2; left -= cons; tot += a[i] / 3; a[i] %= 3; left += a[i]; &#125; printf("%lld\n", tot); return 0;&#125; Prob G. 构造好题Description你有 $n$ 个攻击力为 $1$ 的士兵，你需要把他们分成 $m$ 个兵团，来攻击 $m$ 个敌人，其中第 $i$ 个敌人的血量为 $hp_i$ 。你的攻击是分轮进行的，每一轮中，你都需要给你的每个兵团确定一个敌人作为目标，不妨设这一兵团共有 $x$ 人，那么作为目标的敌人的血量就会降低 $x$ 点。一个敌人死亡当且仅当他的血量小于等于0，那么问你至少需要多少轮，才能把所有敌人都杀死，并输出攻击方案。 Solution每一轮攻击一共对敌人造成 $n$ 点伤害，一个很显然的轮数下界就是：$$ans \geq \left\lceil \frac{ \sum_{i=1}^m hp_i}{n} \right\rceil$$事实上，这个下界也能达到，下面叙述构造方法，感觉真的是脑洞大开。首先，这道题目的限制非常宽松，我们采用的策略有很大的余地，但是过于自由也给我们带来了无从下手的这种困境。我们首先来想一种易于实现的策略，使得问题的限制加强一些，然后来分析其可行性。我们想要有一种分配兵团的方案，使得下面的策略是最优的： 我们按照顺序杀敌，即先击杀1号敌人，再击杀2号敌人…… 我们试图按照走马灯的方法对敌人进行攻击，即按照顺序考虑我们的兵团，若某个敌人没有死，则兵团攻击这个敌人；若这个敌人死了，那么兵团攻击下一个敌人。 这两个策略可以描述为下面的代码： 1234567for(int i = 0, p = 0; i &lt; m; ++i) &#123; while(hp[i] &gt; 0) &#123; hp[i] -= sz[p % m]; ans.push_back(i); p++; &#125;&#125; 这种策略很好实现，可是它什么时候是最优的呢？当且仅当杀死 $1,2,\cdots,m-1$ 这些敌人时，刚好将他们的血量降为0 。设我们兵团的分配方案是第 $i$ 个兵团 $a_i$ 人，记$$pre_k = \sum_{i=1}^k a_i$$那么，上面的条件就等价于：（ $k \in [1,m-1],p\in [1,m]$ ）$$\forall k \text{ } \exists p \text{ 使得} \sum_{i=1}^k hp_i \equiv pre_p \pmod n$$这个东西怎么构造？这个东西其实就是随便构造呢。我们要使 $pre$ 数组出现所有 $hp$ 模 $n$ 的前缀和，一个显然的思路就是把 $\sum\limits_{i=1}^k hp_i \pmod n$ 全部求出来，然后排个序，得到 $sum$ 数组，然后就令 $pre_i = sum_i$ 即可 满足上面的条件。再差分一下就可以得到 $a$ 数组了，至此，我们就构造完毕了，模拟一下上面的走马灯即可得到方案。 Comment其实这道题除了下界比较好想之外，剩下的步骤都不好想，但是一旦看完题解，我就觉得原来这么简单。好的构造题正是这样啊！场上A出这道题的人真是神仙。 Code稍微加了点IO优化，结果居然现在成了 Execution time 榜的榜首2333 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 1020000;int n, m, hp[maxn], tot;int main() &#123; vector&lt;int&gt; sums, sz, ans; read(n, m); for(int i = 0; i &lt; m; ++i) &#123; read(hp[i]); tot += hp[i]; if(i != m - 1) sums.push_back(tot % n); &#125; sums.push_back(0); sums.push_back(n); sort(sums.begin(), sums.end()); for(int i = 0; i + 1 &lt; int(sums.size()); ++i) sz.push_back(sums[i + 1] - sums[i]); for(int i = 0, p = 0; i &lt; m; ++i) &#123; while(hp[i] &gt; 0) &#123; hp[i] -= sz[p % m]; ans.push_back(i); p++; &#125; &#125; while(ans.size() % m != 0) ans.push_back(0); printf("%d\n", int(ans.size()) / m); for(int i = 0; i &lt; m; ++i) &#123; write(sz[i]); putchar(i+1==m ? '\n' : ' '); &#125; for(int i = 0; i &lt; int(ans.size()); ++i) &#123; write(ans[i] + 1); putchar(i%m==m-1 ? '\n' : ' '); &#125; return 0;&#125; Prob H. 精妙的 FWT想要找到更多有关 FWT 的内容，可以参考我的这篇博客。 Description给定 $a,b,c$ ，以及 $n$ 个 $k$ 位 bitmask $A_i,B_i,C_i$ ，求下面 $n$ 个集合幂级数的异或 FWT，即：$$\prod_{1\leq i\leq n} (ax^{A_i}+bx^{B_i}+cx^{C_i})$$数据范围：$n\leq 10^5,k\leq 17,0\leq A_i,B_i,C_i &lt; 2^k,$ Solution按照正常的 FWT 思路，就是把这 $n$ 个集合幂级数分别求出 FWT，然后再点乘起来，然后再做 IFWT。复杂度是 $O(nk2^k)$ 的，无法通过此题。 但是这道题需要注意的一点是每一个集合幂级数都只有三项，并且 $a,b,c$ 是固定的。回顾 FWT 的公式：$$\hat{f}(S) = \sum_{T\subseteq 2^U} f(T) (-1)^{|S\cap T|}$$因此每个集合幂级数 FWT 之后也仅仅会有 $\pm a \pm b \pm c$ 这么 8 种项。为了使问题更加简单，我们进行这样的变换： $B_i:=B_i \oplus A_i,C_i := C_i \oplus A_i, A_i := 0$ 。变换之后我们得出的结果的第 $S$ 项就等价于答案的第 $S\oplus xorsum$ 项，其中 $xorsum = \oplus_{i=1}^n A_i$。可以发现，这样做之后只剩下 $a\pm b \pm c$ 这四项了。 我们的一个重要观察是，将 FWT 之后的这 $n$ 个集合幂级数乘起来的结果中，对于一个固定的位置 $S$ ，这一项的系数一定是 $(a+b+c)^x (a+b-c)^y (a-b+c)^z (a-b-c)^w$ 的形式。如果我们能够把 $x,y,z,w$ 解出来，整个问题就解决了。首先，我们有一个最朴素的关系式：$$x+y+z+w = n$$之后有两种说法，一种是官方题解所说的考虑所有 $n$ 个 FWT 之后的幂级数的第 $S$ 项之和，然后再多考虑一个条件即可得到四个方程；另一种则非常简洁、对称、优美，可是我对这种方法还没有简洁优美的证明。这种方法是这样的： 将 $A_i\oplus B_i$ 的值统计入一个数组 $f$，对 $f$ FWT之后，对于其第 $S$ 项有：$x+y-z-w=f[S]$。 将 $A_i\oplus C_i$ 的值统计入一个数组 $g$，对 $g$ FWT之后，对于其第 $S$ 项有：$x-y+z-w=g[S]$。 将 $B_i\oplus C_i$ 的值统计入一个数组 $h$，对 $h$ FWT之后，对于其第 $S$ 项有：$x-y-z+w=h[S]$。 然后消元法即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Generated by powerful Codeforces Tool * Author: YangDavid * Time: 2019-05-02 16:57:53*/#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 102000, MS = (1 &lt;&lt; 17) + 2, MOD = 998244353;int A[maxn], B[maxn], C[maxn], n, k, full;int AB[MS], AC[MS], BC[MS], ans[MS], out[MS];int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;const int inv2 = qpow(2, MOD - 2), inv4 = qpow(4, MOD - 2);void fwt(int* arr, int dwt = 1) &#123; int l, r; for(int i = 0; i &lt; k; ++i) for(int S = 0; S &lt; full; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = arr[S], r = arr[S|(1&lt;&lt;i)]; arr[S] = mo(l + r); arr[S|(1&lt;&lt;i)] = mo(l - r); &#125; int iv = qpow(full, MOD - 2); if(dwt == -1) for(int S = 0; S &lt; full; ++S) arr[S] = muln(arr[S], iv);&#125;int gg[4], a, b, c, xorsum;int gett(ll s, ll t, ll u, ll v) &#123; int x = muln(mo(mo(s+t)+mo(u+v)), inv4); int y = mo(muln(mo(s+t), inv2) - x); int z = mo(muln(mo(s+u), inv2) - x); int w = mo(muln(mo(s+v), inv2) - x); return muln( muln(qpow(gg[0],x),qpow(gg[1],y)) , muln(qpow(gg[2],z),qpow(gg[3],w)) );&#125;int main() &#123; scanf("%d%d%d%d%d", &amp;n, &amp;k, &amp;a, &amp;b, &amp;c); full = (1 &lt;&lt; k); gg[0] = mo(mo(a+b)+c), gg[1] = mo(mo(a+b)-c), gg[2] = mo(mo(a-b)+c), gg[3] = mo(mo(a-b)-c); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;A[i], &amp;B[i], &amp;C[i]); AB[A[i]^B[i]]++, AC[A[i]^C[i]]++, BC[B[i]^C[i]]++; xorsum ^= A[i]; &#125; fwt(AB), fwt(AC), fwt(BC); for(int S = 0; S &lt; full; ++S) &#123; ans[S] = gett(n, AB[S], AC[S], BC[S]); &#125; fwt(ans, -1); for(int S = 0; S &lt; full; ++S) out[S] = ans[S ^ xorsum]; for(int S = 0; S &lt; full; ++S) printf("%d%c", out[S], " \n"[S==full-1]); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
        <tag>构造</tag>
        <tag>快速沃尔什变换（FWT）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Comet OJ Contest #0 比赛报告]]></title>
    <url>%2F2019%2F03%2F31%2FComet-OJ-Contest-0-%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Overview Status A B C D E F Contest 00:27 02:21 —— —— —— —— Upsolve OK OK AC AC Attempt +5 +1 * * AC count 312 60 34 9 6 6 Tag 贪心 概率 图论 DP ? 数学 Coding 948 2739 2733 ? ? 3040 Thinking Easy Easy+ Mid ? ? Hard Stars ★ ★ ★★ ★★★ 这是当时参加Wannafly冬令营时使用的 Comet OJ 第一次举办的比赛，出题人是tangjz，感觉题目质量还挺不错，可以看到出题人、主办方都是挺用心的呢。 采用的是3小时的ACM赛制，然而罚时还是按照20min算的，A题有点不细心了，结果罚时就上了天 QAQ 比赛时写出了前两道题，Rank 52 out of 507，感觉海星。cyy也打了，Rank 45。 B题开始一直担心常数问题，害怕会T，但是这次比赛充分体现出了DP常数之小 比赛链接 [UPD1: 2019-04-13] 补掉了F题，更新了F题代码。 [TODO1] Solve Problem D[TODO2] Solve Problem E TutorialProb A. 数学，分类讨论Description题意是求下面关于 $(x,y,z)$ 的方程的解的数目，以及对于所有解，求 $\sum\limits_{(x,y,z)}xyz$，参数 $n$ 已给定，无穷则输出 infty：$$\sqrt{x-\sqrt{n}} + \sqrt{y} - \sqrt{z} = 0$$ Solution 当 $n$ 是完全平方数时，答案为 infty 否则，稍作变换即得到： $x-\sqrt{n} = z+y-\sqrt{4yz} \text{ }(y&lt;z)$ 如果 $4\nmid n$，则无解； 否则，枚举 $n/4$ 的每个因子 $d$（要求 $d\times d&lt;n/4$），则 $(d+\frac nd, d, \frac nd)$ 就是一组解，累加答案即可。 需要注意的一点是，这道题卡常数，不能用 long long，必须用 unsigned int 。 复杂度 $O(T\sqrt{n})$ Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int MOD = 1000000007;unsigned n, tot, mul = 0;void solve() &#123; tot = mul = 0; scanf("%u", &amp;n); if(n == 0) &#123; puts("infty"); return; &#125; for(ll v = sqrt(n - 1); v * v &lt;= n; ++v) if(v * v == n) &#123; puts("infty"); return; &#125; if(n % 4 != 0) &#123; puts("0 0"); return; &#125; n /= 4; for(unsigned y = 1; y * y &lt;= n; ++y) if(n % y == 0) &#123; unsigned z = n / y, x = y + z; if(x &lt; 44722 &amp;&amp; x * x &lt; n) continue; tot++; mul = mul + (1LL * x * n % MOD); mul %= MOD; &#125; printf("%u %u\n", tot, mul);&#125;signed main() &#123; unsigned T; scanf("%u", &amp;T); while(T--) solve(); return 0;&#125; Prob B. 概率，DP这道题的DP转移是很显然的，但是细节略多。具体细节见代码吧。 复杂度 $O(\sum n^2m + nk)$ Bonus1：据说有 $O(nm\log n+n\log k) $ 的做法？不太会。 Bonus2：据说可以不用 $\sum n \leq1000, \sum m\leq 1000$ 的条件，cyy提了一个维护关于 $p, q$ 多项式的做法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 505, MOD = 1000000007;const int BUFF_SIZE = 1 &lt;&lt; 20;char BUFF[BUFF_SIZE],*BB,*BE;#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;inline int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;inline int inv(int x) &#123; return qpow(x, MOD - 2);&#125;inline int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;const int inv100 = inv(100);int dp[2][maxn][maxn], n, m, k, p, q, r;void solve() &#123; memset(dp, 0, sizeof dp); dp[1][1][0] = 1; read(n, m, k, p, q); p = muln(p, inv100); q = muln(q, inv100); r = mo(1 + MOD-q + MOD-p); for(int t = 2; t &lt;= m; ++t) &#123; auto c = dp[t &amp; 1], o = dp[(t-1) &amp; 1]; c[1][0] = muln(o[1][0], r); int lim = min(t, n); if(t &lt;= n) &#123; c[lim][0] = muln(o[lim-1][0], p); c[lim][lim-1] = muln(o[lim-1][lim-2], q); &#125; else &#123; c[lim][0] = mo(o[lim][0] + muln(o[lim-1][0], p)); c[lim][lim-1] = mo(o[lim][lim-1] + muln(o[lim-1][lim-2], q)); &#125; for(int l = 2; l &lt; lim; ++l) &#123; c[l][0] = mo(mo(muln(r, o[l][0]) + muln(p, o[l-1][0]))) + muln(p, o[l][1]); c[l][l-1] = mo(mo(muln(r, o[l][l-1]) + muln(q, o[l-1][l-2])) + muln(q, o[l][l-2])); for(int v = 1; v &lt; l-1; ++v) &#123; c[l][v] = mo(mo(muln(r, o[l][v]) + muln(p, o[l][v+1])) + muln(q, o[l][v-1])); &#125; &#125; &#125; int ans = 0, (*c)[505] = dp[m &amp; 1]; for(int i = 1; i &lt;= n; ++i) &#123; int f = 0; for(int j = 0; j &lt; i; ++j) f = mo(f + c[i][j]); ans = mo(ans + muln(qpow(i, k), f)); &#125; ans = muln(ans, qpow(100, m - 1)); write(ans), putchar('\n');&#125;int main() &#123; int T; read(T); while(T--) solve(); return 0;&#125; Prob C. 图论，并查集，BCCSolution题意可以转化为下面的等价形式： 在一个逐步加边的图中，问每一次加边之后，图中各个边双联通分量有多少对点两两可达。 显然需要这么搞： 用并查集维护连通性，如果加的边不在连通块里，则合并联通块，这很容易。 对于每个连通块，维护边双联通分量。这不可避免地需要解决合并两个边双联通分量的问题。 到这一步就是这道题的难点了。究竟怎么合并边双呢？ 一种想法，cyy提出这就是LCT进行动态缩点的裸题。可惜我不会LCT啊QAQ 实际上，标准做法十分清新自然。我们只需要把边以时间为权值求一下最小生成森林，然后再并查集暴力合并边双就好了。因为有了最小生成森林，树的形态就不会发生变化，直接暴力就可以了。 实现上需要注意这几个问题： 如何用并查集暴力合并边双？可以注意到，边双在图中也是组成一棵树的。而任何一条非树边在边双树上都对应一条链，直接使用暴力求LCA的方法往上跳，边跳边缩就可以了，如边双图中的 v 跳到父节点 pa[v] 时，将 v 的信息合并到 pa[v] 上即可。 有关按秩合并。合并边双时，如果每次都是 v 合并到 pa[v] 上，复杂度可能会退化（因为数据毒瘤）。按秩合并在这道题其实不是特别自然，实现起来需要小心。（我没有按秩合并，加了个读入优化，1966ms/4000ms通过的） 如果仔细实现，这道题的时间复杂度是 $O(n\alpha(n)+m)$ Code(106 lines, 2733 byte) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int BUFF_SIZE = 1 &lt;&lt; 20;char BUFF[BUFF_SIZE],*BB,*BE;#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 2002000;vector&lt;int&gt; mst[maxn];vector&lt;pii&gt; e;int n, m, _x, _y, intree[maxn], fa[maxn], dep[maxn];ll ans, tot;struct dsu &#123; int pa[maxn], sz[maxn]; void init(int N) &#123; for(int i = 1; i &lt;= N; ++i) &#123; pa[i] = i; sz[i] = 1; &#125; &#125; int find(int x) &#123; if(x == pa[x]) return x; return pa[x] = find(pa[x]); &#125; bool merge(int son, int fat) &#123; son = find(son), fat = find(fat); if(son == fat) return false; ans -= 1LL * sz[son] * (sz[son] - 1) / 2; ans -= 1LL * sz[fat] * (sz[fat] - 1) / 2; sz[fat] += sz[son]; sz[son] = 0; pa[son] = fat; ans += 1LL * sz[fat] * (sz[fat] - 1) / 2; return true; &#125;&#125; s;void dfs(int v, int depth, int fath) &#123; fa[v] = fath, dep[v] = depth; for(auto g : mst[v]) if(g != fath) dfs(g, depth + 1, v);&#125;void jump(int x, int y) &#123; x = s.find(x), y = s.find(y); while(x != y) &#123; if(dep[x] &lt; dep[y]) swap(x, y); int to = s.find(fa[x]); assert(s.merge(x, to)); x = to; &#125;&#125;void solve() &#123; read(n, m); s.init(n); e.clear(); e.emplace_back(0, 0); rep(i, n) mst[i].clear(); rep(i, m) &#123; read(_x, _y); e.emplace_back(_x, _y); if(s.merge(_x, _y)) &#123; intree[i] = true; mst[_x].push_back(_y); mst[_y].push_back(_x); &#125; else intree[i] = false; &#125; memset(fa, 0, sizeof(int) * (n + 20)); rep(i, n) if(!fa[i]) dfs(i, 1, -1); s.init(n); ans = tot = 0; rep(i, m) &#123; if(!intree[i]) &#123; int x = e[i].first, y = e[i].second; jump(x, y); &#125; tot ^= ans * i; &#125; printf("%lld\n", tot);&#125;int main() &#123; int T; read(T); while(T--) solve(); return 0;&#125; Prob F. 数学，几何，状压dpDescription小象同学有 $n$ 根木棍。他想用其中的一些木棍摆成一些多边形的形状，使得这些多边形面积的乘积尽量大，你可以帮帮他吗？ 这里要求每根木棍至多在一个多边形中被使用，这也意味着有些木棍可能不被使用。此外，在每个多边形中，不能存在两根木棍位于同一条直线上，换句话说，多边形的每条边应该对应恰好一根木棍。 注意，摆出的每个多边形应该由不严格相交的边组成，且多边形面积应该严格大于 $0$。若不能摆出任何一个多边形，则视多边形面积的乘积为 $0$。 $$n\leq 12$$ Solution首先很容易看出，如果我们能够解决给出 $n$ 条边，求出这 $n$ 条边能围出多边形的最大面积，那么我们就预处理出所有边的子集，然后再枚举子集的子集状压 dp 即可完成此题。而这个问题怎么做呢？我们介绍两个结论： 首先是 $n$ 边形存在的条件，这个还算比较显然：$$\sum_{i=1}^n a_i &gt; 2 \times \max_{1\leq i\leq n}a_i$$而要使这个 $n$ 边形面积最大，我们有下面的结论： 面积最大的多边形是凸多边形，且是圆内接多边形，且这个圆的半径是唯一确定的。 证明： 这个结论可以用调整法得到，不妨尝试画一个半径为 $\frac 12 \max\{a_1,a_2,\cdots,a_m\}$ 的圆，将多边形的边依次对应到圆周上。那么：若多边形覆盖的周长总和超过一个圆周，则意味着半径不够大，通过增大半径可以得到圆心在多边形内的圆满足条件；若周长总和没有达到一个圆周，分两种情况考虑：那么也意味着半径不够大，但通过增大半径得到的圆对应的圆心会在多边形外部。 在这种构造多边形的方法里，多边形的面积等于圆的面积减去 $m$ 个弓型区域的面积。不妨留下这些弓型区域并尝试改变多边形的形状，通过这样的调整可以枚举到这个边长集合对应的所有可能的凸多边形形状。与此同时，圆被改变为周长固定的闭合图形，而在二维空间里，周长固定的闭合图形中面积最大的就是圆，因此多边形面积最大时一定能够画出这样的圆，使得多边形的点都在圆周上。那么剩下的工作便是二分确定唯一的半径 $R$，然后算出相应的多边形面积。 注意：这个证明抄自tls题解，但是部分内容是有问题的！！！正确的调整方式请见代码！明天会更新正确证明 其实这个多边形的边的顺序也是可以随意调换的。根据上面的证明方法，这个圆形的半径同样也是唯一确定的，使用二分搜索模拟上面的调整过程即可实现。 时间复杂度 $O(2^n \log \epsilon \cdot n + 3^n)$ Comment这道题是很妙的一道题！感觉这个结论很具有普遍意义！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxs = (1 &lt;&lt; 12) + 10;const long double eps = 1e-9;const long double PI = 3.1415926535897932384626L;int n, a[20], full, fa[maxs];bool valid[maxs];long double dp[maxs], area[maxs];vector&lt;int&gt; way[maxs];long double calc(int state) &#123; vector&lt;int&gt; e; int tot = 0, sz = e.size(); for(int i = 0; i &lt; n; ++i) if(state &gt;&gt; i &amp; 1) &#123; e.push_back(a[i]); tot += a[i]; &#125; sz = e.size(); if(tot &lt;= e.back() * 2) &#123; valid[state] = false; return 0.0L; &#125; valid[state] = true; bool half = false; auto TooLarge = [&amp;](long double R) -&gt; bool &#123; long double theta = 0.0L, f = R*R*2.0L; for(int i = 0; i &lt; sz - 1; ++i) theta += acos((f - 1.0L*e[i]*e[i]) / f); long double last = acos((f - 1.0L*e[sz-1]*e[sz-1]) / f); if(theta &lt;= PI) &#123; half = true; return theta - last &gt; 0.0L; &#125; else &#123; half = false; return theta + last &lt; 2.0L * PI; &#125; &#125;; long double l = (long double)e.back() / 2.0L, r = 10000; rep(i, 100) &#123; long double mid = (l + r) / 2.0L; if(TooLarge(mid)) r = mid; else l = mid; &#125; TooLarge(r); long double sq = 0.0L; for(int i = 0; i &lt; sz; ++i) &#123; long double p = (r + r + e[i]) / 2.0L; long double triangle = sqrtl(p * (p-e[i])) * (p-r); if(i == sz - 1 &amp;&amp; half) sq -= triangle; else sq += triangle; &#125; return sq;&#125;void solve() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); sort(a, a + n); full = (1 &lt;&lt; n) - 1; for(int S = 1; S &lt;= full; ++S) area[S] = calc(S); long double bestdp = 0.0; int choice = 0; for(int S = 1; S &lt;= full; ++S) &#123; dp[S] = area[S], fa[S] = 0; for(int T = (S - 1) &amp; S; T; T = (T - 1) &amp; S) if(valid[T]) &#123; if(dp[S] + eps &lt; dp[T] * dp[T ^ S]) &#123; dp[S] = area[T] * dp[T ^ S]; fa[S] = S ^ T; &#125; &#125; if(dp[S] &gt; bestdp + eps) &#123; bestdp = dp[S]; choice = S; &#125; &#125; printf("%.12Lf\n", bestdp); int S = choice, tmp = choice, cnt = 0; while(tmp) tmp = fa[tmp], cnt++; printf("%d\n", cnt); while(S) &#123; int cho = S ^ fa[S]; vector&lt;int&gt; polygon; for(int i = 0; i &lt; n; ++i) if(cho &gt;&gt; i &amp; 1) polygon.push_back(a[i]); printf("%d", int(polygon.size())); for(auto g : polygon) printf(" %d", g); putchar('\n'); S = fa[S]; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125; 官方题解题解下载链接]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率与期望</tag>
        <tag>Comet OJ</tag>
        <tag>边双联通分量</tag>
        <tag>数学结论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder ExaWizards 2019 比赛报告]]></title>
    <url>%2F2019%2F03%2F31%2FAtCoder-ExaWizards-2019-%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Overview Status A B C D E F Contest 00:01 00:03 (0) 01:15 —— —— Upsolve OK OK AC OK AC Attempt + + * + * AC count 3132 3081 469 227 134 14 Tag 入门 入门 思维 DP 概率 ? Coding Easy- Easy- Easy Mid Mid ? Thinking Easy- Easy- Mid Mid- Mid- ? Stars ★★ ★★ ★★ Rank 245 / 3138 Performance 2073，感觉海星 Rating 1442 (+254) Specialist 再次感受到 AtCoder 的凶残，AB就是入门题，然后两题和三题之间的难度鸿沟简直无敌 看来我是打不破AtCoder比赛过不了C题的魔咒了。。。D都AC了，C题还不会做 D题我的DP复杂度不是最优秀的，但是因为常数小，也通过了。 E题是挺简单的一道概率题，场上没看，有点可惜了。 [TODO: Solve Problem F] TutorialsProb C. 思维Solution一个核心的观察就是，无论怎么喊口令，人之间的相对顺序是不改变的。因此只需要维护最左边和最右边未出界的人的编号就可以了，换句话说，逆着时间序，并且反着处理口令，设最左边出界处有一个人，就是看这个人最远能到哪；最右边有个人，看他最左能到哪。然后减一下就好了。 时间复杂度 $O(n+q)$ Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 202000;int n, q, lb, rb;char s[maxn], t[maxn], d[maxn];int main() &#123; scanf("%d %d\n%s\n", &amp;n, &amp;q, s + 1); lb = 0, rb = n + 1; // (lb, rb) available rep(i, q) scanf("%c %c\n", &amp;t[i], &amp;d[i]); for(int i = q; i ; --i) &#123; if(s[lb+1]==t[i] &amp;&amp; d[i]=='L') lb++; if(s[rb-1]==t[i] &amp;&amp; d[i]=='R') rb--; if(s[lb]==t[i] &amp;&amp; d[i]=='R') lb--; if(s[rb]==t[i] &amp;&amp; d[i]=='L') rb++; &#125; printf("%d\n", rb - lb - 1); return 0;&#125; Prob D. dp，好题Description你有 $n$ 个大小不超过 $1\cdot 10^5$ 的模数，以及一个不超过 $1\cdot 10^5$ 的数 $x$ 。你现在考虑这 $n$ 个模数的所有 $n!$ 中排列 $p_1,p_2,\cdots,p_n$，求 $x\bmod p_1\bmod p_2\cdots\bmod p_n$ 的和。即： Observation核心观察是当 $x$ 模一个小数之后，模大数会变得没有效果。因此这启发我们把模数数组从大到小排序。令 $dp[p][v]$ 为考虑过 $a[1],a[2],\cdots,a[p]$ 这些模数之后， $x$ 变为 $v$ 的方案数。 Solution 1考虑直接暴力实现上述过程。 刷表法，直接朴素枚举每种状态下一步放在哪里。预处理阶乘之后，复杂度 $O(n^2m)$，不是特别好写。稍微加了一个优化，就是不考虑无需计算的状态，然后就过了。（458 ms） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int MOD = 1000000007;inline int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;inline int inv(int x) &#123; return qpow(x, MOD - 2); &#125;int n, s, a[202], dp[202][102000], fac[222] = &#123;1&#125;, ifac[222] = &#123;1&#125;;vector&lt;int&gt; valid[202];bitset&lt;102000&gt; vis[202];inline int P(int N, int M) &#123; return muln(fac[N], ifac[N-M]); &#125;int main() &#123; scanf("%d%d", &amp;n, &amp;s); for(int i = 1; i &lt;= 200; ++i) &#123; fac[i] = muln(fac[i - 1], i); ifac[i] = inv(fac[i]); &#125; rep(i, n) scanf("%d", &amp;a[i]); sort(a + 1, a + n + 1, greater&lt;int&gt;()); dp[0][s] = 1; valid[0].push_back(s); for(int i = 0; i &lt; n; ++i) &#123; for(auto j : valid[i]) &#123; for(int k = i + 1; k &lt;= n; ++k) &#123; dp[k][j % a[k]] += muln(dp[i][j], P(n-i-1, k-i-1)); dp[k][j % a[k]] %= MOD; if(!vis[k][j%a[k]]) &#123; vis[k][j%a[k]] = true; valid[k].push_back(j % a[k]); &#125; &#125; &#125; &#125; ll res = 0; for(int i = 1; i &lt;= s; ++i) res = (res + 1LL * i * dp[n][i] % MOD) % MOD; cout &lt;&lt; res &lt;&lt; '\n'; return 0;&#125; Prob E. 概率，数学12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define Type intconst Type MOD = 1000000007;namespace ModOp &#123; inline Type mo(Type x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125; struct MF &#123; Type v; MF(Type x = 0): v(mo(x)) &#123; &#125; operator Type() &#123; return v; &#125; MF operator + (const MF&amp; f) const &#123; return mo(v + f.v); &#125; MF operator - (const MF&amp; f) const &#123; return mo(v - f.v); &#125; MF operator * (const MF&amp; f) const &#123; return 1LL * v * f.v % MOD; &#125; MF operator / (const MF&amp; f) const &#123; return v / f.v; &#125; MF operator - () const &#123; return MOD - v; &#125; MF operator &gt;&gt; (int idx) const &#123; return v &gt;&gt; idx; &#125; MF operator &lt;&lt; (int idx) const &#123; return v &lt;&lt; idx; &#125; bool operator == (const MF&amp; f) const &#123; return v == f.v; &#125; bool operator != (const MF&amp; f) const &#123; return v != f.v; &#125; bool operator &gt; (const MF&amp; f) const &#123; return v &gt; f.v; &#125; bool operator &lt; (const MF&amp; f) const &#123; return v &lt; f.v; &#125; bool operator &gt;= (const MF&amp; f) const &#123; return v &gt;= f.v; &#125; bool operator &lt;= (const MF&amp; f) const &#123; return v &lt;= f.v; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; out, MF f) &#123; return out &lt;&lt; f.v; &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, MF f) &#123; return in &gt;&gt; f.v; &#125; bool scan() &#123; return scanf("%d", &amp;v) != -1; &#125; void print() &#123; printf("%d", v); &#125; &#125;;&#125;#undef Typetemplate&lt;typename T&gt; T qpow(T x, int y) &#123; T ret = T(1); for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) ret = ret * x; return ret;&#125;using ModOp::MF;const int maxn = 200200, N = 200000;MF fac[maxn], ifac[maxn], onlyb[maxn], onlyw[maxn];MF C(int x, int y) &#123; if(x &lt; y) return MF(0); return fac[x] * ifac[y] * ifac[x - y];&#125;int b, w;int main() &#123; fac[0] = ifac[0] = MF(1); for(int i = 1; i &lt;= N; ++i) &#123; fac[i] = fac[i - 1] * MF(i); ifac[i] = qpow(fac[i], MOD - 2); &#125; scanf("%d%d", &amp;b, &amp;w); for(int i = 1; i &lt;= b + w; ++i) &#123; onlyb[i] = onlyb[i - 1] + C(i-1, w-1) * qpow(MF(2), MOD-1-i); onlyw[i] = onlyw[i - 1] + C(i-1, b-1) * qpow(MF(2), MOD-1-i); &#125; for(int i = 0; i &lt; b + w; ++i) &#123; cout &lt;&lt; (MF(1) + onlyb[i] - onlyw[i]) * qpow(MF(2), MOD - 2) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Grand Contest 032 比赛总结]]></title>
    <url>%2F2019%2F03%2F26%2FAtCoder-Grand-Contest-032-%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[OverviewStatus Status A B C D E F Contest 00:13 00:57 (2) —— —— —— Upsolve OK OK AC AC AC AC Attempt + + *2 * * * AC count 1222 894 197 111 21 4 Tag 贪心 构造 图论 DP 二分 概率 Coding Easy Easy Mid- Easy Mid- Easy Thinking Easy Mid- Mid Mid+ Mid+ Hard Stars ★ ★ ★★ ★★ ★★★★ Rank 413 / 1645 Upsolved 6/6，题目已经全部补完。 Performance 1849，打炸了啊 Rating 1188 (+368), Pupil C题有挺多小情况的，没在场上写出来，挺可惜的。 D题是一步很有趣的模型转化 F题是概率期望的超级好题。 这次比赛AtCoder的官方题解是真的良心！我会在博文末尾附上官方题解的PDF的，可以对照阅读。 P.S. 以后题解Overview的表格里面会附带推荐程度、代码难度 [UPD 2019.4.21] 补掉了F题，题解将会单独写一篇博客。 cz_xuyixuan的题解 ccosi的题解 F题果壳网上的优质回答 Replay开场看了A题，马上想到了贪心的正确性，13分钟1A了。 之后看了B题，发现是比较擅长的构造，但是这么一个挺简单的题却让我懵逼了老半天，快到1小时的时候才A掉，花的时间有点多了。 C题开始看了没什么思路，顺便把D也看了，感觉就是一个DP，但是有C题挡着，又静不下心来想。仔细分析了一下，发现是可做的，讨论了几种情况，交上去却还是WA了。比赛本来就快要结束了，结果发现有一种讨论写挂了，可是要改也来不及了，于是就GG了。 TutorialProb. A 贪心Solution贪心策略是：我们寻找最右边的能被移走的球。如果找不到，则一定无解；否则，我们就把这个球移走。显然，如果我们不这么干，最右边的球将无法被移走。 时间复杂度：$O(n^3)$，稍加优化即可 $O(n^2)$ Code1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 13000;int n, _x;vector&lt;int&gt; a, ans;bool extend() &#123; int sz = a.size(); for(int i = sz - 1; i &gt;= 0; --i) &#123; if(a[i] == i + 1) &#123; for(int j = i; j &lt; sz - 1; ++j) swap(a[j], a[j + 1]); a.pop_back(); ans.push_back(i + 1); return true; &#125; &#125; return false;&#125;int main() &#123; scanf("%d", &amp;n); rep(i, n) scanf("%d", &amp;_x), a.push_back(_x); rep(i, n) if(!extend()) &#123; puts("-1"); return 0; &#125; reverse(ans.begin(), ans.end()); for(auto g : ans) printf("%d\n", g); return 0;&#125; Prob. B 构造Statement你需要构造这样一个 $n$ 个顶点，顶点标号分别是 $1,2,\cdots,n$ 的图，满足下面的条件： 这个图是连通图 对于每个顶点来说，它相邻所有顶点的标号加起来的值是相等的。 Thinking感觉还是我一直想通过构造小情况的方案，从而归纳出通用的构造方案。构造4条边的方案时，我构造出了蝴蝶形，发现它是一个正则图（即每个点度数都恰好相等），由此找到了归纳构造顶点数为 $4n$ 的方法。可是还有很多情况构造不出来呢！我就陷入了自闭状态。仔细看看这种归纳构造的图的性质吧，结果我发现，我构造的就是完全二分图。这么做的思想是把顶点分成两堆，这两堆点的权值之和相同。这个思想完全可以推广！我们可以把顶点分成内部点的权值之和相同的 $m$ 堆，然后每一个点都和与它不在同一堆的所有点都进行连线。这启发我们根据顶点数的奇偶性，进行如下的构造： 当n是奇数时，分成这么 $(n+1)/2$ 组：{1,n-1}, {2,n-2}, …, {(n-1)/2,(n+1)/2}, {n} 当n是偶数时，分成这么 $n/2$ 组：{1, n}, {2, n-1}, …, {n/2, n/2 + 1} 时间复杂度 $O(n)$ Code12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;int n, tot = 0;vector&lt;int&gt; gp[300];int main() &#123; scanf("%d", &amp;n); if(n &amp; 1) gp[++tot].push_back(n), n--; int hf = n / 2; for(int i = 1; i &lt;= hf; ++i) &#123; gp[++tot].push_back(i); gp[tot].push_back(n + 1 - i); &#125; vector&lt; pair&lt;int, int&gt; &gt; ans; for(int i = 1; i &lt;= tot; ++i) &#123; for(int j = i + 1; j &lt;= tot; ++j) &#123; for(auto u : gp[i]) for(auto v : gp[j]) ans.emplace_back(u, v); &#125; &#125; int sz = ans.size(); printf("%d\n", sz); for(auto g : ans) printf("%d %d\n", g.first, g.second); return 0;&#125; Prob. C 分类讨论，欧拉回路Statement你需要判断这件事情： 给定一个无向连通简单图，是否可以将它的边集划分为三个部分，使得每一部分都能组成图中的一条欧拉回路？（这里的组成欧拉回路是指顶点可以重复经过，但是边只能经过一次） Solution 首先根据每个点度数是否都是偶数，判断这个图存不存在一个欧拉回路，答案是 No 然后，如果存在度数大于4的点，那么一定存在至少三条欧拉回路，答案是 Yes 现在我们只需要讨论只含有度数为2或4的图了。 如果度数为4的顶点超过3个，那么答案是 Yes 如果度数为4的顶点恰为2个，这个情况就比较特殊了。把度数为2的点缩起来，我们需要找到这两个顶点之间路径条数 $x$，这两个顶点的自环个数 $y$，判断 $x/2+y$ 和3的大小关系。 如果度数为4的点不超过1个，那么一定最多 2 条欧拉回路，答案是No 时间复杂度 $O(n)$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 200200;int n, m, _x, _y, deg[maxn], cnt;int u = -1, v = -1;vector&lt;int&gt; G[maxn];void dfs(int a, int fa) &#123; for(auto g : G[a]) if(g != fa) &#123; if(deg[g] == 2) dfs(g, a); else if(g == u) cnt += 2; else if(g == v) cnt += 1; else assert(false); &#125;&#125;int main() &#123; read(n, m); rep(i, m) &#123; read(_x, _y); deg[_x]++; deg[_y]++; G[_x].push_back(_y); G[_y].push_back(_x); &#125; rep(i, n) &#123; if(deg[i] &amp; 1) &#123; puts("No"); return 0; &#125; &#125; rep(i, n) if(deg[i] &gt; 4) &#123; puts("Yes"); return 0; &#125; int ok = 0; rep(i, n) if(deg[i] == 4) ok++; if(ok == 0) &#123; puts("No"); return 0; &#125; else if(ok &gt; 2) &#123; puts("Yes"); return 0; &#125; else if(ok == 1) &#123; puts("No"); return 0; &#125; else &#123; rep(i, n) if(deg[i] == 4) &#123; if(u == -1) u = i; else v = i; &#125; dfs(u, -1); if(cnt &gt; 5) puts("Yes"); else puts("No"); &#125; return 0;&#125; Prob. D DPSolution这道题的第一步就非常不好想啊！这个思想还是非常有意思的：我们可以认为每个点坐标可以移动到任何实数，而我们根据初末状态来决定花费：如果点落在原位置左边，那么花费B；落在右边花费A；落在中间无花费。 发现了这个等价转化之后，问题就变得非常简单。我们按照 $1,2,\cdots,n$ 的顺序进行dp，那么每个数移动到的新位置就是递增的。设 $dp[i][j]$ 表示已经考虑过 $1,2,\cdots,i$ 这么些数，且 $i$ 这个数放在了 $[j-1,j)$ 这个区间里的最小花费，那么有：$$dp[i+1][j] = \begin{cases}dp[i][j] &amp; j = f[i+1]\\dp[i][j]+A &amp; j&gt;f[i+1]\\dp[i][j]+B &amp; j &lt; f[i+1]\end{cases}$$时间复杂度 $O(n^2)$。 Code123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 5500;ll dp[maxn][maxn];int n, A, B, p[maxn], f[maxn];// A: right, B: leftvoid upd(ll&amp; x, ll y) &#123; x = min(x, y); &#125;int main() &#123; memset(dp, 0x3f, sizeof dp); scanf("%d%d%d", &amp;n, &amp;A, &amp;B); rep(i, n) scanf("%d", &amp;p[i]), f[p[i]] = i; memset(dp[0], 0, sizeof(dp[0])); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) dp[i][j] = min(dp[i][j-1], dp[i][j]); for(int j = 1; j &lt;= n; ++j) &#123; // [0, j) if(j == f[i+1]) upd(dp[i+1][j], dp[i][j]); else if(j &gt; f[i+1]) upd(dp[i+1][j], dp[i][j] + A); else if(j &lt; f[i+1]) upd(dp[i+1][j], dp[i][j] + B); &#125; &#125; for(int i = 1; i &lt;= n; ++i) dp[n][i] = min(dp[n][i-1], dp[n][i]); printf("%lld\n", dp[n][n]); return 0;&#125; Prob E. 二分，贪心，思维Description给你 $M$ 和 $2n$ 个数 $a_1,a_2\cdots,a_{2n}$ ，你需要把这 $2n$ 个数配成 $n$ 对 $(x_i,y_i) \text{ for }i=1,2,\cdots,n$，使得下面的数取最小值：$$\max_{1\leq i\leq n}\left[(x_i+y_i)\bmod M\right]$$ Solution见官方题解吧，官方题解真的很清楚。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 202000;ll a[maxn], n, m;ll ans = 0x3f3f3f3f3f3f3f3f;bool judge(int x) &#123; ll res = 0; assert((n - x) % 2 == 0); for(int l = x + 1, r = n; l &lt; r; l++, r--) &#123; if(a[l] + a[r] &lt; m) return false; res = max(res, a[l] + a[r] - m); &#125; for(int l = 1, r = x; l &lt; r; l++, r--) &#123; res = max(res, a[l] + a[r]); &#125; ans = min(ans, res); return true;&#125;int main() &#123; scanf("%lld%lld", &amp;n, &amp;m); n &lt;&lt;= 1; rep(i, n) scanf("%lld", &amp;a[i]); sort(a + 1, a + n + 1); int l = 0, r = n; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if((n - mid) &amp; 1) mid--; if(judge(mid)) r = mid; else l = mid + 2; &#125; judge(l); printf("%lld\n", ans); return 0;&#125; Prob F. 概率期望，超级好题这道题我会专门写题解，链接在这里)。这道题的结论是：$$ans = \sum_{i=1}^m \frac{1}{3^i \cdot n(n-i+1)}$$F题果壳网上的优质回答 2015-2016 Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest 代码： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int MOD = 1000000007, maxn = 1020000;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int inv(int x) &#123; return qpow(x, MOD - 2); &#125;int n, ans, i3 = inv(3), in, p3 = 1;int main() &#123; scanf("%d", &amp;n); in = inv(n); for(int i = 1; i &lt;= n; ++i) &#123; p3 = muln(p3, i3); ans += muln(p3, muln(in, inv(n - i + 1))); if(ans &gt;= MOD) ans -= MOD; &#125; printf("%d\n", ans); return 0;&#125; 附录：官方题解题解下载链接]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>思维</tag>
        <tag>dp</tag>
        <tag>欧拉回路</tag>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论之旅1：同余方程]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%97%85%E4%B9%8B%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近我一直在刷潘承洞、潘承彪的《初等数论》，感觉还是学到了不少东西呢。从现在我就来做一个数论之旅系列专题笔记吧，顺便也记录一下我的学习历程。 这一次笔记对应的是《初等数论》第四章同余方程 4.5 到 4.9 的内容，主要介绍二次剩余理论，包括欧拉判别法，勒让德符号，二次互反律，雅克比符号等，以及高次同余方程简介，给出了 $n$ 次剩余的判别公式。 在开始之前约定一下我的记号吧。未经说明的任何字母都代表自然数，小写字母 $p$ 始终代表奇素数，而大写的 $P$ 则不一定。 二次剩余知识与定理首先我们最初是想要解决二次同余方程 $ax^2+bx+c\equiv 0\pmod p$ 。我们经过配方等操作之后，可以发现这种方程化简之后唯一不平凡的形式就是 $x^2\equiv d \pmod p$ 这个样子。这个形式看似简单，不就是模意义下开根号么，可是里面藏着不少玄机。我们先给出一些定义： 模素数的二次剩余、二次非剩余的定义： 若关于 $x$ 的同余方程 $x^2\equiv d \pmod p$ 有解（$p\nmid d$），则称 $d$ 是模 $p$ 的二次剩余； 否则，称 $d$ 是模 $p$ 的二次非剩余。 注意：我们一般不谈 $\pmod 2$ 的二次剩余，也不谈 $0$ 是不是二次剩余。 显然，$\pmod p$ 的二次剩余一共有 $\frac{p-1}{2}$ 个，且方程 $x^2\equiv d \pmod p$ 要么无解，要么恰好有两个解。 欧拉判别法 设素数 $p&gt;2, p\nmid d$ ，那么，$d$ 是模 $p$ 的二次剩余的充分必要条件是：$$d^{(p-1)/2} \equiv 1 \pmod p$$$d$ 是模 $p$ 的二次非剩余的充分必要条件是：$$d^{(p-1)/2} \equiv -1 \pmod p$$ 这个定理是一个比较重要的定理，我们可以轻易在 $O(\log p)$ 的时间内计算出一个数是不是二次剩余，而在大部分ACM竞赛中对于二次剩余也只需要了解这么多。这个地方我暂时不给出证明，以后提到的原根之后，我们将给出一种统一的证明方式，这种证法同时能证明之后提到的 $n$ 次剩余的结论。 由欧拉判别法，根据其只有-1，1这两种取值特点，结合乘方的性质，我们可以很轻易地发现下面的性质： 二次剩余 $\times$ 二次剩余 = 二次剩余 二次剩余 $\times$ 二次非剩余 = 二次非剩余 二次非剩余 $\times$ 二次非剩余 = 二次剩余 模 $p$ 意义下，这种二次剩余的关系满足一种积性性质！那么，我们就引入一种一种完全积性函数来表示二次剩余吧，由此勒让德符号应运而生。 勒让德符号 定义整变量 $d$ 的函数（ $p$ 是素数）$$\left(\frac{d}{p}\right) =\begin{cases}1 &amp; \text{d是模p的二次剩余} \\-1 &amp; \text{d是模p的二次非剩余}\\0 &amp; p\mid d\end{cases}$$我们把 $\left(\frac{d}{p}\right)$ 称为模 $p$ 的勒让德符号。 勒让德符号满足下面的性质: $\left(\frac dp \right) = \left( \frac{p+d}{p}\right)$ ；即：勒让德符号有周期性。 $\left(\frac{d}{p}\right) \equiv d^{(p-1)/2} \pmod p$ 这是因为欧拉判别法 $\left(\frac{dc}{p}\right) = \left(\frac{d}{p}\right) \left(\frac{c}{p}\right)$ 有了第一、第三点，我们称勒让德符号是模 $p$ 的Dirichlet特征，勒让德符号因此具有良好的性质；而有了第二点，我们可以方便地使用快速幂来计算勒让德符号。 二次剩余这么就完全解决了吗？从理论上讲，还有很多非常优美的性质没有挖掘呢！下面我们就引出初等数论最重要的成果之一：高斯的二次互反律。首先我们介绍高斯引理： 高斯引理 设 $p \nmid d$；再设 $1\leq j \leq (p-1)/2$，令$$t_i \equiv jd \pmod p,\text{ } 0 &lt; t_j &lt; p$$以 $n$ 表示这 $(p-1)/2$ 个 $t_i$ 中大于 $p/2$ 的数的个数，那么：$$\left(\frac{d}{p}\right) = (-1)^n$$事实上，当 $\gcd(d,2p)=1$ 时，我们还有 $n$ 的精确表达式：$$n = \sum_{i=1}^{(p-1)/2} \left[\frac{jd}{p}\right]$$ 这个定理还是蛮有用的，有了高斯引理，我们就可以解决一部分勒让德符号计算的问题了：（读者可以自己验证） $\left( \frac{1}{p} \right) \equiv 1$ 这个根据定义显然； $\left( \frac{-1}{p} \right) \equiv (-1)^{\frac{p-1}{2}}$ 根据定义显然，$4k+1$ 型素数-1是二次剩余； $\left( \frac{2}{p} \right) \equiv (-1)^{\frac{p^2-1}{8}}$ 用高斯引理易得。这说明对于 $8k\pm 1$ 型素数 $2$ 是二次剩余； 那么如何证明呢？高斯引理的证明是挺精妙的，我们只证明前一半部分。我们考虑 $t_i$ 的乘积，一方面：$$\prod_{i=1}^{(p-1)/2} t_i = d^{(p-1)/2} \prod_{i=1}^{(p-1)/2} i$$另一方面，把 $t_i$ 中所有大于 $(p-1)/2$ 的数 $r$ 换成 $p - r$ ，即可使这些 $t_i$ 形成 $1,2,\cdots,(p-1)/2$ 的一个排列，这个过程中一共有 $n$ 个数被调换，因此乘积中会出现 $(-1)^n$ 的因子。由此：$$\prod_{i=1}^{(p-1)/2} t_i = (-1)^n \prod_{i=1}^{(p-1)/2} i$$综合上面两个式子，即可得到这个定理。 如果稍微进行一些分析，就可以得到 $n$ 的表达形式了，这里不再展开。可是我们能够注意到， $n$ 的形式不是类欧几里得算法的形式么？我们自然要考虑它的几何意义。如下图，这个值就是阴影三角形 $\triangle OCB$ 内部格点的数目。为什么说是内部呢？很好证明，这个三角形斜边上不会出现格点。 二次互反律在上面的图片里面，我们不禁要问还有没有别的几何意义。我们观察 $\triangle OCB$ ，这个三角形就是 $\left(\frac{p}{d}\right)$ 啊！（注意我们之前约定过 $d$ 是奇数）。那么这两个三角形的格点数目之和正好就是整个矩形的格点数目 $\frac{p-1}{2} \cdot \frac{d-1}{2}$ ！由此我们就证明了二次互反律： 设 $p,q$ 为奇素数，$p\neq q$ ，则有：$$\left(\frac qp\right) \cdot \left( \frac pq \right) = (-1)^{\frac{p-1}{2} \cdot \frac{q-1}{2}}$$ 二次互反律的理论价值和实用价值都很高，可以证明很多命题，下面举几个《初等数论》上的例题吧，读者可以想一想怎么解决，之后可能会更新解答。 证明有无穷多个 $8k+1$ 型质数 求以 $11$ 为其二次剩余的所有奇素数 $p$ 证明：若$\left(\frac dp\right) = -1$ ，则 $p$ 必然不能表示为 $x^2-dy^2$ 的形式。 我们再说一说二次互反律的另一个重要价值——计算勒让德符号。有了二次互反律，我们可以设计一种类欧几里得算法！回想我们是如何使用欧几里得算法求最大公约数的： 我们知道 $\gcd(a,0)=a$ 这一种平凡情况 否则，利用 $\gcd(a,b) = \gcd(b,a\%b)$ ，我们可以将问题规模缩小一半，从而让问题可以化为平凡情况 对于勒让德符号的计算，我们不也可以这样吗？我们有这么几个条件： 当勒让德符号上面的数 $d=1,2 \text{ or } -1$ 时，可以直接给出答案； 否则，根据互反律，我们可以交换上下两个数，$O(1)$ 计算那个多出来的 $(-1)^{\frac {p-1}{2} \cdot \frac{q-1}2}$ 因子，然后用Legendre符号的周期性进行取模，使得问题规模缩小一半。 这不是挺完美的吗？别高兴得太早！别忘记，勒让德符号要求符号下面的数 $p$ 可要是质数！正因为这一点，互反律成立需要 $p,q$ 是奇素数才可以！这样才能保证勒让德符号有意义！这可麻烦了，这样的话，就是计算个勒让德符号，还要必须将数分解质因数！分解质因数可不是个简单的事情，当数比较大的时候这个开销是花不起的。那么我们怎么办呢？我们可以拓展勒让德符号的定义，我们来定义雅克比符号： 雅克比符号 设奇数 $P&gt;1$，$P=p_1p_2\cdots p_s$ ，则定义雅克比符号为：$$\left( \frac dP \right) = \prod_{i-1}^{s} \left(\frac d{p_i}\right)$$其中乘积项中的符号是勒让德符号。 可以验证，雅克比符号满足勒让德符号的一切性质，并且满足互反律，因此可以辅助计算勒让德符号。 可是有一点必须强调：雅克比符号 $\left( \frac dP \right)=1$ 绝不保证 $x^2\equiv d \pmod P$ 一定有解！例如：$\left(\frac 2 {3599}\right) = 1$ ，可是 $x^2\equiv 2 \pmod {3599}$ 无解！ 其实雅可比符号还有拓展，叫做Kronecker符号，甚至还可以拓展到有理数范围，叫做Hilbert符号。这里给出维基百科的链接吧 Legendre，此处不再详细说明了。（其实是因为我也不会） 下面是一个雅克比符号的模板。使用二次互反律计算，复杂度 $O(\log \min \{a,n\})$ 。Accepted on HDU3589 12345678910int Jacobi(int a, int n) &#123; a %= n; if(a == 0 || (a%2==0 &amp;&amp; n%2==0)) return 0; if(a == 1) return 1; if(a == 2) return (((n&amp;7) == 1) || ((n&amp;7) == 7)) ? 1 : -1; if((a &amp; 1) == 0) return Jacobi(2, n) * Jacobi(a / 2, n); if(n % 2 == 0) return Jacobi(a, 2) * Jacobi(a, n / 2); int sgn = ((a - 1) / 2 * (n - 1) / 2) &amp; 1; return Jacobi(n, a) * (sgn ? -1 : 1);&#125; Cipolla算法上面主要是在讲如何判断二次剩余存不存在的问题，可是如果知道存在了，到底应当怎样构造呢？Cipolla算法即可解决这个问题。这个算法感觉数学背景还是蛮深厚的，是一个挺有趣的算法。 推荐博客 czy ，下面内容是从他的博客上抄的。 模板题： Timus 1132 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define Type intnamespace ModOp &#123; Type MOD; inline Type mo(Type x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125; struct MF &#123; Type v; MF(Type x = 0): v(mo(x)) &#123; &#125; operator Type() &#123; return v; &#125; MF operator + (const MF&amp; f) const &#123; return mo(v + f.v); &#125; MF operator - (const MF&amp; f) const &#123; return mo(v - f.v); &#125; MF operator * (const MF&amp; f) const &#123; return 1LL * v * f.v % MOD; &#125; MF operator / (const MF&amp; f) const &#123; return v / f.v; &#125; MF operator - () const &#123; return MOD - v; &#125; MF operator &gt;&gt; (int idx) const &#123; return v &gt;&gt; idx; &#125; MF operator &lt;&lt; (int idx) const &#123; return v &lt;&lt; idx; &#125; bool operator == (const MF&amp; f) const &#123; return v == f.v; &#125; bool operator != (const MF&amp; f) const &#123; return v != f.v; &#125; bool operator &gt; (const MF&amp; f) const &#123; return v &gt; f.v; &#125; bool operator &lt; (const MF&amp; f) const &#123; return v &lt; f.v; &#125; bool operator &gt;= (const MF&amp; f) const &#123; return v &gt;= f.v; &#125; bool operator &lt;= (const MF&amp; f) const &#123; return v &lt;= f.v; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; out, MF f) &#123; return out &lt;&lt; f.v; &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, MF f) &#123; return in &gt;&gt; f.v; &#125; bool scan() &#123; return scanf("%d", &amp;v) != -1; &#125; void print() &#123; printf("%d", v); &#125; &#125;;&#125;#undef Typetemplate&lt;typename T&gt; T qpow(T x, int y) &#123; T ret = T(1); for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) ret = ret * x; return ret;&#125;using ModOp::MF;namespace qres &#123; MF a, n; int p; struct F &#123; MF x, y; // x+yw F(MF _a = 0, MF _b = 0): x(_a), y(_b) &#123; &#125; F operator + (F f2) const &#123; return F(x + f2.x, y + f2.y); &#125; F operator * (F f2) const &#123; return F(x*f2.x + y*f2.y*(a*a-n), x*f2.y+y*f2.x); &#125; &#125;; MF Legendre(MF d) &#123; return qpow(d, (p-1)/2); &#125; void Cipolla(int qn, int qp) &#123; // p is a prime, gcd(n, p) = 1 qn %= qp; if(qp == 2 &amp;&amp; qn == 1) &#123; puts("1"); return; &#125; ModOp::MOD = p = qp; n = qn; if(Legendre(n) != MF(1)) &#123; puts("No root"); return; &#125; a = rng() % p; while(Legendre(a * a - n) != MF(-1)) a = rng() % p; F w(a, 1), res = qpow(w, (p + 1) / 2); MF ans = res.x, ans2 = -ans; if(ans &gt; ans2) swap(ans, ans2); cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; "\n"; &#125;&#125; 例题题解允许我先咕一下QAQ [CF1091G] New Year and the Factorisation Collaboration 蛮有意思的CF题，在Goodbye 2018里出的。 BZOJ1406 [AHOI2007]密码箱题意：求下面同余方程的所有解：$(n\leq 2\cdot 10^9)$$$x^2\equiv 1 \pmod n$$解法： 对于方程 $x^2\equiv 1 \pmod{p^\alpha}$ ，只需要进行分类讨论，然后Hensel引理升幂。对于任意模数的情况，只需要再用CRT合并。 [SCOI2018] Numazu的蜜柑模素数的高次同余方程模意义下的因式定理现在我们要解决更加困难的问题了：给定整系数多项式 $f(x)$，求解 $f(x)\equiv 0 \pmod p$ 。对于实数域，有因式定理，即如果 $f(x)$ 有根 $c$，则 $f(x)$ 有因式 $(x-c)$。对于模意义下有没有类似性质呢？答案是肯定的。 设 $p\nmid a_n$ ，若 $n$ 次同余方程 $f(x) \equiv 0 \pmod p$ 有 $k$ 个不同的解 $x\equiv c_1,\cdots,c_k \pmod p$ ，则一定存在唯一一对整系数多项式 $g_k(x), r_k(x)$，使得：$$f(x) = (x-c_1)\cdots(x-c_k)g_k(x) + p \cdot r_k(x)$$ 这个定理还有一种等价表述，即Lagrange定理： $f(x) \equiv 0 \pmod p$ 的解数 $k \leq \min(n,p)$ 结合上面定理，我们可以得到一个强有力的结论，即判别 $n$ 次方程恰有 $n$ 个解的方法： 设 $a_n=1$ ，那么 $f(x) \equiv 0 \pmod p$ 的解数等于 $n$ 的充分必要条件是：存在整系数多项式$q,r$ ，且$r$ 次数小于 $n$，使得：$$x^p-x = f(x)q(x) + p\cdot r(x)$$ $n$ 次剩余由此，我们就具有了解决 $n$ 次剩余的理论基础。我们称 $x^n\equiv a \pmod p (p\nmid a)$ 为二项同余方程，而如果这个方程有解，则称 $a$ 为模 $p$ 的 $n$ 次剩余，否则为 $n$ 次非剩余。可以利用原根证明下面两个定理： 若 $n\mid p-1$ ，则 $x^n\equiv a \pmod p (p\nmid a)$ 的充要条件是：$$a^{(p-1)/n} \equiv 1 \pmod p$$ 若 $n\nmid p-1$ ，令 $k=\gcd(n,p-1)$ 则 $x^n\equiv a \pmod p (p\nmid a)$ 的充要条件是：$x^k\equiv a \pmod p $ 有解，且解数相同。即有解的充分必要条件是：$$a^{(p-1)/k} \equiv 1 \pmod p$$ 这样我们就找到了欧拉判别法的推广！我们也可以快速解决判断 $n$ 次剩余的问题了！可是还有没有类似勒让德符号的定义了呢，有没有互反律之类的东西了呢？在自然数范围内是没有了，如果使用代数数论的观点来看，应该还是有的，可是超出了我们的讨论范围。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>二次剩余</tag>
        <tag>数论</tag>
        <tag>n次剩余</tag>
        <tag>数论之旅系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Grand Contest 031 比赛总结]]></title>
    <url>%2F2019%2F03%2F17%2FAtcoder-Grand-Contest-031-%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview Status A B C D E F Contest 00:05 00:17 —— —— —— —— Upsolve OK OK AC AC Attempt + + *2 * AC count 1536 993 246 54 9 5 Rank 358 out of 1925, performance 2020 Rating 820, became Pupil 比赛中卡在 C 题上了，和cyy想出了做法，可是比赛中没来得及写完，挺可惜的 C题是挺有趣的一道构造题，相当于是超立方体中询问任意两点是否存在哈密尔顿路径。 D题是类似于斐波那契数列的置换序列，找到规律之后其实挺简单的，感觉可能有更高深的知识背景 nocriz 太强了！过了 C 题，Rank 167 [TODO: solve Problem E] Prob A. 签到答案就是 (每种字母出现次数+1) 乘起来，然后再减一。 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;int n, ans = 1;map&lt;char, int&gt; cnt;char s[300000];int main() &#123; scanf("%d%s", &amp;n, s); for(int i = 0; i &lt; n; ++i) cnt[s[i]]++; for(auto g : cnt) &#123; ans = 1LL * ans * (g.second + 1) % 1000000007; &#125; cout &lt;&lt; ans - 1; return 0;&#125; Prob B. 简单dp首先，我们把字符串中连续相同字母缩成一个，即把 “aaaabbaaaaa” 缩成 “aba”，这样相邻字母就互不相同了。 考虑 $dp[r]$ 表示子串 $s[1,r]$ 的答案，我们只需要枚举最后一个字母 $s[r]$ 的选择。有两种转移： $s[r]$ 不参与染色，那么贡献是 $dp[r-1]$ $s[r]$ 与 $sc$ 同色，染好之后，只需要染前面 $s[1,c-1]$ 这个子串，贡献就是 $dp[c-1]$ 把每种颜色的贡献用数组存起来就可以 $O(1)$ 完成转移了。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 202000, MOD = 1000000007;int c[maxn], tot, n, dp[maxn], sum_occ[maxn], _x;int main() &#123; scanf("%d", &amp;n); rep(i, n) &#123; scanf("%d", &amp;_x); if(_x == c[tot]) continue; c[++tot] = _x; &#125; dp[0] = 1; for(int i = 1; i &lt;= tot; ++i) &#123; dp[i] = (dp[i - 1] + sum_occ[c[i]]) % MOD; sum_occ[c[i]] = (dp[i - 1] + sum_occ[c[i]]) % MOD; &#125; cout &lt;&lt; dp[tot] &lt;&lt; '\n'; return 0;&#125; Prob C. 构造，格雷码，好题Description给出 $n, A, B$ 三个数，问存不存在 $0,1,\cdots,2^n-1$ 的一个排列 $p$ ，使得： $p_0=A$ ，即第一项是A。 $p_{2^n-1} = B$，即第二项是B。 $\text{popcount}(p_i \oplus p_{i+1}) = 1, \forall i \in [0,2^n-1)$ ，即相邻两个数二进制表示只差一位。 Solution这道题感觉结论还是挺吸引人的，构造方法是不太寻常的归纳，用到了格雷码的相关知识，而且它还有超立方体哈密尔顿路径的构造这么一个非常有趣的背景，是一道挺不错的题目。 超立方体哈密尔顿路径首先讲一下这个问题和超立方体哈密尔顿路径的关系，虽然这一点在解决这道题中倒是没有起到太大的作用。 如果仔细观察题中所说的由 $0,1,2,\cdots,2^n-1$ 作为顶点，二进制表示仅仅相差以为的两个数连边，这样构成的图其实就是超立方体。构造方式是这样的： 零维立方体是一个孤立的点 $k+1$ 维立方体是这样构造的： 首先，画出两个 $k$ 维立方体 然后，将这两个 $k$ 维立方体对应顶点连上线即可。 于是，问题就化成了从超立方体顶点 $A$ 走到顶点 $B$，存不存在一条哈密尔顿路径，如果存在就请构造出来。对于这个问题，说不定一些启发式算法可以通过？ 一种构造首先，我们只需要考虑从 $0$ 走到 $A\oplus B$ 的情况，而中间会经过 $2^n-1$ 次某个二进制位翻转的操作，因此 $A\oplus B$ 的二进制位数为偶数时，答案一定是不可以。那么为奇数时，是否就一定可以了呢？ 事实上，确实是这样的。 Gray 函数我们首先描述一种 $A=\underbrace{000\cdots 0}_{k\text{ zeros}}$ , $B=1\underbrace{00\cdots 0} _ {k-1 \text{ zeros}}$ 的不重不漏的构造，这种构造使用了数学归纳法，本质上就是格雷码的构造过程： 首先，根据归纳假设，我们选定后 $k-1$ 位，可以将 $000\cdots 0$ 变为 $010\cdots 0$ ； 然后，我们把第一位改变，即：变为 $110\cdots 0$ 再之后，我们再选定后 $k-1$ 位，使用和第一步完全一样的翻转方法，即可得到 $100\cdots 0$ ，可以发现，在整个过程中，每一个数都已经出现过了。 硬核构造下面的构造就比较硬核了，很多步骤相互嵌套，但是规模在逐步缩小，因此是正确的。 我们上面现在解决了 $A$与 $B$ 相差1位的情形，要解决一般的情形，即：$$A=\underbrace{000\cdots 0} _ {k\text{ zeros}}, B=\underbrace{111\cdots1} _ {m\text{ ones}} \underbrace{000\cdots 0} _ {k-m \text{ zeros}}$$ 我们将其记为：mono(ones, zeros) 首先，我们声称，解决从 $\underbrace{000\cdots 0} _ {m\text{ zeros}}$ 到 $\underbrace{111\cdots 1} _ {m\text{ ones}}$ 的问题即可完成上述过程。我们这么进行操作：假如我们已经有一个操作序列 $op_1,op_2,\cdots,op_{2^m-1}$ 能够完成从全0到全1的变化，那么在每进行一次操作 $op_i$ 之后，我们都跑一遍后 $k-m$ 位的格雷码，将其第一位修改，后 $k-m-1$ 位不变。经过这样的操作，如果前面全0到全1能够遍历前k位所有可能情况，那么后面的格雷码操作将可以保证我们总的方案是正确的。 第二步就是解决从 $\underbrace{000\cdots 0} _ {m\text{ zeros}}$ 到 $\underbrace{111\cdots 1} _ {m\text{ ones}}$ 的过程。 我们先将其后 $m-1$ 位跑一遍格雷码，变成 $010\cdots 0$ 然后把第一位改变，变为 $110\cdots 0$ 这一步，我们对后面的 $m-1$ 位递归调用 mono(m-2, 1) ，使得后 $m-2$ 位改变，而第2位不变，并且遍历完后 $m-1$ 位的所有情况。这样，我们就完成了总的构造。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;int cur = 0, A, B, n, dif;vector&lt;int&gt; ans;void gray(deque&lt;int&gt; pos, deque&lt;int&gt; care) &#123; int sz = pos.size(); if(sz == 0) return; int fr = pos.front(); pos.pop_front(); gray(pos, care); gray(care, deque&lt;int&gt;()); cur ^= (1 &lt;&lt; fr); ans.push_back(cur ^ A); gray(pos, care);&#125;void mono(deque&lt;int&gt; ones, deque&lt;int&gt; care) &#123; if(ones.size() == 0) return; if(ones.size() == 1) &#123; care.push_front(ones.front()); gray(care, deque&lt;int&gt;()); return; &#125; int fr = ones.front(); ones.pop_front(); gray(ones, care); int se = ones.front(); gray(care, deque&lt;int&gt;()); cur ^= (1 &lt;&lt; fr); ans.push_back(cur ^ A); care.push_back(se); ones.pop_front(); mono(ones, care);&#125;void solve() &#123; deque&lt;int&gt; cg, ncg; for(int i = 0; i &lt; n; ++i) &#123; if(dif &gt;&gt; i &amp; 1) cg.push_back(i); else ncg.push_back(i); &#125; mono(cg, ncg);&#125;bool vis[1&lt;&lt;18];int last ;int main() &#123; cin &gt;&gt; n &gt;&gt; A &gt;&gt; B; dif = A ^ B; if(__builtin_popcount(dif) &amp; 1) &#123; puts("YES"); ans.push_back(cur ^ A); solve(); for(auto g : ans) printf("%d ", g); &#125; else puts("NO"); return 0;&#125; Prob D. 置换，找规律Description给你一个置换序列的前两项 $a_1=p,a_2=q$ ，之后的置换这么定义： 记第 $a_k$ 个置换的之前的 $a_{k-2}=m,a_{k-1}=n$ ，则 $a_k$ 的第 $m[i]$ 项 $a_k[m[i]] = n[i]$ 之后询问第 $q$ 个置换是多少。 Solution这道题蛮乱搞的，写出前10项左右可以发现规律，然后就没了。规律在代码中写得很明确。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;struct permutation &#123; int sz; vector&lt;int&gt; a; permutation(int N = 0): sz(N), a(N + 10) &#123; &#125; inline void identity() &#123; for(int i = 1; i &lt;= sz; ++i) a[i] = i; &#125; inline void show(const char * msg) &#123; printf("%s", msg); for(int i = 1; i &lt;= sz; ++i) &#123; printf("%d", a[i]); if(i &lt; sz) putchar(' '); &#125; &#125; int&amp; operator [] (int idx) &#123; return a[idx]; &#125; permutation operator * (permutation rhs) &#123; permutation res(sz); for(int i = 1; i &lt;= sz; ++i) res[i] = a[rhs[i]]; return res; &#125; bool check() &#123; vector&lt;int&gt; _vis(sz + 3, 0); rep(i, sz) _vis[a[i]] = true; rep(i, sz) if(!_vis[i]) &#123; puts("NO!NOT A PERMUTATION!"); return false; &#125; return true; &#125; ll decomp() &#123; vector&lt;int&gt; _vis(sz + 3, 0); ll ans = -1; for(int i = 1; i &lt;= sz; ++i) if(!_vis[i]) &#123; ll len = 0, c = i; while(!_vis[c]) &#123; _vis[c] = true; len++; c = a[c]; &#125; if(ans == -1) ans = len; else ans = ans * (len / __gcd(ans, len)); &#125; return ans; &#125; permutation inverse() &#123; permutation rev(sz); rep(i, sz) rev[a[i]] = i; return rev; &#125;&#125;;permutation qpow(permutation p, int y) &#123; permutation t(p.sz); t.identity(); for(; y; y &gt;&gt;= 1, p = p * p) if(y &amp; 1) t = t * p; return t;&#125;int n, k;int main() &#123; scanf("%d%d", &amp;n, &amp;k); int period = (k - 1) / 6, left = k - 6 * period; permutation p(n), q(n), pi(n), qi(n), res(n), A(n), B(n), qpqp(n); rep(i, n) scanf("%d", &amp;p[i]); rep(i, n) scanf("%d", &amp;q[i]); pi = p.inverse(); qi = q.inverse(); qpqp = q * pi * qi * p; res.identity(); A = qpow(qpqp, period); switch(left) &#123; case 1: B = p; break; case 2: B = q; break; case 3: B = q * pi; break; case 4: B = q * pi * qi; break; case 5: B = q * pi * qi * p * qi; break; case 6: B = q * pi * qi * p * p * qi; break; &#125; res = A * B * A.inverse(); res.show(""); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>构造</tag>
        <tag>格雷码</tag>
        <tag>置换</tag>
        <tag>哈密尔顿路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[p进数 (p-adic) 、牛顿迭代与Hensel引理]]></title>
    <url>%2F2019%2F03%2F10%2Fp%E8%BF%9B%E6%95%B0-p-adic-%E4%B8%8EHensel%E5%BC%95%E7%90%86%2F</url>
    <content type="text"><![CDATA[你敢相信 $\sum\limits^{\infty}_{i=0}2^i = -1$ 吗？数论中一个长相奇怪的定理到底有什么直观意义？牛顿迭代法作为常用的数值方法，和p进数又会有什么联系？ 上面的几个问题似乎毫不相关，我当时分别听说这几个知识的时候也没有发现它们之间的联系。可是这几天偶然了解到有关p进数（p-adic）的一套理论，我顿时感觉如同醍醐灌顶：换一种角度看问题，它们之间的联系居然如此简单明了！下面我就来介绍一下我认识的这几个知识的联系吧。 这一块内容有很多涉及代数数论甚至泛函分析的相关内容，我都没有太深入的了解，可能会出不少问题，也希望大家能给我进行一些补充吧。 TL;DR（Too long; Don’t read） （这是简述，看完简述剩下的就可以不看了） 简而言之，这篇文章数论中一个形式古怪的提高模数次数的定理（Hensel定理，2.1中有定义描述与证明）说起，目的是阐明它的直观意义，即说明与牛顿迭代法的相似性： 一方面，从定理形式的表面出发，这个定理的变形之后和牛顿迭代法是极为相似的 另一方面，从更深层次的意义来说，它解决的问题是在p进度量下用有理数逼近多项式的零点的过程。 第一点在2.2会有解释，而第二点则更为关键。本质上说，牛顿迭代法那样在绝对值度量下用有理数估计多项式零点，用的是是从数位高的地方向数位低的地方逼近的方法，即类似$1,1.4,1.41,1.414,\cdots$ 的过程。可是Hensel定理是从恰恰相反的方向逼近的，即从数位低的地方向数位高的地方递进的，如在7-adic下逼近 $\sqrt{2}$，则逼近的数列是这样的： $\{3, (13)_7, (213)_7,\cdots\}$ 。 这么做靠谱吗？怎么感觉都没有任何收敛的感觉呢，简直玄学！可是你为什么说这个数列不收敛？你会说，因为相邻两项之间的距离，即差的绝对值，越来越大了呗。但是你说的这个距离为什么就是差的绝对值？如果我巧妙定义另一套距离，说不定我就可以说这个数列是逐步收敛的了。这就引出了一套有趣的数学理论，即p进度量和p进数 。 首先，我们定义了有理数集上一种独特的范数和距离 然后，我们引入完备的概念。在绝对值度量下，比如数列$1,1.4,1.41,1.414,\cdots$ ，这个数列存在极限（因为单调有界），并且数列每一项都是有理数，但是这个极限就不在有理数集里。因此我们称有理数集是不完备的，称这样的数列就是在对无理数进行逼近。 从这个观点来看， Hensel引理相当于在p进度量下，给出了用有理数逼近多项式零点的数列的构造。 牛顿迭代法给出了在绝对值度量下用有理数逼近多项式零点的数列的构造。 因此从目的的角度看来，牛顿迭代和Hensel引理是在不同度量下，解决同一个问题，因此形式相似。这可真的是殊途同归啊！这不得不赞叹数学的魅力了。 P.S. 强烈推荐3blue1brown的这个视频，讲的是p进数：3blue1brown的视频 非常直观易懂，让大家瞬间能对p进数有个概念。可以先看视频，再看本文。 Hensel引理一切的一切，都要从潘承洞、潘承彪《初等数论》第186页的一个定理说起。（第四章第四节） 如果你求出了一个整系数多项式同余方程 $f(x)\equiv 0 \pmod p$ 的一些解 $x\equiv c_1,c_2,\cdots\pmod p$ ，但是我要求你再求出 $\mod {p^2}$ 的解，你该怎么做呢？直接重新求一遍？太麻烦了吧！有什么简单方法吗？这个定理给出了答案。只是。。。这个定理的形式有点诡异，无法直观理解： 定理的描述与证明定理描述定理 设 $p$ 是素数，整系数多项式 $f(x)=a_n x^n+a_{n-1}x^{n-1} +\cdots + a_1x+a_0, n \geq 2$ ；再设整数$\alpha \geq 2$， $c$ 是同余方程 $f(x) \equiv 0 \pmod {p^{\alpha-1}}$ 的解，那么，同余方程 $f(x) \equiv 0 \pmod{p^\alpha}$ 满足 $x\equiv c\pmod{p^{\alpha-1}}$ 的解是形式一定是$x\equiv c+y_j p^{\alpha - 1}, j=1,2,\cdots, l$ ，这里$y\equiv y_1,\cdots,y_l \pmod p$ 是关于 $y$ 的一次同余方程：$$f’(c) \cdot y\equiv -f(c) \cdot p^{1-\alpha} \pmod p \tag{1}$$的全部解，其中 $f’(x)$ 即表示 $f(x)$ 的导函数。 （这个定理据说是代数数论重要定理Hensel引理的初等描述。） 一些解释与思考这个定理好诡异啊！到底是什么意思呢？我们一步一步来。首先 $x\equiv c\pmod{p^{\alpha-1}}$ 这个解在模数升幂之后的形式一定是 $x\equiv c+y p^{\alpha - 1} \pmod{p^\alpha}$ ，这一点可以理解，因为如果把 $x$ 写成 $p$ 进制数，那么 $x$ 的后$\alpha - 1$ 位（从个位开始数）已经确定为 $c$ ，只有第 $\alpha$ 位这一个位置可以任取，不妨设这一位的数是 $y $，( $0\leq y&lt; p$ )，则解的形式就是 $x\equiv c+y\cdot p^{\alpha -1}$ 。 可能有同学会问：为什么拓展之后的解形式中 $y$ 还要分这么多种？这是因为同余方程 (1) 是一次同余方程，根据 $f’(c)$ 和 $-f(c)\cdot p^{1-\alpha}$ 是否模 $p$ 余 $0$ 进行讨论的话，可能有一个解，可能无解，也可能任何 $0\leq y&lt;n$ 的数都是解，即：拓展之后可能有 $0,1$ 或 $p$ 个解，这么写是一种不失一般性的写法。 然后。。。就到了最鬼畜的(1)式了。这里怎么莫名出现了导数？为什么它的形式如此诡异？二潘在书里也给出了一个初等的证明，但同样无法让人感受这个定理的直观意义。 定理证明证明 将拓展之后的解的形式 $x\equiv c+y_j p^{\alpha - 1}$ 代入方程 $f(x) \equiv 0 \pmod{p^{\alpha}}$ ：$$\begin{align}f(x) &amp; \equiv &amp; a_n(c+p^{\alpha-1}y)^n + a_{n-1} (c+p^{\alpha-1}y)^{n-1} +\cdots+a_0\\ &amp; \equiv &amp; f(c)+p^{\alpha-1}f’(c)y+A_2p^{2(\alpha-1)}y^2+\cdots+A_n p^{n(\alpha-1)}y^n\ &amp; \equiv &amp; 0 \pmod {p^\alpha}\end{align}$$其中 $A_2, A_3,\cdots,A_n$ 是整数，由于 $\alpha \geq 2$ ，从上式可知 $f(x) \equiv 0 \pmod{p^{\alpha}}$ 等价于：$$p^{\alpha-1} f’(c) y \equiv -f(c) \pmod{p^\alpha}$$由于 $f(c)$ 是 $p^{\alpha-1}$ 的倍数（因为 $f(c)\equiv 0 \pmod {p^{\alpha-1}}$），所以两边同时除以 $p^{\alpha - 1}$ 即可得到我们要证明的式子。 评论 说实话。。。这个证明也挺平凡的，并没有给我对于定理的直观感受。那么下面我们就从直观感觉出发，探究这个定理究竟是在解决什么问题。 与牛顿迭代法形式上的相似之处其实，式 (1) 和牛顿迭代法本质是完全相同的。 先做一个约定，这里的牛顿迭代法为了和Hensel引理相对应，采用非常狭义的定义。要求初始值为有理数，而求零点的函数也是多项式函数，这样迭代的每一步也都是有理数了。 我们知道，在求连续函数 $f(x)$ 的零点时，牛顿迭代法的递推公式是：$$c’ = c - \frac{f(c)}{f’(c)} \tag{2}$$而我们的式 (1) 也可以写作（假设只有一个拓展后的解）：$$c’ \equiv c-\big(\frac{f(c)/p^{k-1}}{f’(c)} \bmod p\big) \cdot p^{k-1} \pmod{p^k}$$如果不严格地把取模号全部丢弃，我们会发现这个式子和 (2) 是完全一样的。事实上，在同余运算下因为有取模操作，式 (1) 已经做到和牛顿迭代保持最大程度的相似了。 那么我们来考虑这两者在目的上有什么相似之处：牛顿迭代实际上在不断逼近一个使得函数值为0的点，这里的“逼近”指的是迭代值和真实值的距离（即差的绝对值）逐渐缩小，是一个收敛的过程；而Hensel引理的让幂次升高的迭代是否也是在”逼近“某个数呢？不过这里的逼近好像会导致迭代值之间差的绝对值越来越大，这个过程是还能是收敛的吗？ 事实上，这就引出了有理数的另一种度量：$p$ 进度量（或 $p$ 进赋值）。 $p$ 进数$p$ 进制数首先明确一点的是 $p$ 进数中的 $p$ ，指的是素数，因为素数情况下的性质比较优雅。 什么是 $p$ 进数（p-adic）？我们先从 $p$ 进制数一步一步说起。 我们都熟悉十进制数，我们可以类似十进制表示法那样，写出 $p$ 进制数的形式：$$\begin{align}x&amp;=&amp;\cdots\alpha_i \alpha_{i-1}\cdots\alpha_1\alpha_0.\alpha_{-1}\cdots\alpha_{-k+1}\alpha_{-k}\\&amp; = &amp; \cdots + \alpha_i p^i+\cdots + \alpha_1p +\alpha_0 + \frac{\alpha_{-1}}{p} + \cdots\frac {\alpha_{-k}}{p_k}\end{align}$$一些常见的结论就是，一个分母是 $p$ 的整数幂的分数在 $p$ 进制下为有限小数；其他有理数一定会是循环小数，无理数则是无限不循环小数。 在我们通常的认识中，如果 $x$ 是正数，那么 $x$ 小数点左边的数位越多，这个数就会越大（称为范数越大）。但是这一点是为什么呢？像刚才的问题，那我能不能定义右数字越多，这个数越大呢？ 为了探寻上面数论定理的意义，我们采用这种反着来定义范数的方法，可是我们还需要做一些准备工作，即我的这种定义需要满足距离的性质。 范数与度量范数是绝对值概念的推广。由上面的例子看出，范数也是需要公理化的。那么范数需要有哪些性质呢？ 若 $X$ 是数域上的线性空间，泛函 $\left| \cdot \right|:X \rightarrow R$ 满足： (1) 正定性：$\left|x\right|\geq0$，且 $\left|x\right|=0\Leftrightarrow x=0$； (2) 正齐次性： $\left|cx\right|=|c|\left|x\right|$; (3) 次可加性（三角不等式）：$\left|x+y\right|\leq \left|x\right|+\left|y\right|$ ； 那么，$\left|\cdot\right|$ 称为 $X$ 上的一个范数。 我们定义 $v_p(x)=\max \{\alpha \in N: p^\alpha \mid x \} $，则 $|x|_p = p^{-v_p(x)}$ 就可以作为正整数域 $N^*$ 的一个范数（注意指数上的符号！这就是上面小数点后数字越多，数越大的体现）。这个概念还可以推广到有理数域 $\mathbb{Q}$。定义 $|\frac ab|_p = \frac{|a|_p}{|b|_p}$ 即可。 有了范数的概念，定义距离就是很显然的了。$d(x,y)=\left|x-y\right|$ 。 例如，$p=3$ 时$$d(5, \frac 59) = p^{-v_p(\frac {40}{9})}=p^{-2}=\frac 19$$ $$d(6,735) = p^{-v(729)} = p^{-6} = \frac{1}{729}$$ 因此，最开头说的这个式子在2-adic的左边就不再是那么不可理解了：$$\sum_{i=0}^\infty 2^i = -1$$ 在绝对值度量下，我们认为“越来越小”的数组成的级数可能收敛，可是在这里不也一样吗？在2-adic下，$2^i$ 随着 $i$ 的增大，不就是在减小吗？还有一个问题，右边为什么是 $-1$？这就要思考在 2-adic 下怎么表示负数了。 这确实又引出了问题。 和绝对值度量一样，我们从大到小考虑这个p进数的每一位进行近似。这里要注意，$p$ 是比 $p^2$ 大的，因此从大到小就是对应这一个升幂的过程。 以 $x=-1$ 的表示为例，首先考虑第0位。这一位应当满足：$$x\equiv -1 \pmod 2$$显然这一位是1。然后考虑第一位后这个数一定是 $1+t\cdot2$形式的，那么：$$1+t\cdot 2\equiv -1 \pmod {2^2}$$由此， $t\equiv 1 \pmod 2$ 。那么考虑第二位。这个数现在变成了 $1+2+t\cdot2^2$形式，然后我们要解：$$1+2+t\cdot 2^2\equiv -1 \pmod{2^3}$$逐渐进行下去，我们发现这里的每一位都是 $1$ ，因此 $-1$ 在2-adic下的表示就是 $\sum\limits_{i=0}^\infty 2^i$ 这个例子是不是很有启发性？这个过程是不是和上面的定理很相似？ 像这样，我们可以利用p进度量求得 p-adic 下所有的有理数 $\frac ab$ 的表示。我们只需要将方程 $bx\equiv a\pmod{p^k}$ 不断用类似的过程升幂，而升幂的过程就是一个渐进的过程。 有理数域的完备化还有更疯狂的呢！如果我对 $x^2\equiv 2\pmod {7^k}$ 不断升幂，那我又能得到什么呢？我甚至能得到 $\sqrt{2}$ 在7-adic下的表示！这可是一件了不起的事情！我们的p进度量可没办法处理无理数啊！在无理数中怎么谈 $v_p(x)$ 这个函数呢？可是无理数就这样能够在p进数中出现了。 实际上这种过程就是一个将有理数域完备化的过程。 设 $x_n$ 是距离空间 $X$ 中的点列，如果对于任意的 $\epsilon&gt;0$，存在自然数 $N$，当 $m,n&gt;N$ 时，$|x_n−x_m|&lt;\epsilon$，称 $\{x_n\}$ 是一个 Cauchy 列。 完备空间或者完备度量空间是具有下述性质的空间：空间中的任何柯西序列都收敛在该空间之内。 有理数集就不是完备的，因为在绝对值度量下， $\sqrt{2}$ 的有限位小数表示 $\{1,1.4,1.41,1.414,1.4142,\cdots\}$ 是一个柯西序列，但是其极限 $\sqrt{2}$ 不在有理数集内；而我们的例子相当于说在7-adic度量下的序列 $\{3, (13)_7, (213)_7\}$ 也是一个柯西序列，但是极限 $\sqrt{2}$ 不在有理数集中。 将不完备集合中添加元素使之完备的过程称为完备化。所有将有理数集按照绝对值完备化，即可得到实数集；而按照p进赋值完备化就得到了p进数。 殊途同归！现在我们可以讨论最开始的定理的意义了。总结一下： 首先，我们定义了一种与绝对值恰恰相反的范数：p进赋值 由此，我们也定义了有理数集的两种不同的距离 然后，我们发现，对于这两种距离，有理数集都不是完备的，都能存在柯西序列，使得序列的极限不在有理数集中。 按照绝对值距离，有理数集拓展为了实数集；按照p进赋值，有理数集完备化为p进数集。 我们上面说有理数集直接就“完备化”了，可是还没说到底怎么趋近一个这样的无理数呢。考虑特殊的情况：对于整系数多项式零点的寻找。正好，相对应的，两种度量方式给出了两种逼近方式： 绝对值度量给出了牛顿迭代法，逐渐使得答案精确的小数点位数增多。 p进度量给出了Hensel引理，逐渐给答案升幂。 因此，解决的问题都相同，解决的方式也相同。在截然不同的两种度量下，它们最终的公式居然能够完全一致，这不得不赞叹数学的魅力了。 注 事实上，在有理数域上定义范数只有上面两种本质不同的不平凡定义方式。这个结论成为奥斯特洛夫斯基定理（Ostrowski’s theorem） 实际上由于p 进数是完备的，甚至可以继续在p进数上定义微积分！ 还未搞清楚的问题 牛顿迭代法的几何意义是切线，可是Hensel引理有没有几何意义呢？ 网上有人说LTE引理（升幂引理）和 p 进数有关系，有什么关系呢？ Hensel定理的代数数论表述如何理解？ 都说p进数集是被实数集所包含的，这是为什么？哪些实数不能被p进估计？ 相关推荐推荐的视频资料： 3blue1brown的视频 （这个在开头已经推荐过了）很清晰易懂，非常有启发性。 Hensel引理与p-adic（youtube） 这个视频专业性更强一些，和本文的内容更是息息相关。这个视频的uploader，Harpreet Bedi 是个专业数学知识的科普作者，他上传的视频往往是有关深刻的数学知识的。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>p-adic</tag>
        <tag>数论</tag>
        <tag>牛顿迭代法</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opentrains 10378 解题报告]]></title>
    <url>%2F2019%2F03%2F06%2FOpentrains-10378-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[XVIII Open Cup named after E.V. Pankratiev. Grand Prix of UralsOverview Status A B C D E F G H I J K L M Contest 0:34 3:56 1:37 —- —- —- 0:23 3:03 —- —- 2:29 —- —- Upsolve OK OK OK AC AC OK OK AC OK TLE AC Attempt +2 +2 +3 *1 *3 +1 +3 *2 + *9 * Total AC 183 131 138 88 45 3 146 120 11 116 139 45 47 比赛链接 Claris的题解 dirt $60\%​$ 啊，还是要提高代码准确性啊。 总览： Solved 6 out of 13 Upsolved 11 out of 13 Rank 108 out of 202 （击败 $46.53\%​$ ） 这场比赛动态规划涉及较多 C是二分加多重背包 D是bitset优化完全背包的dp，比赛时被这道题卡了。 K是一个有趣的构造 L 题状压dp卡常数！ M题必须手写高精度！ 踩过的坑点： A：仅仅有一个环并不构成苹果！WA * 2 B：少判断h之和是否相等。WA * 2 C：数组越界，玄学输出。WA * 3 Prob. A 图的遍历模拟题意即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 120;vector&lt;int&gt; G[maxn];int n, m, fa[maxn], _x, _y, has = false, father[maxn], dep[maxn], deg[maxn];pair&lt;int, int&gt; cyc;int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125;void dfs(int v, int fath) &#123; father[v] = fath; for(auto g : G[v]) &#123; if(g != fath) dfs(g, v), dep[g] = dep[v] + 1; &#125;&#125;int incyc[maxn];int main() &#123; scanf("%d%d", &amp;n, &amp;m); if(n != m) &#123; puts("No"); return 0; &#125; rep(i, n) fa[i] = i; rep(i, m) &#123; scanf("%d%d", &amp;_x, &amp;_y); if(find(_x) == find(_y)) &#123; if(has) &#123; puts("No"); return 0; &#125; else has = true, cyc = &#123;_x, _y&#125;, deg[_x]++, deg[_y]++;; &#125; else &#123; deg[_x]++, deg[_y]++; G[_x].push_back(_y); G[_y].push_back(_x); fa[find(_x)] = find(_y); &#125; &#125; dfs(1, -1); int u = cyc.first, v = cyc.second, cnt = 2; incyc[u] = incyc[v] = 1; while(u != v) &#123; if(dep[u] &gt; dep[v]) swap(u, v); if(dep[u] == dep[v]) &#123; u = father[u]; incyc[u] = 1; cnt++; &#125; if(dep[u] &lt; dep[v]) &#123; v = father[v]; incyc[v] = 1; cnt++; &#125; &#125; if(cnt == n + 1) &#123; puts("No"); return 0; &#125; rep(i, n) if(!incyc[i]) &#123; if(deg[i] &gt; 2) &#123; puts("No"); return 0; &#125; &#125; else &#123; if(deg[i] &gt; 3) &#123; puts("No"); return 0; &#125; &#125; puts("Yes"); return 0;&#125; Prob. B 排序由题意，对于一个图表 $G$ 的一系列区间 $[l_1,r_1-1],[l_2,r_2-1],\cdots,[l_n,r_n-1]​$ ，我们得到的是一系列下面的等式：$$a[l_i,r_i-1] = h_i$$利用前缀和，令 $pre_h[i] = \sum\limits_{j=1}^{i} h[i]$ ， $pre_a[i] = \sum\limits_{j=1}^{i} a[i]$则条件转化为：$$pre_a[r_i-1]=pre_h[i]$$即：针对 $pre_a$ 的一系列等式。把两个图表对应的等式求出，排序，然后判断是否矛盾即可。 注意：必须判断两个图表 $h$ 数组的和相等！当时没注意这一点，然后玄学WA了好久。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 2000;struct lim &#123; int x, ylim; // sum(1, x) = ylim lim(int _x = 0, int _y = 0) : x(_x), ylim(_y) &#123; &#125; bool operator &lt; (const lim&amp; lm) const &#123; return x &lt; lm.x || (x==lm.x &amp;&amp; ylim&lt;lm.ylim); &#125;&#125;;vector&lt;lim&gt; t;int k1, b1, s1, k2, b2, s2, h1[maxn], h2[maxn];int main() &#123; read(k1, b1, s1); rep(i, k1) read(h1[i]); read(k2, b2, s2); rep(i, k2) read(h2[i]); int c1 = b1 - 1, c2 = b2 - 1; t.emplace_back(c1, 0); t.emplace_back(c2, 0); rep(i, k1) &#123; c1 += s1; h1[i] += h1[i - 1]; t.emplace_back(c1, h1[i]); &#125; rep(i, k2) &#123; c2 += s2; h2[i] += h2[i - 1]; t.emplace_back(c2, h2[i]); &#125; if(h1[k1] != h2[k2]) &#123; puts("No"); return 0; &#125; sort(t.begin(), t.end()); int cx = -1000, cy = -1000; for(auto g : t) &#123; if(g.x == cx) &#123; if(g.ylim != cy) &#123; puts("No"); return 0; &#125; continue; &#125; else &#123; if(g.ylim &lt; cy) &#123; puts("No"); return 0; &#125; cy = g.ylim; cx = g.x; &#125; &#125; puts("Yes"); return 0;&#125; Prob. C 二分，多重背包Solution 首先，可以二分答案，将问题变为判定性问题。 这个判定性问题是什么呢？假设我们在检查答案 $x$ ，对于每种物品，有价值 $m_i$，我们可以选择 $0$或$1,\cdots, \lfloor\frac{c_i}{x}\rfloor$个，问能否选出一些物品，使得总价值在区间 $[mn, mx]$ 的范围内。 这个问题就是多重背包问题，只需要使用二进制拆分或者单调队列即可解决。（这里实现的是二进制拆分） 坑点：二分上界 $r$ 别设小了，当时WA了一次。 时间复杂度： $O(10000 \cdot \log (1e6) \cdot \log c)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 55, INF = 0x3f3f3f3f;int n, mn, mx, m[maxn], c[maxn];bool dp[900][20020];inline int lowbit(int x) &#123; return x &amp; (-x); &#125;bool judge(int x) &#123; memset(dp, 0, sizeof dp); dp[0][0] = true; vector&lt;int&gt; weight; weight.push_back(0); for(int i = 1; i &lt;= n; ++i) &#123; int has = c[i] / x; int p = 1; while(has &gt;= p) &#123; has -= p; if(1LL * p * m[i] &gt;= 10000) &#123; p &lt;&lt;= 1; continue; &#125; weight.push_back(p * m[i]); p &lt;&lt;= 1; &#125; if(1LL * has * m[i] &lt;= 10000 &amp;&amp; has) weight.push_back(has * m[i]); &#125; int len = weight.size() - 1; for(int i = 1; i &lt;= len; ++i) &#123; memcpy(dp[i], dp[i - 1], sizeof(dp[i])); for(int j = weight[i]; j &lt;= 10000; ++j) dp[i][j] |= dp[i - 1][j - weight[i]]; &#125; for(int i = mn; i &lt;= mx; ++i) if(dp[len][i]) return true; return false;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;mn, &amp;mx); rep(i, n) scanf("%d%d", &amp;m[i], &amp;c[i]); int l = 0, r = 2000000; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(l == r - 1) mid = r; if(judge(mid)) l = mid; else r = mid - 1; &#125; printf("%d\n", l); return 0;&#125; Prob. G 折半搜索搜一半，放进map；再搜另一半，在map里查询。 Thinking &amp; Code by sl 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#define maxn 20000using namespace std;typedef long long ll;ll n,a,b;ll c[maxn];map&lt;ll,ll&gt; d;ll ans=0;void dfs1(ll i,ll j)&#123; if(i==n/2)&#123;d[j]++;return;&#125; dfs1(i+1,j+c[i]); dfs1(i+1,j);&#125;void dfs2(ll i,ll j)&#123; if(i==n)&#123;ans+=d[-j];return;&#125; dfs2(i+1,j+c[i]); dfs2(i+1,j);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; for(ll i=0;i&lt;n;i++) &#123; ll cnt1,cnt2; cin&gt;&gt;cnt1&gt;&gt;cnt2; c[i]=cnt1*b-cnt2*a; &#125; dfs1(0,0); dfs2(n/2,0) ; cout&lt;&lt;ans-1;&#125; Prob. H 暴力？Thinking &amp; Code By sl，明天再仔细看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;iostream&gt; using namespace std;const int maxn=50000;int n,m,i,j,k,ans[maxn],ask[maxn],b[maxn];vector&lt;int&gt;a[maxn];bool w[67108865+100];inline int get()&#123; static char s[1000]; scanf("%s",s); int t=0,len=strlen(s); for(int i=0;i&lt;len;i++)t|=1&lt;&lt;(s[i]-'a'); return t;&#125;int main()&#123; cin&gt;&gt;n; for(i=1;i&lt;=n;i++)&#123; cin&gt;&gt;k; for(int t=1;t&lt;=k;t++)&#123; int p=get(); a[i].push_back(p); &#125; &#125; for(int i=1;i&lt;=n;i++) ans[i]=1; cin&gt;&gt;m; for(i=1;i&lt;=m;i++)&#123; cin&gt;&gt;k; for(j=1;j&lt;=k;j++)b[j]=get(); for(j=1;j&lt;=k;j++) &#123; for(int i=b[j];i;i=(i-1)&amp;b[j]) w[i]=1; &#125; for(j=1;j&lt;=n;j++)&#123; int t=0; for(int x=0;x&lt;a[j].size();x++) if(w[a[j][x]]) t++; if(t&gt;ask[j])&#123;ask[j]=t;ans[j]=i;&#125; &#125; for(j=1;j&lt;=k;j++) &#123; for(int i=b[j];i;i=(i-1)&amp;b[j])w[i]=0; &#125; &#125; for(i=1;i&lt;=n;i++)printf("%d\n",ans[i]);&#125; Prob. K 构造Description要求你构造一个 $n$ 条边的简单多边形，使得顶点都是整点，且每条边的长度都是整数。（ $n\leq 30$ ） Solution个人认为这道题的构造还是非常精妙的。首先我们构造这样的一个三角形： 我们可以发现，这个三角形是个直角三角形，且三边长都是整数。其斜边中线也是整数。由此，我们可以拼出一列平行四边形，而每个平行四边形四个顶点和中心点都是可以选取的。如下图所示，就展示了九边形的构造方法；类似地可以构造其他情况。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const int maxn = 50;int n;struct Point &#123; int x, y; Point(int _ = 0, int __ = 0): x(_), y(__) &#123; &#125; Point operator + (const Point&amp; pt) const &#123; return Point(x + pt.x, y + pt.y); &#125;&#125;;Point up[maxn], low[maxn], mid[maxn], dev;void print(Point pt) &#123; printf("%d %d\n", pt.x, pt.y);&#125;int main() &#123; scanf("%d", &amp;n); up[0] = Point(-30, 40); mid[0] = Point(33, 56); low[0] = Point(96, 72); dev = Point(96, 72); for(int i = 1; i &lt; 48; ++i) &#123; up[i] = up[i - 1] + dev; mid[i] = mid[i - 1] + dev; low[i] = low[i - 1] + dev; &#125; n -= 2; puts("0 0"); print(up[0]); for(int i = 1; n; ++i) &#123; if(n &gt; 2) &#123; n -= 2; print(mid[i - 1]); print(up[i]); &#125; else if(n == 2) &#123; print(up[i]); print(low[i - 1]); n = 0; &#125; else if(n == 1) &#123; print(low[i - 1]); n = 0; &#125; &#125; return 0;&#125; 赛后补题Prob D. DP, bitsetSolution设计状态为 $dp[w][S][C]$，表示宽为 $w$，面积为 $S$，周长为 $C$ 的情况是否可行。为了构造方案，还需记录转移方案数组 $fa[S][C]$ 表示面积为 $S$，周长为 $C​$ 的时应当选哪一个矩形。 转移就是枚举矩形的长 $l​$ 的过程，注意每一种矩形都可能出现无限次，因此是个完全背包。采用刷表法，那么转移方程就是：$$dp[w-1][S][C] \rightarrow dp[w][S][C] \tag{1}$$ $$dp[w][S][C] \rightarrow dp[w][S+ l\cdot w][C+2\cdot(l+w)] \forall l \in [w,1000] \tag{2}$$在状态转移的过程中更新 $fa$ 数组。但是这么做状态数 $\Theta(\sqrt{S} \cdot S \cdot C)$ ，由于调和级数，转移复杂度均摊下来是 $\Theta(\log n)$ ，总的的复杂度是 $O(\sqrt{S} \cdot S \cdot C \cdot \log S)$ ，无论时间和空间都是比较吃紧的。因此还需要进行优化： 滚动数组。使用滚动数组可以使空间复杂度降至 $S\cdot C$ ，并且使得代码变得更加简洁； bitset优化。注意到转移式 $(2)$ 中对于周长 $C$ 这一维的更新来说， $S,l,w$ 都是确定的，因此这一维只是一个错位意义下的按位或，使用bitset后复杂度除以 $w$ ，可以通过。但是，还有一个问题： $fa$ 数组该如何更新？如果暴力判断哪些状态被更新到，那么复杂度降低的 $w$ 将前功尽弃。实际上，我们用更新后的 bitset异或更新前的，求出哪些位置被更新，然后用bitset自带的_Find_first() 和 _Find_next()函数把这些位置更新，即可继续保持复杂度除以 $w$。这种操作感觉还是第一次在比赛时使用。 下面列出bitset这两个不太常用的函数的一些性质吧：点这里是介绍这两个函数的博客 时间复杂度 $O(\frac nw)$ 如果找不到1，则返回 bitset.size()。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;pii fa[1020][4040];bitset&lt;4040&gt; dp[1020];int main() &#123; dp[0][0] = true; for(int w = 1; w * w &lt;= 1000; ++w) &#123; for(int s = 0; s &lt;= 1000; ++s) &#123; for(int l = w; s + w*l &lt;= 1000; ++l) &#123; auto nb = (dp[s]&lt;&lt;(2*(w+l))) | dp[s+w*l]; auto gg = nb ^ dp[s + w*l]; int p = gg._Find_first(); dp[s + w*l] = nb; while(p != gg.size()) &#123; fa[s + (w * l)][p] = &#123;w, l&#125;; p = gg._Find_next(p); &#125; &#125; &#125; &#125; int T; scanf("%d", &amp;T); while(T--) &#123; int S, C; scanf("%d%d", &amp;S, &amp;C); if(fa[S][C].first == 0) &#123; puts("No"); &#125; else &#123; vector&lt;pii&gt; ans; while(S &amp;&amp; C) &#123; auto g = fa[S][C]; ans.push_back(fa[S][C]); S -= g.first * g.second; C -= (g.first + g.second) * 2; &#125; int sz = ans.size(); puts("Yes"); printf("%d\n", sz); for(int i = 0; i &lt; sz; ++i) printf("%d %d\n", ans[i].first, ans[i].second); &#125; &#125; return 0;&#125; Prob. J 最短路，贪心由于在每个地方都可以进行等待，因此一定是越早到达某个位置越好。预处理出每一时刻走某条边最短花费，然后直接求最短路即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pii;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 2030;const ll INF = 0x3f3f3f3f3f3f3f3fLL;int code(char ch) &#123; if(isupper(ch)) return ch - 'A' + 1; else return ch - 'a' + 1 + 26;&#125;priority_queue&lt; pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq;char str[10], G[maxn][maxn];ll d[maxn], w[66][maxn];ll n, m, s;struct jump &#123; ll a, b, c, d, id; void get(int iid) &#123; id = iid; read(a, b, c, d); memset(w[id], 0x3f, sizeof(w[id])); for(int i = 0; i &lt; c; ++i) &#123; for(int j = 0; j &lt; c; ++j) w[id][i] = min(w[id][i], go(i+j)+j); &#125; &#125; ll go(ll ss) &#123; return ((a * ss + b) % c) + d; &#125;&#125; jp[100];int main() &#123; memset(d, 0x3f, sizeof d); read(n, m, s); for(int i = 1; i &lt;= m; ++i) scanf("%s", str), jp[code(str[0])].get(code(str[0])); rep(i, n) scanf("%s", G[i] + 1); pq.emplace(s, 1); d[1] = s; while(!pq.empty()) &#123; auto tp = pq.top(); pq.pop(); ll no = tp.second, di = tp.first; if(d[no] != di) continue; for(int i = 1; i &lt;= n; ++i) if(G[no][i] != '.') &#123; ll tm = w[code(G[no][i])][di % jp[code(G[no][i])].c]; if(tm + d[no] &lt; d[i]) &#123; d[i] = tm + d[no]; pq.emplace(tm + d[no], i); &#125; &#125; &#125; if(d[n] == INF) puts("-1"); else printf("%lld\n", d[n] - d[1]); return 0;&#125; Prob. E 交互，构造Description一共有六个骰子，每个骰子每一面上都有一个字符串，你可以选择一个骰子进行投掷，系统会随机返回这一次投掷的结果，然后你需要把投掷结果的字符串合理拼接，组成一个合法的恒成立的式子。（你最多可以投掷 $1000$ 次） 这六个骰子的描述如下： Type 1: = &lt; &gt; != &lt;= &gt;= Type 2: 4 + - ( ( ) Type 3: 0 / / / 8 + Type 4: 2 3 4 5 - ) Type 5: + - * / 1 9 Type 6: 6 7 + - ( ) Solution每个询问到的字符都必须用到，这个条件有些棘手。很容易想到利用 $0\cdot x=0$ 的性质，可是怎么用呢？这要根据比较运算的不同分类讨论。我们有下面的策略： 首先问出两个0，一个2，”+”, “-“, “*” 符号各问出一个。 然后不断询问第二个骰子和第四个骰子，保证以下两个条件均满足： 首先，括号至少出现一对，并且左右括号数量相等 其次，非零数字的出现次数比运算符的出现次数多不少于5次 如果这两点满足了，那么我们这样构造方案： 首先确定比较运算符的左边，如果运算符是”&gt;”，则让左边是0+2；如果是”&lt;”或”!=”，则让左边是0-2。 然后右边是类似 0*(()) 的形式。右边括号里的数只需要在剩下的数字中插入没用完的运算符即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;map&lt;string, int&gt; cnt;string goal;int nzcount() &#123; int ret = 0; for(char ch = '1'; ch &lt;= '9'; ++ch) &#123; string s = ""; s += ch; ret += cnt[s]; &#125; return ret;&#125;int sgncount() &#123; return cnt["+"] + cnt["-"] + cnt["*"] + cnt["/"];&#125;string query(int tp) &#123; cout &lt;&lt; tp &lt;&lt; '\n'; cout.flush(); string ret; cin &gt;&gt; ret; cnt[ret]++; return ret;&#125;bool Try(string s) &#123; if(cnt[s] &gt; 0) &#123; cout &lt;&lt; s; cnt[s]--; return true; &#125; else return false;&#125;int main() &#123; goal = query(1); while(cnt["0"] &lt; 2) query(3); while(cnt["2"] == 0 || cnt["-"] == 0) query(4); while(cnt["*"] == 0 || cnt["+"] == 0) query(5); bool c = true; while(c) &#123; c = false; while(nzcount() &lt; sgncount() + 5 || cnt[")"] &lt; cnt["("]) &#123; query(4); c = true; &#125; while(cnt["("] &lt; cnt[")"] || cnt["("] == 0 || cnt[")"] == 0) &#123; query(2); c = true; &#125; &#125; printf("0 "); assert(Try("0")); if(goal == "&gt;") &#123; Try("+"); Try("2"); &#125; else if(goal == "&lt;" || goal == "!=") &#123; Try("-"); Try("2"); &#125; assert(Try(goal)); assert(Try("0")); assert(Try("*")); while(Try("(")) continue; while(sgncount() + nzcount()) &#123; for(int i = 1; i &lt;= 9; ++i) if(Try(to_string(i))) break; if(Try("+") || Try("-") || Try("*") || Try("/")) continue; &#125; while(Try(")")) continue; cout &lt;&lt; "\n"; cout.flush(); return 0;&#125; Prob. L 状压dp，卡常数Solution首先，同一行或同一列边界上如果是箱子，且字母不同，则会使答案加倍；把这些加倍的因子处理出来，我们就可以把箱子视作相同了。 令 $dp[row][col][mask][k]$ 表示考虑到第 $row$ 行，第 $col$ 列，第 $i$ 列剩余未填数量为 $mask$ 三进制表示下第 $i$ 位，第 $row$ 行还剩 $k$ 个没有填，则枚举在这一个的行动即可转移。 必须使用滚动数组优化内存，而这样的复杂度是 $O(n^2 3^{n+1})$ 的，实际上还是会TLE on test 20。。。所以我哕了。Claris的代码也会TLE。 Code这份代码会TLE on test 20。。。也没招了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#pragma GCC optimize("-O3", "-Ofast", "-finline", "-funroll-loops")#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;char s[20][20];int n, m, rc[20], cc[20];ll p3[30];int bin[1600000];ll ans, dp[2][1600000][3], fac = 1, msk, full;int get(int tri, int pos) &#123; return tri / p3[pos] % 3; &#125;void precalc() &#123; p3[0] = 1; for(int i = 1; i &lt;= 23; ++i) p3[i] = p3[i - 1] * 3LL; for(int i = 1; i &lt; p3[13]; ++i) bin[i] = (bin[i / 3] &lt;&lt; 1) + (i % 3 != 0);&#125;int main() &#123; precalc(); scanf("%d", &amp;n); m = n + 2, full = p3[n]; for(int i = 0; i &lt; m; ++i) scanf("%s", s[i]); auto check = [&amp;](char a, char b) &#123; if(a != '#' &amp;&amp; b != '#' &amp;&amp; a != b) fac &lt;&lt;= 1; &#125;; for(int i = 1; i &lt;= n; ++i) &#123; check(s[0][i], s[m-1][i]); check(s[i][0], s[i][m-1]); cc[i] += (s[0][i] != '#') + (s[m-1][i] != '#'); rc[i] += (s[i][0] != '#') + (s[i][m-1] != '#'); msk += p3[i-1] * (cc[i]); &#125; dp[0][msk][0] = fac; bool e = false; for(int row = 1; row &lt;= n; ++row) &#123; memset(dp[e ^ 1], 0, sizeof (dp[e ^ 1][0]) * (msk + 3)); e ^= 1; int rrr = rc[row]; for(int S = 0; S &lt;= msk; ++S) dp[e][S][rrr] = dp[e^1][S][0]; for(int col = 0; col &lt; n; ++col) if(s[row][col+1] == '.') &#123; memset(dp[e ^ 1], 0, sizeof (dp[e ^ 1][0]) * (msk + 3)); for(int S = 0; S &lt;= msk; ++S) &#123; ll* now = dp[e][S], *gg = dp[e^1][S]; if(rrr==1) gg[0] += now[1]; else if(rrr==2) &#123; gg[0] += now[1]; gg[1] += now[2]; &#125; if(bin[S] &gt;&gt; col &amp; 1) &#123; gg = dp[e^1][S-p3[col]]; if(rrr==0) gg[0] += now[0]; else if(rrr==1) &#123; gg[0] += now[0]; gg[1] += now[1]; &#125; else if(rrr == 2) &#123; gg[0] += now[0]; gg[1] += now[1]; gg[2] += now[2]; &#125; &#125; &#125; e ^= 1; &#125; &#125; printf("%lld\n", dp[e][0][0]); return 0;&#125; Prob. M 高精度，树dp显然的树dp。。。但要用高精度就很烦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ll;typedef __int128 lll;const int N = 10000010, M = 50;const ll MO = 1000000000000000000ULL;int n, i;char a[N];struct P&#123; ll v[3]; P() &#123; v[0] = v[1] = v[2] = 0; &#125; P operator+(int b) &#123; P c; for (int i = 0; i &lt; 3; i++) c.v[i] = v[i]; c.v[0] += b; for (int i = 0; i &lt; 2; i++) if (c.v[i] &gt;= MO) &#123; c.v[i + 1] += c.v[i] / MO; c.v[i] -= MO; &#125; return c; &#125; P operator+(const P &amp;b) &#123; P c; for (int i = 0; i &lt; 3; i++) c.v[i] = v[i] + b.v[i]; for (int i = 0; i &lt; 2; i++) if (c.v[i] &gt;= MO) &#123; c.v[i + 1] += c.v[i] / MO; c.v[i] -= MO; &#125; return c; &#125; P operator*(int b) &#123; P c; for (int i = 0; i &lt; 3; i++) c.v[i] = v[i] * b; for (int i = 0; i &lt; 2; i++) c.v[i + 1] += c.v[i] / MO, c.v[i] %= MO; c.v[2] %= MO; return c; &#125; P operator*(const P &amp;b) &#123; P c; static lll f[3]; f[0] = f[1] = f[2] = 0; for (int i = 0; i &lt; 3; i++) if (v[i]) for (int j = 0; i + j &lt; 3; j++) if (b.v[j]) f[i + j] += (lll)v[i] * b.v[j]; for (int i = 0; i &lt; 2; i++) if (f[i] &gt;= MO) f[i + 1] += f[i] / MO, f[i] %= MO; if (f[2] &gt;= MO) f[2] %= MO; for (int i = 0; i &lt; 3; i++) c.v[i] = f[i]; return c; &#125; void up(const P &amp;b) &#123; //max= int i; for (i = 2; ~i; i--) if (b.v[i] != v[i]) break; if (i &lt; 0) return; if (b.v[i] &lt; v[i]) return; for (i = 0; i &lt; 3; i++) v[i] = b.v[i]; &#125; void write() &#123; int i = 2; while (i &amp;&amp; !v[i]) i--; printf("%llu", v[i]); for (int j = i - 1; ~j; j--) printf("%018llu", v[j]); puts(""); &#125;&#125; f[M], g[M], p[M], ans, ff, gg, mx[M];int d[M];unsigned int seed, base;void dfs(int x, int k)&#123; f[k] = g[k] = mx[k] = P(); d[k] = 0; for (int i = 0; i &lt; 2; i++) &#123; int y = x &lt;&lt; 1 | i; if (y &gt; n) continue; dfs(y, k + 1); ff = (f[k + 1] * 10) + ((int)a[y]); gg = g[k + 1] + (p[d[k + 1]] * ((int)a[y])); mx[k].up((ff * p[d[k]]) + g[k]); mx[k].up((f[k] * p[d[k + 1] + 1]) + gg); f[k].up(ff); g[k].up(gg); d[k] = max(d[k], d[k + 1] + 1); &#125; ans = ans + mx[k];&#125;int main()&#123; scanf("%d%u", &amp;n, &amp;seed); base = (1U &lt;&lt; 31) - 1; p[0].v[0] = 1; for (i = 1; i &lt; M; i++) p[i] = p[i - 1] * 10; for (i = 1; i &lt;= n; i++) &#123; a[i] = ((seed &amp; base) &gt;&gt; 16) % 9 + 1; seed = seed * 1103515245 + 12345; &#125; dfs(1, 0); ans.write();&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>构造</tag>
        <tag>状压dp</tag>
        <tag>Opentrains</tag>
        <tag>暴力</tag>
        <tag>背包问题</tag>
        <tag>最短路</tag>
        <tag>bitset</tag>
        <tag>折半搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码模板库]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E5%BA%93%2F</url>
    <content type="text"><![CDATA[常用算法的模板~ 对拍传统题对拍Python: 123456789101112131415161718192021from time import timefrom os import systemdef run(cmd, msg): start = time() ret = system(cmd) if ret != 0: print("RUNTIME ERROR!") exit(0) duration = (time() - start) * 1000.0 print("&#123;&#125; ms elapsed (&#123;&#125;)".format(duration, msg))for test in range(1000): run('python igen.py &gt; in.txt', "generator") run('irel &lt; in.txt &gt; out.txt', "my program") run('iac &lt; in.txt &gt; outac.txt', "std program") if system("fc out.txt outac.txt &gt; fc.log"): print("Wrong answer on test &#123;&#125;\n".format(test + 1)) exit(0) else: print("Accepted on test &#123;&#125;\n".format(test + 1)) Windows 批处理： 12345678910111213@echo offset /a tst = 1:againgen &gt; in.txtaac &lt; in.txt &gt; outac.txta &lt; in.txt &gt; out.txtfc out.txt outac.txt &gt; fc.logif errorlevel 1 (echo Wrong Answer) else ( echo Accepted on test %tst% set /a tst = %tst% + 1 if %tst% LEQ 100 goto again else echo Pretests Passed)echo Pretests Passed 交互题双线程对拍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# This is a small program that runs two processes two processes, connecting the# stdin of each one to the stdout of the other.# It doesn't perform a lot of checking, so many errors may# be caught internally by Python (e.g., if your command line has incorrect# syntax) or not caught at all (e.g., if the judge or solution hangs).## Run this as:# python interactive_runner.py &lt;cmd_line_judge&gt; -- &lt;cmd_line_solution&gt;## For example:# python interactive_runner.py python judge.py 0 -- ./my_binary## This will run the first test set of a python judge called "judge.py" that# receives the test set number (starting from 0) via command line parameter# with a solution compiled into a binary called "my_binary".## This is only intended as a convenient tool to help contestants test solutions# locally. In particular, it is not identical to the implementation on our# server, which is more complex.from __future__ import print_functionimport sys, subprocess, threadingclass SubprocessThread(threading.Thread): def __init__(self, args, stdin_pipe=subprocess.PIPE, stdout_pipe=subprocess.PIPE, stderr_pipe=subprocess.PIPE): threading.Thread.__init__(self) self.p = subprocess.Popen( args, stdin=stdin_pipe, stdout=stdout_pipe, stderr=stderr_pipe) def run(self): try: self.return_code = self.p.wait() self.stdout = "" if self.p.stdout is None else self.p.stdout.read() self.stderr = "" if self.p.stderr is None else self.p.stderr.read() except (SystemError, OSError): self.return_code = -1 self.stdout = "" self.stderr = "The process crashed or produced too much output."assert sys.argv.count("--") == 1, ( "There should be exactly one instance of '--' in the command line.")sep_index = sys.argv.index("--")judge_args = sys.argv[1:sep_index]sol_args = sys.argv[sep_index + 1:]t_sol = SubprocessThread(sol_args)t_judge = SubprocessThread(judge_args, stdin_pipe=t_sol.p.stdout, stdout_pipe=t_sol.p.stdin)t_sol.start()t_judge.start()t_sol.join()t_judge.join()print("Judge return code:", t_judge.return_code)print("Judge standard error:", t_judge.stderr.decode())print("Solution return code:", t_sol.return_code)print("Solution standard error:", t_sol.stderr.decode()) 字符串后缀数据结构后缀数组[2019.3.5] 后缀数组每个元素 $SA[i]$ 表示字典序第 $i$ 大的后缀， $rk[i]$ 表示后缀 $i$ 的排名。（都从1开始） 高度数组 $height[i]$ 表示后缀编号 $SA[i-1]$ 与后缀编号 $SA[i]$ 的 $ lcp$ 。 任意两个后缀的 lcp: $lcp(i, j) = RMQ(height, rk[i + 1], rk[j])$，即在 $height$ 数组中求得下标区间 $\big[rk[i+1],rk[j]\big]$ 中的最小元素值。 下面实现的是倍增法，在 $O(n\log n)$ 时间内求得SA。 注意字符集下标必须从1开始！！ 空间别忘记开两倍，字符数组后一半必须都是0！！ 注意抄模版时别把基数排序中的数组张冠李戴！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const int maxn = 1002000;char str[maxn];int n, a[maxn &lt;&lt; 1];int sa[maxn &lt;&lt; 1], rk[maxn &lt;&lt; 1], height[maxn &lt;&lt; 1];int xx[maxn &lt;&lt; 1], yy[maxn &lt;&lt; 1], c[maxn &lt;&lt; 1];bool cmp(int x, int y, int k) &#123; return yy[x]==yy[y] &amp;&amp; yy[x+k]==yy[y+k]; &#125;void build_sa(int* s, int n, int sz) &#123; // [1, sz] memset(c, 0, sizeof(int) * (sz + 10)); for(int i = 1; i &lt;= n; ++i) c[xx[i] = s[i]]++; for(int i = 1; i &lt;= sz;++i) c[i] += c[i - 1]; for(int i = n ; i ; --i) sa[c[xx[i]]--] = i; for(int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for(int i = n - k + 1; i &lt;= n; ++i) yy[++p] = i; for(int i = 1; i &lt;= n; ++i) if(sa[i] &gt; k) yy[++p] = sa[i] - k; memset(c, 0, sizeof(int) * (sz + 10)); for(int i = 1; i &lt;= n; ++i) c[xx[yy[i]]]++; for(int i = 1; i &lt;= sz; ++i) c[i] += c[i - 1]; for(int i = n; i ; --i) sa[c[xx[yy[i]]]--] = yy[i]; swap(xx, yy); p = xx[sa[1]] = 1; for(int i = 2; i &lt;= n; ++i) xx[sa[i]] = cmp(sa[i], sa[i-1], k) ? p : ++p; if(p &gt;= n) break; else sz = p; &#125; for(int i = 1; i &lt;= n; ++i) rk[sa[i]] = i; for(int i = 1, p = 0; i &lt;= n; ++i) &#123; if(p) --p; while(s[i + p] == s[sa[rk[i] - 1] + p]) p++; height[rk[i]] = p; &#125; // Sample test: aabaaaab // answer: 4 5 6 1 7 2 8 3 | 3 2 3 1 2 0 1 // Sample test: ababa // answer: 5 3 1 4 2 | 1 3 0 2&#125;int main() &#123; #ifdef FREOPEN freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); #endif scanf("%s", str + 1); n = strlen(str + 1); rep(i, n) a[i] = str[i] - 'a' + 1; build_sa(a, n, 150); rep(i, n) printf("%d%c", sa[i], " \n"[i == n]); for(int i = 2; i &lt;= n; ++i) printf("%d%c", height[i], " \n"[i == n]); return 0;&#125; 后缀自动机[2019.3.5] 这里以 洛谷3804 为例，题意是求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值，即：$$\max _{1\leq l\leq r\leq n} (r-l+1) \cdot occ(S[l,r])$$后缀自动机上每个节点的 $right$ 集合的大小就是这个 $right$ 等价类中任何一个字符串的出现次数。由此在parent树上$dp$，令后缀节点的 $dp$ 值为 $1$，其他节点的 $dp$ 值为其儿子的 $dp$ 值之和，由此求出各个节点 $right$ 集合大小即可。 有几个可以优化的地方： 后缀自动机parent树上dp需要进行拓扑排序，可以直接按照长度计数排序，先算长度长的。 最好不要使用指针来实现后缀自动机。这是因为 $64$ 位系统上指针占用的空间为 $64$ 字节，很可能会MLE！ 坑点： 注意这里定义 $nullptr$ 为 $-1$，不要和根节点 $root=0$ 搞混！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const int maxn = 2002000;struct state &#123; int go[26], par, len, sz; state() &#123; memset(go, -1, sizeof go); par = -1; &#125;&#125; sam[maxn];int last = 0, root = 0, tot = 0;void insert(int w) &#123; int np = ++tot; sam[np].len = sam[last].len + 1; sam[np].sz = 1; int p = last; while(p != -1 &amp;&amp; sam[p].go[w] == -1) sam[p].go[w] = np, p = sam[p].par; if(p == -1) sam[np].par = root; else &#123; int q = sam[p].go[w]; if(sam[q].len == sam[p].len + 1) &#123; sam[np].par = q; &#125; else &#123; sam[++tot].par = sam[q].par; memcpy(sam[tot].go, sam[q].go, sizeof sam[tot].go); sam[tot].len = sam[p].len + 1; sam[q].par = tot; sam[np].par = tot; while(p != -1 &amp;&amp; sam[p].go[w] == q) sam[p].go[w] = tot, p = sam[p].par; &#125; &#125; last = np; // Sample: baa (2) // Sample: aabaaaba (8) // Sample: aaaa (6)&#125;char str[maxn];int n, c[maxn], a[maxn];int main() &#123; scanf("%s", str); n = strlen(str); for(int i = 0; i &lt; n; ++i) insert(str[i] - 'a'); rep(i, tot) c[sam[i].len]++; rep(i, n) c[i] += c[i - 1]; for(int i = tot; i; --i) a[c[sam[i].len]--] = i; for(int i = tot; i ; --i) sam[sam[a[i]].par].sz += sam[a[i]].sz; ll ans = 0; for(int i = tot; i ; --i) if(sam[i].sz &gt; 1) ans = max(ans, 1LL * sam[i].sz * sam[i].len); printf("%lld\n", ans); return 0;&#125; 数学结论集锦线段随机 $n-1$ 个点第 $k$ 短线段的期望长度在一个长度为 $1$ 的线段上随机撒 $n-1$ 个点，形成了 $n$ 条线段，那么这 $n$ 条线段中第 $k$ 短（$k\leq n$）的线段期望长度就是：$$\frac 1n \sum_{i=0}^{k-1} \frac 1{n-i}$$例如， $n$ 条线段中最短的线段期望长度是 $\frac 1 {n^2}$，第二短的期望是 $\frac 1n (\frac 1n + \frac 1{n-1})$ ，依此类推。 Comet OJ contest #0 F. 几何结论题目链接 对于给出 $n$ 条边长，要摆出非退化 $n$ 边形的问题， $n$ 边形存在的条件是:$$\sum_{i=1}^n a_i &gt; 2 \times \max_{1\leq i\leq n}a_i$$而要使这个 $n$ 边形面积最大，那么一定有组成的 $n$ 边形是凸多边形，且是圆内接多边形，因此这个多边形的边的顺序也是可以随意调换的。这个圆形的半径同样也是唯一确定的，可以使用二分搜索来查找。 而这个二分搜索也是需要有一定技巧的。要分为多边形通过圆心和不通过圆心两类进行讨论。 下面的代码输入边长序列 $e$（要求有序，从小到大），返回能产生的最大凸多边形面积。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647long double FindMaxAreaPolygon(vector&lt;int&gt; e) &#123; int tot = 0, sz = e.size(); for(int i = 0; i &lt; n; ++i) if(state &gt;&gt; i &amp; 1) &#123; e.push_back(a[i]); tot += a[i]; &#125; sz = e.size(); if(tot &lt;= e.back() * 2) &#123; valid[state] = false; return 0.0L; &#125; valid[state] = true; bool half = false; auto TooLarge = [&amp;](long double R) -&gt; bool &#123; long double theta = 0.0L, f = R*R*2.0L; for(int i = 0; i &lt; sz - 1; ++i) theta += acos((f - 1.0L*e[i]*e[i]) / f); long double last = acos((f - 1.0L*e[sz-1]*e[sz-1]) / f); if(theta &lt;= PI) &#123; half = true; return theta - last &gt; 0.0L; &#125; else &#123; half = false; return theta + last &lt; 2.0L * PI; &#125; &#125;; long double l = (long double)e.back() / 2.0L, r = 10000; rep(i, 100) &#123; long double mid = (l + r) / 2.0L; if(TooLarge(mid)) r = mid; else l = mid; &#125; TooLarge(r); long double sq = 0.0L; for(int i = 0; i &lt; sz; ++i) &#123; long double p = (r + r + e[i]) / 2.0L; long double triangle = sqrtl(p * (p-e[i])) * (p-r); if(i == sz - 1 &amp;&amp; half) sq -= triangle; else sq += triangle; &#125; return sq;&#125; 数论取模运算两套操作 第一套是实现了一个有限域的类，适合于可以粘贴代码的比赛，写起公式来比较爽： 12345678910111213141516171819202122232425262728293031323334353637383940#define Type intnamespace ModOp &#123; Type MOD; inline Type mo(Type x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125; struct MF &#123; Type v; MF(Type x = 0): v(mo(x)) &#123; &#125; operator Type() &#123; return v; &#125; MF operator + (const MF&amp; f) const &#123; return mo(v + f.v); &#125; MF operator - (const MF&amp; f) const &#123; return mo(v - f.v); &#125; MF operator * (const MF&amp; f) const &#123; return 1LL * v * f.v % MOD; &#125; MF operator / (const MF&amp; f) const &#123; return v / f.v; &#125; MF operator - () const &#123; return MOD - v; &#125; MF operator &gt;&gt; (int idx) const &#123; return v &gt;&gt; idx; &#125; MF operator &lt;&lt; (int idx) const &#123; return v &lt;&lt; idx; &#125; bool operator == (const MF&amp; f) const &#123; return v == f.v; &#125; bool operator != (const MF&amp; f) const &#123; return v != f.v; &#125; bool operator &gt; (const MF&amp; f) const &#123; return v &gt; f.v; &#125; bool operator &lt; (const MF&amp; f) const &#123; return v &lt; f.v; &#125; bool operator &gt;= (const MF&amp; f) const &#123; return v &gt;= f.v; &#125; bool operator &lt;= (const MF&amp; f) const &#123; return v &lt;= f.v; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; out, MF f) &#123; return out &lt;&lt; f.v; &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, MF f) &#123; return in &gt;&gt; f.v; &#125; bool scan() &#123; return scanf("%d", &amp;v) != -1; &#125; void print() &#123; printf("%d", v); &#125; &#125;;&#125;#undef Typetemplate&lt;typename T&gt; T qpow(T x, int y) &#123; T ret = T(1); for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) ret = ret * x; return ret;&#125;using ModOp::MF; 第二类：即把加法乘法写成函数形式。 12 二次剩余[2019.3.18] 相关定理雅克比符号使用高斯二次互反律进行，又是一种类欧几里得算法，复杂度 $O(\log \min \{a,n\})$ 。 Accepted on HDU3589 12345678910int Jacobi(int a, int n) &#123; a %= n; if(a == 0 || (a%2==0 &amp;&amp; n%2==0)) return 0; if(a == 1) return 1; if(a == 2) return (((n&amp;7) == 1) || ((n&amp;7) == 7)) ? 1 : -1; if((a &amp; 1) == 0) return Jacobi(2, n) * Jacobi(a / 2, n); if(n % 2 == 0) return Jacobi(a, 2) * Jacobi(a, n / 2); int sgn = ((a - 1) / 2 * (n - 1) / 2) &amp; 1; return Jacobi(n, a) * (sgn ? -1 : 1);&#125; 二次剩余的构造Legendre符号：使用欧拉判别法计算 使用Cipolla算法构造二次剩余，ans1, ans2为答案。 Accepted on Timus 1132 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define Type intnamespace ModOp &#123; Type MOD; inline Type mo(Type x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125; struct MF &#123; Type v; MF(Type x = 0): v(mo(x)) &#123; &#125; operator Type() &#123; return v; &#125; MF operator + (const MF&amp; f) const &#123; return mo(v + f.v); &#125; MF operator - (const MF&amp; f) const &#123; return mo(v - f.v); &#125; MF operator * (const MF&amp; f) const &#123; return 1LL * v * f.v % MOD; &#125; MF operator / (const MF&amp; f) const &#123; return v / f.v; &#125; MF operator - () const &#123; return MOD - v; &#125; MF operator &gt;&gt; (int idx) const &#123; return v &gt;&gt; idx; &#125; MF operator &lt;&lt; (int idx) const &#123; return v &lt;&lt; idx; &#125; bool operator == (const MF&amp; f) const &#123; return v == f.v; &#125; bool operator != (const MF&amp; f) const &#123; return v != f.v; &#125; bool operator &gt; (const MF&amp; f) const &#123; return v &gt; f.v; &#125; bool operator &lt; (const MF&amp; f) const &#123; return v &lt; f.v; &#125; bool operator &gt;= (const MF&amp; f) const &#123; return v &gt;= f.v; &#125; bool operator &lt;= (const MF&amp; f) const &#123; return v &lt;= f.v; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; out, MF f) &#123; return out &lt;&lt; f.v; &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, MF f) &#123; return in &gt;&gt; f.v; &#125; bool scan() &#123; return scanf("%d", &amp;v) != -1; &#125; void print() &#123; printf("%d", v); &#125; &#125;;&#125;#undef Typetemplate&lt;typename T&gt; T qpow(T x, int y) &#123; T ret = T(1); for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) ret = ret * x; return ret;&#125;using ModOp::MF;namespace qres &#123; MF a, n; int p; struct F &#123; MF x, y; // x+yw F(MF _a = 0, MF _b = 0): x(_a), y(_b) &#123; &#125; F operator + (F f2) const &#123; return F(x + f2.x, y + f2.y); &#125; F operator * (F f2) const &#123; return F(x*f2.x + y*f2.y*(a*a-n), x*f2.y+y*f2.x); &#125; &#125;; MF Legendre(MF d) &#123; return qpow(d, (p-1)/2); &#125; void Cipolla(int qn, int qp) &#123; // p is a prime, gcd(n, p) = 1 qn %= qp; if(qp == 2 &amp;&amp; qn == 1) &#123; puts("1"); return; &#125; ModOp::MOD = p = qp; n = qn; if(Legendre(n) != MF(1)) &#123; puts("No root"); return; &#125; a = rng() % p; while(Legendre(a * a - n) != MF(-1)) a = rng() % p; F w(a, 1), res = qpow(w, (p + 1) / 2); MF ans = res.x, ans2 = -ans; if(ans &gt; ans2) swap(ans, ans2); cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; "\n"; &#125;&#125; 置换置换（permutation）是从 $\{1,2,3,\cdots,n\}$ 到 $\{1,2,3,\cdots,n\}$ 的双射。下面的模板支持以下操作： identity() 将置换变为恒等置换，即 $f(i)\equiv i$ 置换的复合。直接使用乘法即可。这里注意， $f \circ g$ 和函数复合一样，是从右往左算的，即： $(f \circ g)[i]=f[g[i]]$ 。 逆置换 置换分解为循环，并输出这个置换的阶，即 $f^d = id$ 的最小正整数 $d$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct permutation &#123; int sz; vector&lt;int&gt; a; permutation(int N = 0): sz(N), a(N + 10) &#123; &#125; inline void identity() &#123; for(int i = 1; i &lt;= sz; ++i) a[i] = i; &#125; inline void show(const char * msg) &#123; printf("%s", msg); for(int i = 1; i &lt;= sz; ++i) &#123; printf("%d", a[i]); if(i &lt; sz) putchar(' '); &#125; &#125; int&amp; operator [] (int idx) &#123; return a[idx]; &#125; permutation operator * (permutation rhs) &#123; permutation res(sz); for(int i = 1; i &lt;= sz; ++i) res[i] = a[rhs[i]]; return res; &#125; bool check() &#123; vector&lt;int&gt; _vis(sz + 3, 0); rep(i, sz) _vis[a[i]] = true; rep(i, sz) if(!_vis[i]) &#123; puts("NO!NOT A PERMUTATION!"); return false; &#125; return true; &#125; ll decomp() &#123; vector&lt;int&gt; _vis(sz + 3, 0); ll ans = -1; for(int i = 1; i &lt;= sz; ++i) if(!_vis[i]) &#123; ll len = 0, c = i; while(!_vis[c]) &#123; _vis[c] = true; len++; c = a[c]; &#125; if(ans == -1) ans = len; else ans = ans * (len / __gcd(ans, len)); &#125; return ans; &#125; permutation inverse() &#123; permutation rev(sz); rep(i, sz) rev[a[i]] = i; return rev; &#125;&#125;; 快速傅里叶变换注意检查FFT_MAXN是否够用！ 12345678910111213141516171819202122232425262728293031323334353637383940414243const int FFT_MAXN = 4002000; // multiply by 4!!const double Pi = 3.1415926535897932384626;struct comp &#123; double re, im; comp(double x = 0.0, double y = 0.0): re(x), im(y) &#123; &#125; comp operator + (const comp&amp; c) &#123; return comp(re+c.re, im+c.im); &#125; comp operator - (const comp&amp; c) &#123; return comp(re-c.re, im-c.im); &#125; comp operator * (const comp&amp; c) &#123; return comp(re*c.re-im*c.im, re*c.im+im*c.re); &#125; comp operator / (double dev) &#123; return comp(re / dev, im / dev); &#125;&#125; a[FFT_MAXN], b[FFT_MAXN];int n, m, lim = 1, l = 0, r[FFT_MAXN];void fft(comp* a, int dft) &#123; // -1 for idft, 1 for dft for(int i = 0; i &lt; lim; ++i) if(i &lt; r[i]) swap(a[i], a[r[i]]); for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; comp wn = comp( cos(Pi / mid), sin(Pi / mid) * dft ); for(int len = mid &lt;&lt; 1, s = 0; s &lt; lim; s += len) &#123; comp w(1, 0); for(int k = 0; k &lt; mid; ++k, w = w * wn) &#123; comp x = a[s + k], y = w * a[s + k + mid]; a[s + k] = x + y; a[s + k + mid] = x - y; &#125; &#125; &#125; if(dft == -1) for(int i = 0; i &lt; lim; ++i) a[i] = a[i] / lim;&#125;void fft_init(int degA, int degB) &#123; lim = 1, l = 0; while(lim &lt;= degA + degB) lim &lt;&lt;= 1, l++; for(int i = 0; i &lt; lim; ++i) r[i] = ( r[i &gt;&gt; 1] &gt;&gt; 1 ) | ( (i &amp; 1) &lt;&lt; (l - 1) );&#125;void fft_pmul(comp *A, int degA, comp *B, int degB) &#123; // A will be modified to get answer fft_init(degA, degB); fft(A, 1); fft(B, 1); for(int i = 0; i &lt; lim; ++i) A[i] = A[i] * B[i]; fft(A, -1);&#125; 快速数论变换NTT1234567891011121314151617181920212223242526272829303132333435363738394041424344const int MOD = 998244353, g = 3, ginv = 332748118;inline int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;inline int mo(int x) &#123; while(x &gt;= MOD) x -= MOD; while(x &lt; 0) x += MOD; return x; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;inline int inv(int x) &#123; return qpow(x, MOD - 2); &#125;const int FFT_MAXN = 4004000;int l, r[FFT_MAXN], a[FFT_MAXN], b[FFT_MAXN], n, m, lim, liminv;void ntt(int* a, int dft) &#123; // 1 for dft and -1 for idft for(int i = 0; i &lt; lim; ++i) if(i &lt; r[i]) swap(a[i], a[r[i]]); for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; int wn = qpow(dft==1 ? g : ginv, (MOD-1) / (mid &lt;&lt; 1)); for(int len = mid &lt;&lt; 1, j = 0; j &lt; lim; j += len) &#123; int w = 1; for(int k = 0; k &lt; mid; ++k, w = muln(w, wn)) &#123; int x = a[j + k], y = muln(w, a[j + k + mid]); a[j + k] = mo(x + y); a[j + k + mid] = mo(x - y); &#125; &#125; &#125; if(dft == -1) for(int i = 0; i &lt; lim; ++i) a[i] = muln(a[i], liminv);&#125;void ntt_init(int degA, int degB) &#123; lim = 1, l = 0; while(lim &lt;= degA + degB) lim &lt;&lt;= 1, l++; liminv = inv(lim); for(int i = 0; i &lt; lim; ++i) r[i] = ( r[i&gt;&gt;1] &gt;&gt; 1 ) | ( (i&amp;1) &lt;&lt; (l-1) );&#125;void ntt_pmul(int *A, int degA, int *B, int degB) &#123; ntt_init(degA, degB); ntt(A, 1); ntt(B, 1); for(int i = 0; i &lt; lim; ++i) A[i] = muln(A[i], B[i]); ntt(A, -1);&#125; 快速沃尔什变换/快速莫比乌斯变换conv 函数配合 fmt_or fmt_and fwt_xor 参数解决下面的问题：$$h(S) = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\oplus R = S] f(L)g(R)$$ $$h(S) = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cup R = S] f(L)g(R)$$ $$h(S) = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cap R = S] f(L)g(R)$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxs = (1 &lt;&lt; 17) + 20;const int MOD = 998244353;inline int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int n, m; // ensure m is calculated!!!!vector&lt;int&gt; a, b, Or, And, Xor;inline int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;vector&lt;int&gt; fmt_or(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) A[S|(1&lt;&lt;i)] = mo(A[S|(1&lt;&lt;i)] + dmt*A[S]); return A;&#125;vector&lt;int&gt; fmt_and(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) A[S] = mo(A[S] + dmt*A[S|(1&lt;&lt;i)]); return A;&#125;vector&lt;int&gt; fwt_xor(vector&lt;int&gt; A, int dmt = 1) &#123; int l, r; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = A[S], r = A[S|(1&lt;&lt;i)]; A[S] = mo(l + r); A[S|(1&lt;&lt;i)] = mo(l - r); &#125; if(dmt==-1) &#123; int inv2 = qpow(qpow(2, MOD-2), n); for(int S = 0; S &lt; m; ++S) A[S] = muln(A[S], inv2); &#125; return A;&#125;vector&lt;int&gt; conv(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B, vector&lt;int&gt;(*fn)(vector&lt;int&gt;,int)) &#123; vector&lt;int&gt; aa = fn(A, 1), bb = fn(B, 1); for(int i = 0; i &lt; m; ++i) aa[i] = muln(aa[i], bb[i]); aa = fn(aa, -1); return aa;&#125;void show(vector&lt;int&gt; v) &#123; int first = true; for(auto g : v) &#123; if(first) first = false; else putchar(' '); printf("%d", g); &#125; putchar('\n');&#125;int main() &#123; scanf("%d", &amp;n); m = 1 &lt;&lt; n; a.resize(m), b.resize(m); rep(i, m) scanf("%d", &amp;a[i]); rep(i, m) scanf("%d", &amp;b[i]); show(conv(a, b, fmt_or)); show(conv(a, b, fmt_and)); show(conv(a, b, fwt_xor)); return 0;&#125; 动态规划LIS相关最长公共上升子序列 LCIS定义状态 dp[i][j] 表示考虑数列 $a$ 的前 $i$ 个元素，数列 $b$ 的前 $j$ 个元素，并且最后一个数是 $b_j$ 的 LCIS 长度。 转移：$$\begin{align}dp[i][j] &amp;= dp[i-1][j]\\ dp[i][j] &amp;= 1+\max_{1\leq k &lt; j \text { and } b_k &lt; b_j} dp[i-1][k] \text{ , if a[i] = b[j]}\end{align}$$注意到第二个转移由于 $a_i=b_j$ ，可以直接记录一个最大值做到 $O(1)$ 。总复杂度 $O(n^2)$。下面的模板带构造方案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 1050;int a[maxn], b[maxn], n, m;// LCIS template partint dp[maxn][maxn], res[maxn];pii cho[maxn][maxn];void solve() &#123; // index starts with 1 rep(i, n) rep(j, m) dp[i][j] = 0, cho[i][j] = &#123;-1, -1&#125;; for(int i = 1; i &lt;= n; ++i) &#123; int mx = 0, pos = 0; for(int j = 1; j &lt;= m; ++j) &#123; dp[i][j] = dp[i-1][j], cho[i][j] = &#123;i-1, j&#125;; if(a[i] == b[j] &amp;&amp; mx + 1 &gt; dp[i][j]) &#123; dp[i][j] = mx + 1; cho[i][j] = &#123;i-1, pos&#125;; &#125; if(a[i] &gt; b[j] &amp;&amp; dp[i-1][j] &gt; mx) &#123; mx = dp[i-1][j]; pos = j; &#125; &#125; &#125; int bpos = -1, ans = -1; for(int i = 1; i &lt;= m; ++i) if(dp[n][i] &gt; ans) bpos = i, ans = dp[n][i]; pii p = &#123;n, bpos&#125;; for(int i = ans; i &gt; 0; --i) &#123; res[i] = b[p.second]; int t = p.second; while(p.second == t) p = cho[p.first][p.second]; &#125; printf("%d\n", ans); rep(i, ans) printf("%d%c", res[i], " \n"[i==ans]);&#125;// End of templateint main() &#123; int T; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); rep(i, n) scanf("%d", &amp;a[i]); scanf("%d", &amp;m); rep(i, m) scanf("%d", &amp;b[i]); solve(); &#125; return 0;&#125; 最长 ZigZag 公共子序列Opentrains 1519 J. 即找到这样的公共子序列，满足对于任意合法的 $i$ ，都有：$$a_{i-1} &lt; a_{i} &gt; a_{i+1} \text{ or } a_{i-1} &gt; a_i &lt; a_{i+1}$$方法与上面的完全一样。不过需要注意需要特判长度为 2 时的公共子序列永远是 Zigzag 的，即使这两个元素相等。下面是一个 hack 数据，错了这个会 WA 2。 122 3 33 3 3 3 答案应当是 2。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 2322;int dp[maxn][maxn][2], n, m, a[maxn], b[maxn], lcs[maxn][maxn];void upd(int &amp;x, int y) &#123; x = max(x, y); &#125;int main() &#123; scanf("%d", &amp;n); rep(i, n) scanf("%d", &amp;a[i]); scanf("%d", &amp;m); rep(i, m) scanf("%d", &amp;b[i]); // 0:down, 1:up for(int i = 1; i &lt;= n; ++i) &#123; int mxup = 0, mxdown = 0; for(int j = 1; j &lt;= m; ++j) &#123; dp[i][j][0] = dp[i-1][j][0]; dp[i][j][1] = dp[i-1][j][1]; if(a[i] == b[j]) &#123; upd(dp[i][j][0], mxup + 1); upd(dp[i][j][1], mxdown + 1); &#125; else if(a[i] &gt; b[j]) &#123; upd(mxup, dp[i-1][j][1]); &#125; else upd(mxdown, dp[i-1][j][0]); &#125; &#125; int ans = -1; rep(i, m) upd(ans, max(dp[n][i][0], dp[n][i][1])); rep(i, n) rep(j, m) &#123; if(a[i]==b[j]) lcs[i][j] = lcs[i-1][j-1] + 1; else lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]); &#125; if(lcs[n][m] &gt;= 2) ans = max(ans, 2); printf("%d\n", ans); return 0;&#125; 图论深度优先搜索系列Tarjan求强连通分量输入图G，调用find_scc(vertex count)，之后得到 {nG, sccno} 二元组。可以用 std::tie 来承接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const int maxn = 10200;int n, m, a[maxn], _x, _y;// === template part ===using Graph = vector&lt; vector&lt;int&gt; &gt;;namespace Tarjan &#123;// input Graph G and vertex number vc, (index starts with 1)// then call find_scc(). nG is the new graphvector&lt;int&gt; sccno, dfn, low;stack&lt;int&gt; S;Graph G, nG;int vc, sc, dfs_clock;void Tarjan(int v) &#123; S.push(v); low[v] = dfn[v] = ++dfs_clock; for(auto u : G[v]) &#123; if(!dfn[u]) &#123; Tarjan(u); low[v] = min(low[v], low[u]); &#125; else if(!sccno[u]) low[v] = min(low[v], dfn[u]); &#125; if(low[v] == dfn[v]) &#123; sc++; for(;;) &#123; int p = S.top(); S.pop(); sccno[p] = sc; if(p == v) break; &#125; &#125;&#125;pair&lt; Graph, vector&lt;int&gt; &gt; find_scc(int sz = G.size() - 1) &#123; // returns &#123;new Graph, sccno&#125; sc = dfs_clock = 0; vc = sz; sccno = dfn = low = vector&lt;int&gt;(vc + 2); for(int i = 1; i &lt;= vc; ++i) if(!dfn[i]) Tarjan(i); nG.resize(sc); for(int u = 1; u &lt;= vc; ++u) for(auto v : G[u]) if(sccno[u] != sccno[v]) nG[sccno[u]].push_back(sccno[v]); return &#123;nG, sccno&#125;;&#125;&#125;// === end of template ===Graph G(10020), nG;vector&lt;int&gt; sccno, dp(10020), tot(10020);int dfs(int v) &#123; if(dp[v]) return dp[v]; for(auto u : nG[v]) dp[v] = max(dp[v], dfs(u)); return dp[v] += tot[v];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); rep(i, n) scanf("%d", &amp;a[i]); rep(i, m) &#123; scanf("%d%d", &amp;_x, &amp;_y); G[_x].push_back(_y); &#125; Tarjan::G = G; tie(nG, sccno) = Tarjan::find_scc(); for(int i = 1; i &lt;= n; ++i) tot[sccno[i]] += a[i]; int ans = 0; for(int i = 1; i &lt;= n; ++i) ans = max(ans, dfs(i)); printf("%d\n", ans); return 0;&#125;/*Sample:10 20970 369 910 889 470 106 658 659 916 964 3 23 63 49 58 35 89 19 79 87 53 77 81 710 21 104 82 63 13 58 5Answer: 6911*/ 2-SAT问题有n个布尔变量 $x_1,x_2,\cdots x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是“ $x_i$ 为 $true/false$ 或 $x_j$ 为$true/false$ ”。比如 “ $x_1$ 为真或 $x_3$ 为假”、“$x_7$ 为假或 $x_2$ 为假”。2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。 Tarjan 缩点实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;struct TwoSAT &#123; int n, sz, dfs_clock, scc_cnt; vector&lt; vector&lt;int&gt; &gt; G; vector&lt;int&gt; dfn, low, sccno, ans; TwoSAT(int size) &#123; this-&gt;n = size * 2; this-&gt;sz = size; G.resize(n + 22); dfn.resize(n + 22); low.resize(n + 22); sccno.resize(n + 22); dfs_clock = scc_cnt = 0; &#125; inline void Add(int x, bool xv, int y, bool yv) &#123; G[x + (!xv) * sz].push_back(y + yv * sz); G[y + (!yv) * sz].push_back(x + xv * sz); &#125; // x == xv OR y == yv stack&lt;int&gt; S; void Tarjan(int v) &#123; low[v] = dfn[v] = ++dfs_clock; S.push(v); for(auto u : G[v]) &#123; if(!dfn[u]) &#123; Tarjan(u); low[v] = min(low[v], low[u]); &#125; else if(!sccno[u]) low[v] = min(low[v], dfn[u]); &#125; if(low[v] == dfn[v]) &#123; scc_cnt++; for(;;) &#123; int p = S.top(); S.pop(); sccno[p] = scc_cnt; if(p == v) break; &#125; &#125; &#125; bool solve() &#123; for(int i = 1; i &lt;= n; ++i) if(!dfn[i]) Tarjan(i); for(int i = 1; i &lt;= sz; ++i) if(sccno[i] == sccno[i + sz]) return false; for(int i = 1; i &lt;= sz; ++i) ans.push_back(sccno[i + sz] &lt; sccno[i]); return true; &#125;&#125;; 2-SAT问题（暴力实现） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int MAXN = 1002000;struct TwoSAT &#123; int n; vector&lt; vector&lt;int&gt; &gt; G; vector&lt;int&gt; S; vector&lt;bool&gt; mark; int c; void init(int num) &#123; this-&gt;n = num, c = 0; G.resize(n * 2 + 100); for(int i = 0; i &lt; n * 2; ++i) G[i].clear(); mark.resize(n * 2 + 100); fill(mark.begin(), mark.end(), 0); S.resize(n * 2 + 100); &#125; bool dfs(int x) &#123; if(mark[x ^ 1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; void add(int x, int xv, int y, int yv) &#123; x = x * 2 + xv; y = y * 2 + yv; G[x ^ 1].push_back(y); G[y ^ 1].push_back(x); &#125; bool solve() &#123; for(int i = 0; i &lt; n * 2; i += 2) &#123; if(!mark[i] &amp;&amp; !mark[i + 1]) &#123; c = 0; if(!dfs(i)) &#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;; 网络流最大流Dinic算法，复杂度 $O(n^2 m)$ Dinic(n)创建时声明节点数量 AddEdge(from, to, cap)加边 MaxFlow(s, t)返回最大流 使用前确定好Type用int还是long long 复杂度O(n^2 m) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int INF = 0x3f3f3f3f;#define Type intstruct Edge &#123; int from, to; Type cap, flow; Edge(int u = 0, int v = 0, Type c = 0): from(u), to(v), cap(c), flow(0) &#123; &#125;&#125;;struct Dinic &#123; int N; vector&lt;Edge&gt; edges; vector&lt; vector&lt;int&gt; &gt; adj; vector&lt;int&gt; d, cur; Dinic(int Num): N(Num + 20), edges(0), adj(Num + 20), d(Num + 20), cur(Num + 20) &#123; &#125; void AddEdge(int u, int v, Type cap) &#123; if(u == v) return; edges.emplace_back(u, v, cap); adj[u].emplace_back(edges.size() - 1); edges.emplace_back(v, u, 0); adj[v].emplace_back(edges.size() - 1); &#125; bool BFS(int S, int T) &#123; queue&lt;int&gt; q(&#123;S&#125;); fill(d.begin(), d.end(), N + 1); d[S] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); if(u == T) break; for(int k : adj[u]) &#123; Edge &amp;e = edges[k]; if(e.flow &lt; e.cap &amp;&amp; d[e.to] &gt; d[e.from] + 1) &#123; d[e.to] = d[e.from] + 1; q.emplace(e.to); &#125; &#125; &#125; return d[T] != N + 1; &#125; Type DFS(int u, int T, Type flow = -1) &#123; if(u == T || flow == 0) return flow; for(int &amp;i = cur[u]; i &lt; int(adj[u].size()); ++i) &#123; Edge &amp;e = edges[adj[u][i]]; Edge &amp;re = edges[adj[u][i] ^ 1]; if(d[e.to] == d[e.from] + 1) &#123; Type rem = e.cap - e.flow; if(flow != -1 &amp;&amp; rem &gt; flow) rem = flow; Type pushed = DFS(e.to, T, rem); if(pushed &gt; 0) &#123; e.flow += pushed; re.flow -= pushed; return pushed; &#125; &#125; &#125; return 0; &#125; Type MaxFlow(int S, int T) &#123; Type total = 0; while(BFS(S, T)) &#123; fill(cur.begin(), cur.end(), 0); while(Type flow = DFS(S, T)) total += flow; &#125; return total; &#125;&#125;;#undef Typeint n, m;int main() &#123; int ss, tt; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;ss, &amp;tt); Dinic solver(n); for(int i = 1;i &lt;= m; ++i)&#123; int x, y, cap; scanf("%d%d%d", &amp;x, &amp;y, &amp;cap); solver.AddEdge(x, y, cap); &#125; printf("%d\n", solver.MaxFlow(ss, tt));&#125; 最小费用最大流EK+SPFA。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// EK algorithm for MincostMaxflow. Overall Complexity: O(nm^2)// Functions: MCMF::init(n, m) MCMF::addedge(from, to, capacity, cost)// Main Function: MCMF::MinCostMaxFlow(source, target, cost&amp;) returns flow while editing the cost.// Use long long if possible.#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5020, maxm = 100200;namespace MCMF&#123; int head[maxn], nxt[maxm], n, m, ecnt = 1; struct Edge&#123; int from, to, cap, flow, cost; Edge(int u = 0, int v = 0, int c = 0, int f = 0, int o = 0): from(u), to(v), cap(c), flow(f), cost(o)&#123;&#125; &#125; e[maxm]; inline void init(int nc, int mc)&#123; memset(head, 0, sizeof head); ecnt = 1, n = nc, m = mc; &#125; inline void addedge(int u, int v, int ca, int co)&#123; e[++ecnt] = Edge(u, v, ca, 0, co), nxt[ecnt] = head[u], head[u] = ecnt; e[++ecnt] = Edge(v, u, 0, 0, -co), nxt[ecnt] = head[v], head[v] = ecnt; &#125; int d[maxn], p[maxn], a[maxn], inq[maxn]; inline bool SPFA(int s, int t, int&amp; flow, long long&amp; cost)&#123; memset(d, 0x3f, sizeof d); memset(inq, 0, sizeof inq); d[s] = 0, inq[s] = 1, p[s] = 0, a[s] = 0x3f3f3f3f; queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = head[u]; i ; i = nxt[i])&#123; if(e[i].cap &gt; e[i].flow &amp;&amp; d[e[i].to] &gt; d[u] + e[i].cost)&#123; d[e[i].to] = d[u] + e[i].cost ; p[e[i].to] = i; a[e[i].to] = min(a[u], e[i].cap - e[i].flow); if(!inq[e[i].to])&#123; q.push(e[i].to); inq[e[i].to] = 1; &#125; &#125; &#125; &#125; if(d[t] &gt;= 0x3f3f3f3f) return false; flow += a[t]; cost += 1LL * d[t] * a[t]; for(int u = t; u != s; u = e[p[u]].from)&#123; e[p[u]].flow += a[t]; e[p[u] ^1].flow -= a[t]; &#125; return true; &#125; inline int MinCostMaxFlow(int s, int t, ll&amp; cost)&#123; int flow = 0; cost = 0; while(SPFA(s, t, flow, cost)) continue; return flow; &#125;&#125;using MCMF::addedge;using MCMF::MinCostMaxFlow;using MCMF::init; LCA最近公共祖先LCA（树链剖分）$O(n) - O(\log n)$1234567891011121314151617181920212223242526272829const int maxn = 500200;int n, root, q, top[maxn];int fa[maxn], dep[maxn], sz[maxn], son[maxn];vector&lt;int&gt; G[maxn];void dfs1(int v, int fath, int depth) &#123; dep[v] = depth, fa[v] = fath, sz[v] = 1; for(auto u : G[v]) if(u != fath) &#123; dfs1(u, v, depth + 1); sz[v] += sz[u]; &#125;&#125;void dfs2(int v, int fath, int tp) &#123; int mxsz = 0; top[v] = tp; for(auto u : G[v]) if(u != fath) if(sz[u] &gt; mxsz) mxsz = sz[u], son[v] = u; if(!son[v]) return; dfs2(son[v], v, tp); for(auto u : G[v]) if(u != fath &amp;&amp; u != son[v]) dfs2(u, v, u);&#125;inline int lca(int x, int y) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = fa[top[x]]; &#125; if(dep[x] &lt; dep[y]) return x; return y;&#125; 最近公共祖先LCA(欧拉序RMQ实现)$O(n\log n)-O(1)$ 1234567891011121314151617181920212223242526272829303132333435363738394041const int maxn = 500020, maxm = 1000020;namespace LCA&#123; int n, m, ecnt = 0, head[maxn], nxt[maxm]; struct edge&#123; int from, to; edge(int x = 0, int y = 0) : from(x), to(y) &#123;&#125; &#125; e[maxm]; inline void init(int sz)&#123; memset(head, 0, sizeof(int) * (sz + 10)); ecnt = 0; &#125; inline void addedge(int x, int y)&#123; e[++ecnt] = edge(x, y); nxt[ecnt] = head[x]; head[x] = ecnt; &#125; int st[maxn &lt;&lt; 1][30], euler[maxn &lt;&lt; 1], dep[maxn &lt;&lt; 1], fir[maxn], len; inline int mn(int x, int y) &#123;return dep[x] &lt; dep[y] ? x : y;&#125; void dfs(int v, int fa, int depth) &#123; euler[++len] = v, dep[len] = depth, fir[v] = len; for(int i = head[v]; i; i = nxt[i]) if(e[i].to != fa) &#123; dfs(e[i].to, v, depth + 1); euler[++len] = v, dep[len] = depth; &#125; &#125; inline void init(int root) &#123; len = 0; dfs(root, -1, 1); for(int i = 1; i &lt;= len; ++i) st[i][0] = i; for(int j = 1; (1 &lt;&lt; j) &lt;= len; ++j) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= len; ++i) st[i][j] = mn(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]); &#125; inline int lca(int x, int y) &#123; int l = fir[x], r = fir[y]; if(l &gt; r) swap(l, r); int k = log2(r - l + 1.00); return euler[mn(st[l][k], st[r- (1&lt;&lt;k) + 1][k])]; &#125;&#125; SPFA判负环12345678910111213141516171819202122232425262728293031323334353637const int maxn = 3020, maxm = 10010;int n, m, head[maxn], nxt[maxm], ecnt = 0;struct edge &#123; int from, to, w; edge(int f = 0, int t = 0, int c = 0) : from(f), to(t), w(c) &#123; &#125;&#125; e[maxm];inline void addedge(int f, int t, int c) &#123; e[++ecnt] = edge(f, t, c); nxt[ecnt] = head[f]; head[f] = ecnt;&#125;bool inq[maxn];int cnt[maxn], d[maxn];bool spfa(int s) &#123; // 注：判断的是从s点是否会经过负环，全局负环请加超级源点 memset(inq, 0, sizeof inq); memset(cnt, 0, sizeof cnt); memset(d, 0x3f, sizeof d); inq[s] = true, cnt[s] = 1, d[s] = 0; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int cur = q.front(); q.pop(); inq[cur] = false; for(int i = head[cur]; i ; i = nxt[i]) &#123; int to = e[i].to, w = e[i].w; if(d[to] &gt; d[cur] + w) &#123; d[to] = d[cur] + w; if(!inq[to]) &#123; if(++cnt[to] &gt;= n) return false; q.push(to); &#125; &#125; &#125; &#125; return true;&#125; 数据结构ST表-静态区间最小值1234567891011121314151617const int maxn = 100020;int m, q, a[maxn];namespace ST &#123; int d[maxn][30], n; inline void RMQ_init(int* arr, int sz) &#123; n = sz; for(int i = 1; i &lt;= n; ++i) d[i][0] = arr[i]; for(int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) d[i][j] = max(d[i][j-1], d[i+(1&lt;&lt;(j-1))][j-1]); &#125; inline int RMQ(int l, int r) &#123; int k = 0; while((1 &lt;&lt; (k + 1)) &lt; r - l + 1) k++; return max(d[l][k], d[r-(1&lt;&lt;k)+1][k]); &#125;&#125; 值域 $10^6$ 的名次树（非负）12345678910111213141516171819202122232425struct Fenwick &#123; #define lowbit(x) (x &amp; (-x)) int c[maxn + 100]; inline void Add(int x, int v) &#123; for(; x &lt;= maxn; x += lowbit(x)) c[x] += v; &#125; inline int Find_kth(int k) &#123; // 从1开始计数的第k小 int ans = 0, cnt = 0, i; for(i = 26; i &gt;= 0; --i) &#123; ans += 1 &lt;&lt; i; if(ans &gt;= maxn || c[ans] + cnt &gt;= k) ans -= 1 &lt;&lt; i; else cnt += c[ans]; &#125; return ans + 1; &#125; inline int Find_rk(int x) &#123; //比x小的数的个数+1 int ret = 0; x--; for(; x; x -= lowbit(x)) ret += c[x]; return ret + 1; &#125; inline int Prev(int x) &#123; return Find_kth(Find_rk(x) - 1);&#125; inline int Next(int x) &#123; return Find_kth(Find_rk(x + 1));&#125;&#125; t; 可持久化Trie1234567891011121314151617181920212223242526const int maxn = 50030;int trie[maxn][30], Q, roots[maxn], Root = 1, tot = 1, len, rcnt = 1, End[maxn];char s[maxn];inline void Insert() &#123; scanf("%s", s), len = strlen(s); int rt = ++tot, p = Root, q = rt; roots[++rcnt] = rt; for(int i = 0; i &lt; len; ++i) &#123; if(p) for(int c = 0; c &lt; 26; ++c) trie[q][c] = trie[p][c]; int New = ++tot, ch = s[i] - 'a'; trie[q][ch] = New; p = trie[p][ch], q = trie[q][ch]; if(End[p]) End[q] = true; &#125; Root = rt, End[q] = true;&#125;inline void Undo() &#123; Root = roots[--rcnt]; &#125;inline bool Find() &#123; scanf("%s", s), len = strlen(s); int q = Root; for(int i = 0; i &lt; len; ++i) &#123; int ch = s[i] - 'a'; if(!trie[q][ch]) return false; q = trie[q][ch]; &#125; return End[q];&#125; Treap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const int maxn = 100200;namespace Treap &#123; int tot, root; struct node &#123; int val, dat, cnt, sz; int lc, rc; &#125; tr[maxn]; inline int New(int val) &#123; //注意：开始时已经插入了INF与-INF tr[++tot].val = val; tr[tot].cnt = tr[tot].sz = 1; tr[tot].dat = rand(); return tot; &#125; inline void Update(int p) &#123; tr[p].sz = tr[ tr[p].lc ].sz + tr[ tr[p].rc ].sz + tr[p].cnt; &#125; inline void lrot(int&amp; p) &#123; int q = tr[p].rc; tr[p].rc = tr[q].lc; tr[q].lc = p; p = q; Update(tr[p].lc), Update(p); &#125; inline void rrot(int &amp;p) &#123; int q = tr[p].lc; tr[p].lc = tr[q].rc; tr[q].rc = p; p = q; Update(tr[p].rc), Update(p); &#125; inline void Init() &#123; root = New(INF); tr[root].lc = New(-INF); Update(root); &#125; inline void Insert(int x, int &amp;p = root) &#123; if(p == 0) &#123; p = New(x); return; &#125; if(tr[p].val == x) &#123; tr[p].cnt++; Update(p); return; &#125; else if(tr[p].val &gt; x) &#123; Insert(x, tr[p].lc); if(tr[p].dat &lt; tr[tr[p].lc].dat) rrot(p); &#125; else if(tr[p].val &lt; x) &#123; Insert(x, tr[p].rc); if(tr[p].dat &lt; tr[tr[p].rc].dat) lrot(p); &#125; Update(p); &#125; inline void Remove(int x, int&amp; p = root) &#123; if(p == 0) return; if(tr[p].val == x) &#123; if(tr[p].cnt &gt; 1) &#123; tr[p].cnt--, Update(p); return; &#125; if(tr[p].lc || tr[p].rc) &#123; if(tr[p].rc == 0 || tr[tr[p].lc].dat &gt; tr[tr[p].rc].dat) rrot(p), Remove(x, tr[p].rc); else lrot(p), Remove(x, tr[p].lc); Update(p); &#125; else p = 0; return; &#125; if(tr[p].val &lt; x) Remove(x, tr[p].rc); else Remove(x, tr[p].lc); Update(p); &#125; int small(int val, int p) &#123; if(p == 0) return 0; if(val == tr[p].val) return tr[tr[p].lc].sz; else if(val &lt; tr[p].val) return small(val, tr[p].lc); else return small(val, tr[p].rc) + tr[p].cnt + tr[tr[p].lc].sz; &#125; int kthsmall(int rk, int p) &#123; // k smallest if(p == 0) return INF; if(tr[tr[p].lc].sz &gt;= rk) return kthsmall(rk, tr[p].lc); if(tr[tr[p].lc].sz + tr[p].cnt &gt;= rk) return tr[p].val; return kthsmall(rk - tr[tr[p].lc].sz - tr[p].cnt, tr[p].rc); &#125; inline int Rank(int x) &#123; return small(x, root); &#125; inline int Kth (int k) &#123; return kthsmall(k + 1, root); &#125; inline int Prev(int x) &#123; return Kth(Rank(x) - 1); &#125; inline int Next(int x) &#123; return Kth(Rank(x + 1)); &#125;&#125; 计算几何注意：凸包相关问题，必须搞清楚要求的是严格的还是非严格的。 大板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const double eps = 1e-10;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; Point turn(double rad) &#123; return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); &#125; Point turn90() &#123; return Point(-y, x); &#125; void scan() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double dist2(Point A, Point B) &#123; return dot(A - B, A - B); &#125;double cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125;double angle(Vector A, Vector B) &#123; return acos(dot(A, B) / length(A) / length(B)); &#125;Point LineProjection(Point P, Point A, Point B) &#123; Vector v = B - A; return A + v * (dot(P-A, v) / dot(v, v));&#125;Point LineReflection(Point P, Point A, Point B) &#123; Point proj = LineProjection(P, A, B); return proj + proj - P;&#125;int Clockwise(Point O, Point A, Point B) &#123; /* Clockwise: -1 Counterclockwise: 1 Otherwise: 0 */ return sgn(cross(A - O, B - O));&#125;void SegCheck(Point a, Point b, Point p) &#123; Vector d = b - a, e = p - a; if(sgn(dot(d, e)) == -1) puts("ONLINE_BACK"); else if(sgn(length(e) - length(d)) == 1) puts("ONLINE_FRONT"); else puts("ON_SEGMENT");&#125;int JudgeLLParOrth(Point a1, Point a2, Point b1, Point b2) &#123; /* 2: parallel 1: orthogonal 0: otherwise */ Vector v = a2 - a1, w = b2 - b1; if(sgn(cross(v, w)) == 0) return 2; if(sgn(dot(v, w)) == 0) return 1; return 0;&#125;bool CheckSSProperIntersection(Point a1, Point a2, Point b1, Point b2) &#123; double c1 = cross(a1 - b1, b2 - b1), c2 = cross(a2 - b1, b2 - b1); double c3 = cross(b1 - a1, a2 - a1), c4 = cross(b2 - a1, a2 - a1); return sgn(c1) * sgn(c2) == -1 &amp;&amp; sgn(c3) * sgn(c4) == -1;&#125;bool OnSeg(Point P, Point A, Point B) &#123; // (A, B) not inclusive Vector v = B - P, w = A - P; if(sgn(cross(v, w)) != 0) return false; return sgn(dot(v, w)) == -1;&#125;bool CheckSSIntersection(Point a1, Point a2, Point b1, Point b2) &#123; if(a1 == b1 || a1 == b2 || a2 == b1 || a2 == b2) return true; if(OnSeg(a1, b1, b2) || OnSeg(a2, b1, b2) || OnSeg(b1, a1, a2) || OnSeg(b2, a1, a2)) return true; return CheckSSProperIntersection(a1, a2, b1, b2);&#125;// Ensure lines intersect first!!! cross(v, w) != 0Point LLIntersection(Point a1, Point a2, Point b1, Point b2) &#123; Vector v = a2 - a1, w = b2 - b1, u = a1 - b1; assert(cross(v, w) != 0); double t1 = cross(w, u) / cross(v, w); return a1 + v * t1;&#125; // Line: 2 PointsPoint LLIntPV(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; assert(cross(v, w) != 0); double t = cross(w, u) / cross(v, w); return P + v * t;&#125; // Line: Point + Vectordouble PLDist(Point P, Point A, Point B) &#123; // Point-Line return fabs(cross(B - P, A - P) / length(A - B));&#125;double PSDist(Point P, Point A, Point B) &#123; // Point-Segment if(A == B) return length(P - A); if(sgn(dot(A-P, B-A)) == 1) return length(A - P); if(sgn(dot(B-P, B-A)) == -1) return length(B - P); return fabs(cross(B-P, A-P) / length(A-B));&#125;double SSDist(Point a1, Point a2, Point b1, Point b2) &#123; // segment - segment if(CheckSSIntersection(a1, a2, b1, b2)) return 0.0; return min(min(PSDist(a1,b1,b2), PSDist(a2,b1,b2)), min(PSDist(b1,a1,a2), PSDist(b2,a1,a2)));&#125;// Polygon Operationstypedef vector&lt;Point&gt; Polygon;double PolygonArea(const Polygon&amp; p) &#123; int sz = p.size(); double tot = 0.0; for(int i = 1; i &lt; sz - 1; ++i) tot += cross(p[i]-p[0], p[i+1]-p[0]); return fabs(tot / 2.0);&#125;bool IsConvex(Polygon po, int strict = 1) &#123; // po should be given in counterclockwise !!!! int sz = po.size(); po.push_back(po[0]), po.push_back(po[1]); for(int i = 0; i &lt; sz; ++i) if(sgn(cross(po[i+1]-po[i], po[i+2]-po[i])) &lt; strict) return false; return true;&#125;int InPolygon(Point pt, Polygon po) &#123; /* 2: in polygon * 1: on segment * 0: not in polygon */ int sz = po.size(), wn = 0; po.push_back(po[0]); for(int i = 0; i &lt; sz; ++i) &#123; Point u = po[i], v = po[i + 1]; if(OnSeg(pt, u, v) || pt == u) return 1; if(sgn(u.y-v.y) == 1) swap(u, v); if(pt.y&lt;=u.y || pt.y&gt;v.y) continue; if(sgn(cross(pt-u, v-u)) == -1) wn ^= 1; &#125; return wn &lt;&lt; 1;&#125;Polygon ConvexHull(Polygon pts, int strict = 1) &#123; sort(pts.begin(), pts.end()); int pn = pts.size(), m = -1; vector&lt;Point&gt; res(pn &lt;&lt; 1); for(int i = 0; i &lt; pn; ++i) &#123; while(m &gt; 0 &amp;&amp; sgn(cross(res[m]-res[m-1], pts[i]-res[m-1]))&lt;strict) m--; res[++m] = pts[i]; &#125; int k = m; for(int i = pn - 2; i &gt;= 0; --i) &#123; while(m &gt; k &amp;&amp; sgn(cross(res[m]-res[m-1], pts[i]-res[m-1]))&lt; strict) m--; res[++m] = pts[i]; &#125; res.resize(m + (pn==1)); return res;&#125;// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125; Circle(Point A, Point B, Point C) &#123; // 三点确定圆 assert(sgn(cross(B-A, C-A)) != 0); Point mab = (A + B) / 2.0, ab = (B - A).turn90(); Point mbc = (B + C) / 2.0, bc = (C - B).turn90(); o = LLIntPV(mab, ab, mbc, bc); r = length(A - o); &#125; Point at(double theta) &#123; return o + Point(cos(theta)*r, sin(theta)*r); &#125; bool out(Point pt) &#123; return sgn(length(o-pt) - r) == 1;&#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());Circle MinCircle(vector&lt;Point&gt; pt) &#123; // 最小圆覆盖，随机增量法 int sz = pt.size(); shuffle(pt.begin(), pt.end(), rng); Circle cc(pt[0], 0.0); for(int i = 0; i &lt; sz; ++i) if(cc.out(pt[i])) &#123; cc = Circle(pt[i], 0.0); for(int j = 0; j &lt; i; ++j) if(cc.out(pt[j])) &#123; cc = Circle((pt[i] + pt[j]) / 2.0, length(pt[i]-pt[j]) / 2.0); for(int k = 0; k &lt; j; ++k) &#123; if(cc.out(pt[k])) &#123; cc = Circle(pt[i], pt[j], pt[k]); &#125; &#125; &#125; &#125; return cc;&#125;int main() &#123; Point x; Polygon pol; int q; scanf("%d", &amp;q); while(q--) &#123; x.scan(); pol.push_back(x); &#125; Polygon ch = ConvexHull(pol, 0), ans; int sz = ch.size(), idx = 0; Point my = ch[0]; for(int i = 1; i &lt; sz; ++i) &#123; if(ch[i].y &lt; my.y || (ch[i].y==my.y&amp;&amp;ch[i].x&lt;my.x)) my = ch[i], idx = i; &#125; for(int i = idx; i &lt; sz; ++i) ans.push_back(ch[i]); for(int i = 0; i &lt; idx; ++i) ans.push_back(ch[i]); printf("%d\n", sz); for(int i = 0; i &lt; sz; ++i) printf("%.0f %.0f\n", ans[i].x, ans[i].y); return 0;&#125; 凸包基于水平序的Andrew算法 注意： 调用时 strict = 1 表示严格凸包，不允许有顶点在凸包上。 给出的凸包按照逆时针方向，起始点是最左侧的点中最下侧的。 12345678910111213141516171819202122232425262728293031323334353637383940const double eps = 1e-10;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125;&#125;;double dot(Point x, Point y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Point x) &#123; return sqrt(dot(x, x)); &#125;double cross(Point A, Point B) &#123; return A.x*B.y - A.y*B.x; &#125;vector&lt;Point&gt; p, ch;vector&lt;Point&gt; ConvexHull(vector&lt;Point&gt; pts, int strict = 1) &#123; sort(pts.begin(), pts.end()); int pn = pts.size(), m = -1; vector&lt;Point&gt; res(pn &lt;&lt; 1); for(int i = 0; i &lt; pn; ++i) &#123; while(m &gt; 0 &amp;&amp; sgn(cross(res[m]-res[m-1], pts[i]-res[m-1]))&lt;strict) m--; res[++m] = pts[i]; &#125; int k = m; for(int i = pn - 2; i &gt;= 0; --i) &#123; while(m &gt; k &amp;&amp; sgn(cross(res[m]-res[m-1], pts[i]-res[m-1]))&lt; strict) m--; res[++m] = pts[i]; &#125; res.resize(m + (pn==1)); return res;&#125; 严格上凸壳（CF1142C） 123456789101112131415161718192021222324252627282930313233343536const double eps = 1e-10;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125;&#125;;double dot(Point x, Point y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Point x) &#123; return sqrt(dot(x, x)); &#125;double cross(Point A, Point B) &#123; return A.x*B.y - A.y*B.x; &#125;vector&lt;Point&gt; p, ch;vector&lt;Point&gt; UpperConvexHull(vector&lt;Point&gt; pts, int strict = 1) &#123; sort(pts.begin(), pts.end()); int pn = pts.size(), m = -1; vector&lt;Point&gt; res(pn &lt;&lt; 1); for(int i = 0; i &lt; pn; ++i) &#123; while(m &gt;= 0 &amp;&amp; sgn(res[m].x - pts[i].x) == 0) m--; while(m &gt; 0 &amp;&amp; sgn(cross(res[m]-res[m-1], pts[i]-res[m-1])) &gt;= 0) m--; res[++m] = pts[i]; &#125; res.resize(m + 1); return res;&#125; 其他模拟退火模拟退火算法描述： 若 $J( Y(i+1) ) \geq J( Y(i) )$ (即移动后得到更优解)，则总是接受该移动 若 $J( Y(i+1) )&lt; J( Y(i) )$ (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定），随着能量差的增大而降低。具体来说： 在温度为 $T$ 时，出现能量差为 $\Delta E$ 的降温的概率为 $P(\Delta E)$，表示为：$$P(\Delta E) = e^{\frac {\Delta E} {kT}}$$这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。 下面的代码是使用模拟退火算法解决最小球覆盖问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const double eps = 1e-12;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y, z; Point(double xp=0, double yp=0, double zp=0): x(xp), y(yp), z(zp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y, z+rhs.z); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y, z-rhs.z); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k, z*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k, z/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y) || (x==rhs.x&amp;&amp;y==rhs.y&amp;&amp;z&lt;rhs.z); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0 &amp;&amp; sgn(z-rhs.z)==0; &#125; void scan() &#123; scanf("%lf%lf%lf", &amp;x, &amp;y, &amp;z); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y + x.z*y.z; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double dist2(Point A, Point B) &#123; return dot(A - B, A - B); &#125;// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());double Eval(const vector&lt;Point&gt;&amp; pt, Point o) &#123; double res = 0; for(auto g : pt) res = max(res, dist2(g, o)); return res;&#125;uniform_real_distribution&lt;double&gt; rgen(0.0, 1.0);double Rand()&#123; return rgen(rng); &#125;Circle MinCircleAnneal(const vector&lt;Point&gt;&amp; pt, double T, double dec, double ed) &#123; Point pcur, pbest, pnew; int sz = pt.size(); for(auto g : pt) pcur = pcur + g; pbest = pcur = pcur / sz; double vcur = Eval(pt, pcur), vnew, vbest = vcur; while(T &gt; ed) &#123; pnew = pcur + Point((Rand()*2.0-1) * T, (Rand()*2.0-1.0) * T, (Rand()*2.0-1) * T); vnew = Eval(pt, pnew); if(vnew &lt;= vbest) vbest = vcur = vnew, pbest = pcur = pnew; if(vnew &lt;= vcur || Rand() &lt; exp(-(vnew-vcur)/T)) vcur = vnew, pcur = pnew; T *= dec; &#125; return Circle(pbest, sqrt(vbest));&#125;int n;int main() &#123; scanf("%d", &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) p[i].scan(); double ans = 1e13; rep(i, 40) &#123; Circle cir = MinCircleAnneal(p, 100000.0, 0.999, 3e-7); ans = min(ans, cir.r); &#125; printf("%.10f\n", ans); return 0;&#125; 快读1234567891011121314151617const int BUFF_SIZE = 1 &lt;&lt; 20;char BUFF[BUFF_SIZE],*BB,*BE;#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opentrains 10399 比赛报告]]></title>
    <url>%2F2019%2F03%2F01%2FOpentrains-10399-%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[XVIII Open Cup named after E.V. Pankratiev. Grand Prix of PeterhofOverview Status A B C D E F G H I J Contest 02:21 —— 02:12 —— 04:42 —— —— WA -1 00:57 01:28 Upsolve OK OK AC OK AC? Yes OK OK Attempt +2 +2 *2 +6 *1 *7 +2 +6 Total AC 126 18 127 82 112 0 11 10 151 93 比赛链接 Claris的题解 这次特地挑了个水题相对较多的比赛，感觉体验稍好一点，但是过掉的这5道题里面没有一道题是一发AC的，D题最后还没时间写。这反映出了代码的实现能力实在是有待提高啊。 最终成果： Solved 5 out of 10 Upsolved 6 out of 10 Rank 91 out of 162 ( 击败$43.83 \%​$ ) 做出了有趣的 $J$ 题，运用了二次剩余，欧拉判别法的知识 这次我踩过的坑点可是有很多了，实在是不应该。。。 交错语言，交错代码，这种幼稚错误今天犯了好多次。。。WA + RE + PE * 6 C题：输出方案没有想清楚，spj题提交前没有用常识检查解的正确性。WA * 2 E题：这个锅我能记一年。。。首先是下标张冠李戴，花了一年才过样例。。。然后使用fgets函数时传入的最大读取长度参数少加了一个0，导致小样例随便跑，大样例就WA。。。浪费一个多小时 + WA * 4 I 题：读错题意 WA * 2 J 题：过于相信Python的运行速度 TLE * 4 Prob A. 数学，递推sl写的，知道思路了，明天再仔细补吧。 Prob C. 暴力Solution题目中已经说恰好出现 $10$ 种字母了，因此只需要枚举每种字母对应的数字的排列即可。暴力枚举排列，将每种排列对应的大于小于关系用一个三进制数表示，放进map里统计，找到只出现一次的三进制数将方案输出。 时间复杂度：$O(10! \cdot \log 10!)$，大约是 $8 \cdot 10^7$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;map&lt;ll, int&gt; mp;map&lt;char, int&gt; id;int a[100], n, tot, d[100], perm[100];char s[100], lnk[100];int main() &#123; scanf("%s", s); n = strlen(s); for(int i = 0; i &lt; n; ++i) &#123; if(!id.count(s[i])) id[s[i]] = tot++; a[i] = id[s[i]]; &#125; rep(i, 9) perm[i] = i; do &#123; for(int i = 0; i &lt; n; ++i) d[i] = perm[a[i]]; ll sta = 0; for(int i = 1; i &lt; n; ++i) &#123; sta = sta * 3LL; if(d[i - 1] &gt; d[i]) sta += 2; else if(d[i-1] == d[i]) sta += 1; &#125; mp[sta]++; &#125; while(next_permutation(perm, perm + 10)); for(auto g : mp) &#123; if(g.second == 1) &#123; ll sta = g.first; for(int p = 0; p &lt; n - 1; ++p) &#123; int xp = n - p - 2; if(sta % 3 == 0) lnk[xp] = '&lt;'; else if(sta % 3 == 1) lnk[xp] = '='; else if(sta % 3 == 2) lnk[xp] = '&gt;'; sta /= 3; &#125; for(int i = 0; i &lt; n; ++i) &#123; printf("%c", s[i]); if(i == n - 1) break; printf(" %c ", lnk[i]); &#125; putchar('\n'); return 0; &#125; &#125; puts("Impossible"); return 0;&#125; Prob E. set求前驱后继Solution首先预处理模板串，把模板串中的每个字符出现的位置塞进这个字符对应的 set 里。 然后，一行一行处理文本串。模板串向左偏移可以看作文本串向右偏移，因此根据处理每一行之前的时间将这一行文本向右移动（这个移动应小心实现，移动时间复杂度必须保证是文本串长度量级的）。对于移动过后的每个字符，计算这个字符要想被打印至少需要多少时间，可以在模板串对应字符的 set 里找前驱来完成。然后取这些时间的最大值即可得出这一行的用时。当然了，处理完每一行之后，不要忘记给时间加一来换行。 时间复杂度：$O(n\log n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define int llset&lt;int&gt; st[200];ll ans = 0, lent, lens, shift = 0;char t[200200], s[3000200], sini[3002000];signed main() &#123; fgets(t, 200000, stdin), lent = strlen(t) - 1; t[lent] = 0; for(int i = 0; i &lt; lent; ++i) &#123; st[int(t[i])].insert(i); &#125; while(fgets(sini, 2000000, stdin)) &#123; lens = strlen(sini); sini[--lens] = 0; if(lens == 0) continue; shift = ans % lent; int start = shift, end = (shift + lens - 1) % lent, cross = false; ll tm = 0; for(int i = 0, p = shift; i &lt; lens; ++i) &#123; s[p] = sini[i]; if(++p == lent) p -= lent, cross = true; &#125; for(int i = start, ed = cross? lent-1 : end; i &lt;= ed; ++i) &#123; if(s[i] &lt; 33 || s[i] &gt; 126) continue; auto g = st[int(s[i])].lower_bound(i); if(g == st[int(s[i])].end()) &#123; int dest = *st[int(s[i])].begin(); tm = max(tm, ll(dest + lent - i)); &#125; else tm = max(tm, ll(*g - i)); &#125; if(cross) for(int i = 0, ed = end; i &lt;= ed; ++i) &#123; if(s[i] &lt; 33 || s[i] &gt; 126) continue; auto g = st[int(s[i])].lower_bound(i); if(g == st[int(s[i])].end()) &#123; int dest = *st[int(s[i])].begin(); tm = max(tm, ll(dest + lent - i)); &#125; else tm = max(tm, ll(*g - i)); &#125; ans += tm + 1; for(int i = 0, p = shift; i &lt; lens; ++i) &#123; s[p] = 0; if(++p == lent) p -= lent; &#125; &#125; printf("%lld\n", ans); return 0;&#125; Prob I. 分类讨论这题没什么好说的。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;char s[100200];set&lt;char&gt; ch;int n;void go(int x, int y) &#123; if(x == 0 &amp;&amp; y == 0) &#123; printf("WE"); return; &#125; while(x &gt; 0) putchar('E'), x--; while(x &lt; 0) putchar('W'), x++; while(y &gt; 0) putchar('N'), y--; while(y &lt; 0) putchar('S'), y++; printf("\n"); exit(0);&#125;int xp, yp;int main() &#123; scanf("%s", s + 1); n = strlen(s + 1); rep(i, n) &#123; if(s[i] == 'N') yp++; else if(s[i] == 'E') xp++; else if(s[i] == 'W') xp--; else if(s[i] == 'S') yp--; ch.insert(s[i]); &#125; if(ch.size() == 1) &#123; puts("X"); return 0; &#125; else if(ch.size() == 2) &#123; if(ch.count('W') &amp;&amp; ch.count('E')) &#123; puts("X"); return 0; &#125; if(ch.count('N') &amp;&amp; ch.count('S')) &#123; puts("X"); return 0; &#125; xp = yp = 0; for(auto g : ch) &#123; if(g == 'N') yp--; else if(g == 'E') xp--; else if(g == 'W') xp++; else if(g == 'S') yp++; &#125; go(xp, yp); &#125; else if(ch.size() == 3) &#123; int dx = 0, dy = 0; if(!ch.count('N')) &#123; if(xp == 0 &amp;&amp; yp == 1) dy++; dy++; &#125; else if(!ch.count('E')) &#123; if(xp == 1 &amp;&amp; yp == 0) dx++; dx++; &#125; else if(!ch.count('W')) &#123; if(xp == -1 &amp;&amp; yp == 0) dx--; dx--; &#125; else if(!ch.count('S')) &#123; if(xp == 0 &amp;&amp; yp == -1) dy--; dy--; &#125; else if(!ch.count('S')) go(0, -1); go(dx, dy); &#125; return 0;&#125; Prob J. 二次剩余，概率算法Description给你一个很大的数 $n$ ，让你判断它是不是完全平方数。（ $n$ 不超过 $10^6$ 位） Solution这道题感觉做法很多啊，我开始有两个想法: Solution 1模拟初中教的手算开根号的过程。这种做法之后补吧。 Solution 2挑多个素数，对每个素数 $p$，检查 $n\bmod p$ 是否是二次剩余。 具体怎么检查一个数是不是二次剩余呢？可以使用欧拉判别法： 若 $n^{\frac{p-1}{2}}\equiv 1 \pmod p$，则 $n$ 是模 $p​$ 的二次剩余； 若 $n^{\frac{p-1}{2}}\equiv -1 \pmod p$，则 $n$ 是模 $p​$ 的二次非剩余； 可以证明，$n^{\frac{p-1}{2}} \pmod p​$ 不存在其他情况。 实际上，这就是勒让德符号$\left(\frac{n}{p}\right)$的定义。勒让德符号专门用来解决二次剩余问题，是完全积性函数，还有不少有用的性质。详细参见二潘的《初等数论》吧 第二种方法显然正确的概率很大。可以这么分析概率：$\pmod p$ 的二次剩余共有 $\frac{p+1}{2}$个，如果假设二次剩余分布相对均匀的话，每次检查成功的概率可以认为大约是 $\frac 12$。因此取47个素数，失败概率已经小到 $\frac 1{2^{47}} \approx 10^{-15}$，完全可以忽略。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const ll p[47] = &#123;1226959, 1635947, 2181271, 2908361, 3877817, 5170427, 6893911, 9191891, 12255871, 16341163, 21788233, 29050993, 38734667, 51646229, 68861641, 91815541, 122420729, 163227661, 217636919, 290182597, 386910137, 515880193, 687840301, 917120411, 1000000007, 1000000009, 1222827239, 1610612741, 3221225473, 4294967291, 61, 83, 113, 151, 211, 281, 379,509, 683, 911 , 1217, 1627, 2179, 2909, 3881, 6907, 9209 &#125;;int a[1002000], n;char s[1002000];int mo(ll mod) &#123; ll ret = 0; for(int i = 0; i &lt; n; ++i) &#123; ret = (10LL * ret + a[i]) % mod; &#125; return ret;&#125;inline int qpow(int x, int y, int mod) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = 1LL * x * x % mod) if(y &amp; 1) ret = 1LL * ret * x % mod; return ret;&#125;int main() &#123; scanf("%s", s); n = strlen(s); for(int i = 0; i &lt; n; ++i) a[i] = s[i] - '0'; for(int c = 0; c &lt; 47; ++c) &#123; int r = mo(p[c]); int q = qpow(r, (p[c]-1)/2, p[c]); if(q == p[c]-1) &#123; puts("No"); return 0; &#125; &#125; puts("Yes"); return 0;&#125; 赛后补题Prob B. 插头DP这道题看来是插头DP经典题的变形了，没学过插头DP，明天详细学习一下这种思想吧。 Prob D. 贪心Solution这题直接贪心就可以了。。。感觉数据只出到35有点奇怪，可能只是为了避免表示每层点的坐标时爆 long long 吧，因为 $3^{35} = 50031545098999707$，long long正好装得下。 具体说这道题的解法的话，就是不断迭代以下的过程： 若 $s, t$ 深度相同，则： 如果它们的距离不超过5，就直接走过去； 否则，让它们都用尽量少的步数走到较浅的一层。 否则，不妨设 $s$ 较深，则让 $s$ 用尽量少的步数往较浅的方向走。 注意以上的策略往较浅方向走都仅考虑”用尽量少的步数“而不考虑走到较浅一层的位置，手画一下图可以发现，这么做一定不会比考虑走到较浅一层的位置差，而对于只考虑走到较浅一层的位置的贪心策略，这里给出一组hack数据： 12ccsccaca Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const ll pow3[] = &#123;1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489, 1162261467, 3486784401, 10460353203, 31381059609, 94143178827, 282429536481, 847288609443, 2541865828329, 7625597484987, 22876792454961, 68630377364883, 205891132094649, 617673396283947, 1853020188851841, 5559060566555523, 16677181699666569, 50031545098999707, 150094635296999121, 450283905890997363, 1350851717672992089, 4052555153018976267&#125;;struct Point &#123; ll x, level; void go(char ch) &#123; switch(ch) &#123; case 'c': level++, x = 3LL * x; break; case 'a': x--, x += x&lt;0 ? pow3[level] : 0; break; case 's': x++, x -= x==pow3[level] ? pow3[level] : 0; break; case 'g': assert(x%3==0); level--, x /= 3; break; &#125; &#125;&#125; s, t;bool swp = false;string spos, tpos, ans[2];int main() &#123; cin &gt;&gt; spos &gt;&gt; tpos; for(auto c : spos) s.go(c); for(auto c : tpos) t.go(c); for(;;) &#123; if(s.level &gt; t.level) swap(s, t), swp ^= 1; if(s.level &lt; t.level) &#123; if(t.x % 3 == 2) t.go('s'), ans[swp ^ 1] += 's'; if(t.x % 3 == 1) t.go('a'), ans[swp ^ 1] += 'a'; t.go('g'); ans[swp ^ 1] += 'g'; &#125; else if(s.level == t.level) &#123; ll spin = s.x - t.x; if(spin &lt; 0) spin += pow3[t.level]; ll anti = t.x - s.x; if(anti &lt; 0) anti += pow3[t.level]; if(spin &lt; anti) &#123; if(spin &lt;= 5) &#123; rep(i, spin) t.go('s'), ans[swp ^ 1] += 's'; &#125; else &#123; if(t.x % 3 == 2) t.go('s'), ans[swp ^ 1] += 's'; if(t.x % 3 == 1) t.go('a'), ans[swp ^ 1] += 'a'; t.go('g'); ans[swp ^ 1] += 'g'; &#125; &#125; else &#123; if(anti &lt;= 5) &#123; rep(i, anti) t.go('a'), ans[swp ^ 1] += 'a'; &#125; else &#123; if(t.x % 3 == 2) t.go('s'), ans[swp ^ 1] += 's'; if(t.x % 3 == 1) t.go('a'), ans[swp ^ 1] += 'a'; t.go('g'); ans[swp ^ 1] += 'g'; &#125; &#125; &#125; if(s.level == t.level &amp;&amp; s.x == t.x) break; &#125; reverse(ans[1].begin(), ans[1].end()); cout &lt;&lt; ans[0]; for(auto c : ans[1]) &#123; if(c == 'g') cout &lt;&lt; 'c'; else if(c == 'c') cout &lt;&lt; 'g'; else if(c == 's') cout &lt;&lt; 'a'; else if(c == 'a') cout &lt;&lt; 's'; &#125; cout &lt;&lt; '\n'; return 0;&#125; Prob F. 神仙计算几何要求完成一个机器人巡线程序。这道题看上去非常毒瘤，加了各种随机化干扰成分，可是最终的std代码仅仅600 byte！下面把标准代码贴出来，不知道其中的 ctl 变量的计算到底有什么道理。 123456789101112131415161718192021222324252627// This is std solution#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; double l, r; double pd = 0; while (scanf("%lf%lf", &amp;l, &amp;r) == 2) &#123; if (l &lt; -0.5) break; double d = r - l; double ctl = d * 2 + (d - pd) * 5; pd = d; double ml = 1 - ctl, mr = 1 + ctl; if (ml &lt; -1) ml = -1; if (ml &gt; 1) ml = 1; if (mr &lt; -1) mr = -1; if (mr &gt; 1) mr = 1; printf("%.4lf %.4lf\n", ml, mr); fflush(stdout); &#125; return 0;&#125; Prob G. 博弈，交互题你扮演一个象棋中的车，要捉棋盘上的一个马。挺有意思，明天想想。 Prob H. 多项式exp / 多项式lnsl补的题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll p = 998244353;ll qpow(ll x, ll y)&#123; ll res = 1; while (y &gt; 0) &#123; if (y &amp; 1) res = res * (long long)x % p; x = x * (long long)x % p, y &gt;&gt;= 1; &#125; return res;&#125;void ntt(ll *a, ll len, ll flag)&#123; ll *r = new ll [len]; r[0] = 0; for (ll i = 1; i &lt; len; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) * (len &gt;&gt; 1)); for (ll i = 0; i &lt; len; i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (ll i = 1; i &lt; len; i &lt;&lt;= 1) &#123; ll g1 = qpow(3, (p - 1) / (i * 2)); for (ll j = 0; j &lt; len; j += i &lt;&lt; 1) for (ll g = 1, k = 0; k &lt; i; k++, g = g * (long long)g1 % p) &#123; ll t = a[j + i + k] * (long long)g % p; a[j + i + k] = ((a[j + k] - t) % p + p) % p; a[j + k] = (a[j + k] + t) % p; &#125; &#125; if (flag == -1) &#123; reverse(a + 1, a + len); for (ll i = 0, inv = qpow(len, p - 2); i &lt; len; i++) a[i] = a[i] * (long long)inv % p; &#125; delete []r;&#125;void poly_inv(ll *a, ll len)&#123; if (len == 1) &#123; a[0] = qpow(a[0], p - 2); return; &#125; ll len1 = len / 2; ll *f0 = new ll [len * 2]; for (ll i = 0; i &lt; len1; i++) f0[i] = a[i]; for (ll i = len1; i &lt; len * 2; i++) f0[i] = 0; poly_inv(f0, len1); for (ll i = len1; i &lt; len * 2; i++) f0[i] = 0; ntt(f0, len * 2, 1), ntt(a, len * 2, 1); for (ll i = 0; i &lt; len * 2; i++) a[i] = ((2 * f0[i] % p - a[i] * (long long)f0[i] % p * f0[i] % p) % p + p) % p; ntt(a, len * 2, -1); for (ll i = len; i &lt; len * 2; i++) a[i] = 0; delete []f0;&#125;void poly_derivation(ll *a, ll len)&#123; for (ll i = 1; i &lt; len; i++) a[i - 1] = a[i] * (long long)i % p; a[len - 1] = 0;&#125;void poly_lintergal(ll *a, ll len)&#123; for (ll i = len + 1; i &gt;= 1; i--) a[i] = a[i - 1] * (long long)qpow(i, p - 2) % p; a[0] = 0;&#125;void poly_ln(ll *a, ll len)&#123; ll *b = new ll [len * 2]; for (ll i = 0; i &lt; len; i++) b[i] = a[i]; for (ll i = len; i &lt; len * 2; i++) b[i] = 0; poly_derivation(b, len); poly_inv(a, len); ntt(a, len * 2, 1); ntt(b, len * 2, 1); for (ll i = 0; i &lt; len * 2; i++) a[i] = a[i] * (long long)b[i] % p; ntt(a, len * 2, -1); poly_lintergal(a, len); for (ll i = len; i &lt; len * 2; i++) a[i] = 0; delete []b;&#125;ll mod_sqrt(ll x)&#123; for (ll i = 0; i &lt; p; i++) if (i * (long long)i % p == x) return x; printf("No Solution\n"); return 0;&#125;void poly_sqrt(ll *a, ll len)&#123; if (len == 1) &#123; a[0] = mod_sqrt(a[0]); return; &#125; ll len1 = len / 2; ll *f0 = new ll [len * 2]; for (ll i = 0; i &lt; len1; i++) f0[i] = a[i]; for (ll i = len1; i &lt; len * 2; i++) f0[i] = 0; poly_sqrt(f0, len1); for (ll i = len1; i &lt; len * 2; i++) f0[i] = 0; ll *tmp = new ll [len * 2]; for (ll i = 0; i &lt; len * 2; i++) tmp[i] = f0[i] * 2 % p; poly_inv(tmp, len); ntt(f0, len * 2, 1); for (ll i = 0; i &lt; len * 2; i++) f0[i] = f0[i] * (long long)f0[i] % p; ntt(f0, len * 2, -1); for (ll i = 0; i &lt; len; i++) f0[i] = (f0[i] + a[i]) % p; ntt(f0, len * 2, 1); for (ll i = len; i &lt; 2 * len; i++) tmp[i] = 0; ntt(tmp, len * 2, 1); for (ll i = 0; i &lt; len * 2; i++) a[i] = tmp[i] * (long long)f0[i] % p; ntt(a, len * 2, -1); for (ll i = len; i &lt; len * 2; i++) a[i] = 0; delete []tmp; delete []f0;&#125;void poly_exp(ll *a, ll len)&#123; if (len == 1) &#123; a[0]++; return; &#125; ll len1 = len / 2; ll *f0 = new ll [len * 2]; for (ll i = 0; i &lt; len1; i++) f0[i] = a[i]; for (ll i = len1; i &lt; len * 2; i++) f0[i] = 0; poly_exp(f0, len1); for (ll i = len1; i &lt; len * 2; i++) f0[i] = 0; ll *lnf0 = new ll [len * 2]; for (ll i = 0; i &lt; len * 2; i++) lnf0[i] = f0[i]; poly_ln(lnf0, len); a[0]++; for (ll i = 0; i &lt; len; i++) &#123; a[i] -= lnf0[i]; if (a[i] &lt; 0) a[i] += p; &#125; ntt(a, len * 2, 1); ntt(f0, len * 2, 1); for (ll i = 0; i &lt; len * 2; i++) a[i] = a[i] * (long long)f0[i] % p; ntt(a, len * 2, -1); for (ll i = len; i &lt; len * 2; i++) a[i] = 0;&#125;void poly_qpow(ll *a, ll len, ll n)&#123; ll *tmp = new ll [len * 2]; for (ll i = 0; i &lt; len * 2; i++) tmp[i] = i &gt;= len ? 0 : a[i], a[i] = (i == 0); while (n &gt; 0) &#123; ntt(tmp, len * 2, 1); if (n &amp; 1) &#123; ntt(a, len * 2, 1); for (ll i = 0; i &lt; len * 2; i++) a[i] = a[i] * (long long)tmp[i] % p; ntt(a, len * 2, -1); for (ll i = len; i &lt; len * 2; i++) a[i] = 0; &#125; for (ll i = 0; i &lt; len * 2; i++) tmp[i] = tmp[i] * (long long)tmp[i] % p; ntt(tmp, len * 2, -1); for (ll i = len; i &lt; len * 2; i++) tmp[i] = 0; n &gt;&gt;= 1; &#125; delete []tmp;&#125;ll lagrange_inversion(ll *aa, ll len, ll n)&#123; ll *a = new ll [len * 2]; for (ll i = 0; i &lt; len; i++) a[i] = aa[i]; for (ll i = len; i &lt; len * 2; i++) a[i] = 0; for (ll i = 1; i &lt; len; i++) a[i - 1] = a[i]; poly_inv(a, len); poly_qpow(a, len, n); ll ans = a[n - 1] * (long long)qpow(n, p - 2) % p; delete []a; return ans;&#125;inline ll Ext_Gcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b==0)&#123; x=1; y=0; return a; &#125; ll d = Ext_Gcd(b, a%b, y, x); y-=a/b*x; return d;&#125;inline ll Inv(ll a, ll n)&#123; ll x,y; ll d = Ext_Gcd(a,n,x,y); if(d == 1) return ((x%n)+n)%n; return -1;&#125;ll a[1000000],b[1000000], n,m,k,_, len = 1ll;ll c[1000000],d[1000000];signed main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; n++;m++; for(ll i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(ll i=0;i&lt;m;i++) cin&gt;&gt;b[i]; len=131072; poly_ln(a,len); poly_ln(b,len); for(ll i=0;i&lt;len;i++) &#123; a[i]=a[i]%p*i%p; b[i]=b[i]%p*i%p; if(!(i &amp; 1ll)) &#123; b[i]=b[i]%p*(p-1)%p; a[i]=a[i]%p*(p-1)%p; &#125; &#125; for(ll i=0;i&lt;len;i++) &#123; c[i]=(a[i]%p*b[i]%p)%p*Inv(i,p)%p; if(!(i &amp; 1ll)) &#123; c[i]=c[i]%p*(p-1)%p; &#125; &#125; poly_exp(c,len); for(ll i=0;i&lt;k;i++) &#123; cout&lt;&lt;c[i]%p&lt;&lt;" "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>Opentrains</tag>
        <tag>暴力</tag>
        <tag>二次剩余</tag>
        <tag>概率算法</tag>
        <tag>非完美算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 542 (Div. 1) 比赛总结]]></title>
    <url>%2F2019%2F02%2F26%2FCodeforces-Round-542-Div-1-%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview Status A1 A2 B C D E Contest 00:19 00:18 01:23 —— —— —— Upsolve OK OK OK AC AC Attempt + + +1 +2 + Difficulty 1700 1800 2200 2300 2800 3200 比赛链接 第一次在div. 1上分，现在rating 1997 感觉还行。 nocriz 聚聚 Rank 61，马上就要红啦！%%% 收获： Solved 3 out of 6 Upsolved 5 out of 6 Rank 207 out of 447 想出了B题的一种很有意思的构造 不足： 代码速度还是不够快，C题没有写完。 Prob A. 签到这道题就是个暴力，不知道为什么还要出成两个subtask。我觉得 $O(n\log n)$ 的做法其实也挺好想的。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 5505;ll n, m, cho[maxn], cnt[maxn], _f, _t, d[maxn];ll dist(int f, int t) &#123; if(f == t) return 0; if(t &gt; f) return t - f; else return n + t - f;&#125;int main() &#123; memset(d, 0x3f, sizeof d); scanf("%lld%lld", &amp;n, &amp;m); rep(i, m) &#123; scanf("%lld%lld", &amp;_f, &amp;_t); cnt[_f]++; d[_f] = min(d[_f], dist(_f, _t)); &#125; for(int i = 1; i &lt;= n; ++i) &#123; ll ans = 0; rep(j, n) if(cnt[j] &gt; 0) &#123; ans = max(ans, dist(i, j) + (cnt[j] - 1) * n + d[j]); &#125; printf("%lld ", ans); &#125; return 0;&#125; Prob B. 有趣构造题Description给定一个长度为 $n$ 的数组 $a$，要求出以下的最大值：$$\max_{0\leq l\leq r\leq n-1} \sum_{l\leq i \leq r} (r-l+1)\cdot a_i$$ Alice想出了下面的 $O(n)​$ 的优秀假算法，你想要hack她。给定 $k​$ ，你需要找到一个长度不超过 $2000​$ ，每个元素不超过 $10^6​$ 的数组，使得正确答案正好比Alice的答案大 $k​$ 12345678910111213function find_answer(n, a) # Assumes n is an integer between 1 and 2000, inclusive # Assumes a is a list containing n integers: a[0], a[1], ..., a[n-1] res = 0 cur = 0 k = -1 for i = 0 to i = n-1 cur = cur + a[i] if cur &lt; 0 cur = 0 k = i res = max(res, (i-k)*cur) return res Solution我的构造我的构造方法只需要用到 $0$, $-1$ 以及一个较大的数 $x$。构造的序列形式是这样的： $$\underbrace{0,0,\cdots,0} _ {m zeroes},-1, \underbrace{0,0,\cdots,0} _ {n-m-2 zeroes} , x$$ 显然，Alice认为的最优串是后面 $n-m-1$ 个数，答案是$(n-m-1) \cdot x​$ 正确答案是所有的数，答案是 $n \cdot (x-1)​$ 两者之差为：$n\cdot (x-1) - (n-m-1) \cdot x = k$ 化简得：$(m+1)x=n+k$。因此可以直接枚举 $n$（$1\leq n\leq 2000$），检查它有没有小于 $2000$ 的因数 $d$，且$(n+k)/d\leq10^6$。 可以保证一定有解，不过分析还稍微有些麻烦。 在 $10^6 - 1000$ 以下，枚举连续 $1000$ 个数一定会枚举到 $1000$ 的倍数，因此可以保证一定有 $1000$ 这个解； 对于其他情况，由于数组长度限制，较难分析一些，但是实践表明这个因数 $d$ 枚举到 $1100$ 都能找到解。 std构造这种构造方法更为简单，易于分析。构造形式是这样的： $$-1, \underbrace{a_1, a_2, \cdots, a_{n-1}}_{sum = S}​$$ 这样，差值就为$(S-1) \cdot n - S\cdot (n-1)= S-n​$。使得 $S​$ 达到 $ 10^9​$ 很容易，贪心即可。 Code (Solution 1) 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 100200, V = 1000000;ll k;ll lim(ll x) &#123; return (V - 1 - x) * x; &#125;ll lim2(ll n) &#123; return (n - 1) * V - n; &#125;int main() &#123; cin &gt;&gt; k; for(int i = 1; i &lt;= 1999; ++i) &#123; if(k % i == 0 &amp;&amp; lim(i) &gt;= k) &#123; ll need = k / i + 1 + i; printf("%d\n", i + 1); rep(j, i) printf("-1 "); printf("%lld\n", need); return 0; &#125; &#125; for(int n = 2; n &lt;= 2000; ++n) &#123; for(int t = n - 1; t &gt; 0; --t) if((k + n) % t == 0) &#123; ll B = n - t, A = (k + n) / t; if(A &gt; V) continue; printf("%d\n", n); rep(i, n - B - 1) printf("0 "); printf("-1 "); rep(i, B - 1) printf("0 "); printf("%lld\n", A); return 0; &#125; &#125; puts("-1"); return 0;&#125; Prob C. dp, trie(?), 后缀树Solution显然有直接dp+hash的做法，不过复杂度会多乘上8，好像这道题卡这个常数。。。 可以考虑放在trie树上优化dp的转移过程。考虑一个个将字符插入的过程，若插入$s[i]$，那么就相当于在trie上插入这么一个字符串：$s[i, i-1, i-2, \cdots, 1]$，每次新建了一个节点时，就将向上三代祖先的dp值加过来，如果第四代祖先也合法那么也加入。这么做实际上是暴力建出了原串reverse后的后缀树，在后缀树上dp。（蒟蒻现在还不会写后缀树，以上纯属口胡） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const int maxn = 200200, MOD = 1000000007;struct node &#123; node *ch[2], *fa; int dp, v;&#125; trie[9000000], *Null, *rt = trie + 1;int tot = 1;void add(int &amp;x, int y) &#123; x += y; if(x &gt;= MOD) x -= MOD;&#125;node* New(node* fa) &#123; tot++; assert(tot &lt; 9000000); trie[tot].ch[0] = trie[tot].ch[1] = Null; trie[tot].fa = fa; return trie + tot;&#125;int n, a[maxn], ans = 0;bool Valid(int a1, int a2, int a3, int a4) &#123; if(a1==1 &amp;&amp; a2==1 &amp;&amp; a3==0 &amp;&amp; a4==0) return false; if(a1==1 &amp;&amp; a2==0 &amp;&amp; a3==1 &amp;&amp; a4==0) return false; if(a1==0 &amp;&amp; a2==1 &amp;&amp; a3==1 &amp;&amp; a4==1) return false; if(a1==1 &amp;&amp; a2==1 &amp;&amp; a3==1 &amp;&amp; a4==1) return false; return true;&#125;void insert(int r) &#123; node* p = rt; for(int i = r; i &gt; 0; --i) &#123; if(p-&gt;ch[a[i]] == Null) &#123; p-&gt;ch[a[i]] = New(p); p = p-&gt;ch[a[i]]; p-&gt;v = a[i]; node *anc = p-&gt;fa; int x[4]; x[0] = p-&gt;v; if(anc != Null) &#123; add(p-&gt;dp, anc-&gt;dp); x[1] = anc-&gt;v; anc = anc-&gt;fa; if(anc != Null) &#123; add(p-&gt;dp, anc-&gt;dp); x[2] = anc-&gt;v; anc = anc-&gt;fa; if(anc != Null) &#123; add(p-&gt;dp, anc-&gt;dp); x[3] = anc-&gt;v; anc = anc-&gt;fa; if(anc != Null &amp;&amp; Valid(x[3], x[2], x[1], x[0])) &#123; add(p-&gt;dp, anc-&gt;dp); &#125; &#125; &#125; &#125; add(ans, p-&gt;dp); &#125; else p = p-&gt;ch[a[i]]; &#125;&#125;int main() &#123; rt-&gt;dp = 1, rt-&gt;fa = Null, rt-&gt;v = -1; scanf("%d", &amp;n); rep(i, n) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; ++i) &#123; insert(i); printf("%d\n", ans); &#125; return 0;&#125; Prob D. 分块还没补。。。 Prob E. 博弈Solution 以1为根，首先询问 $n-1$ 次，问出每个子树的大小。 然后从子树大小从小到大的顺序确定每个节点的父亲。这个过程需要二分。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int query(vector&lt;int&gt; T, int v) &#123; if (!T.size()) return 0; printf("1\n1\n%d\n", (int)T.size()); for (int x : T) printf("%d ", x); printf("\n%d\n", v); fflush(stdout); int res; read(res); return res;&#125;int sz[505];vector&lt;int&gt; V, S, E[505];bool cmp(int i, int j) &#123; return sz[i] &lt; sz[j]; &#125;int main() &#123; int n; read(n); for (int i = 2; i &lt;= n; ++i) V.push_back(i); for (int i = 2; i &lt;= n; ++i) sz[i] = query(V, i); sort(V.begin(), V.end(), cmp); for (int x : V) &#123; int k = query(S, x); while (k--) &#123; int l = 0, r = S.size() - 2, res = r + 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; vector&lt;int&gt; tmp; for (int i = 0; i &lt;= mid; ++i) tmp.push_back(S[i]); if (query(tmp, x) &gt; 0) res = mid, r = mid - 1; else l = mid + 1; &#125; E[x].push_back(S[res]); S.erase(S.begin() + res); &#125; S.push_back(x); &#125; for (int x : S) E[1].push_back(x); puts("ANSWER"); for (int i = 1; i &lt;= n; ++i) for (int v : E[i]) printf("%d %d\n", i, v); fflush(stdout); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>构造</tag>
        <tag>后缀树</tag>
        <tag>trie</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opentrains 1513 比赛报告]]></title>
    <url>%2F2019%2F02%2F23%2FOpentrains-1513%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Petrozavodsk Winter-2018. AtCoder ContestOverview Status A B C D E F G H I J K Contest 01:10 —— —— —— —— 04:24 —— —— —— —— 02:12 Upsolve OK AC Y AC OK Y AC OK Attempt +2 +1 * + *5 +1 Total AC 103 4 13 24 36 89 0 10 31 2 96 比赛链接 AtCoder上对应的比赛APC001的链接 whzzt的APC001题解链接 注意这个比赛Opentrains上是Atcoder Petrozavodsk Contest 的Div. 1版本，但是C题、D题、I题APC001上是没有的。 第二次开火车。这次的题目感觉挺不错，思维题居多，代码量不太大。要是推荐题目的话，这里的每道题目都是挺有idea的！但是还是太菜了啊，不知道这么开火车是不是有点浪费这么好的题目。。。这一次算是经历千辛万苦总算签完到了，可是用的时间实在是太多了。以后继续加油吧！ 感觉这一场还是收获满满啊：（虽然现场打得不算出色） Solved 3 out of 11 Upsolved 6 out of 11 学到了有理数二分与Stern-Brocot树 看了2009国家集训队论文金斌《欧几里得算法的应用》以及《一类分数问题的应用》 学到了一系列类欧几里得算法 熟悉了Pick定理 Rank 81 out of 113。 这次比赛踩过的坑点： A题假算法 K题没开long long，少判断连通图的情况 Prob. A 交互题，二分Solution这道题我要给我们队谢罪。。。场上假了两次，后来才想清楚正确做法。。。 做法就是如果知道一段区间$[l,r]$的左端点颜色 $lcolor$ ，那么每个点的颜色都是可以有一个期待值的，而根据题意，一定会有至少一个点不满足期待值。二分中点，那么根据中点是否符合期待，可以断定不符合期待值的点的位置一定在左区间还是右区间，从而递归下去，找出这个期待值就可以了。具体实现细节还挺精妙，详细看代码吧。 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;int n, tp, q = 0;map&lt;int, int&gt; qe;int query(int pos) &#123; if(qe.find(pos) != qe.end()) return qe[pos]; q++; printf("%d\n", pos); fflush(stdout); string res = ""; cin &gt;&gt; res; if(res == "Vacant") exit(0); qe[pos] = res == "Male"; return res == "Male";&#125;void solve(int l, int r, int lcolor) &#123; if(l == r) &#123; query(l); return; &#125; if(l == r - 1) &#123; query(l), query(r); return; &#125; int mid = (l + r) &gt;&gt; 1, qr = query(mid); if(qr == (((mid - l) &amp; 1) + lcolor) % 2) solve(mid, r, qr); else solve(l, mid - 1, lcolor);&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt; n; ++i) expect[i] = expect[i - 1] ^ 1; solve(0, n - 1, query(0)); return 0;&#125; Prob. F 有思维含量的贪心or树dpSolution这题当时还想了好久，cyy和wzk都说是好题，我还以为是什么神奇点分治之类的做法呢。。后来想了想贪心对的面挺大，一写居然一次OK了，感觉还行，就是想的时间有点过长了。 解法： 考虑菊花图的情况，如果中心点有 $k$ 个邻居，则答案为 $k-1$ 。因此对于任意一个点，周围如果有 $k$ 个邻居，则最多只能有一个邻居子树中没有天线。因此利用这个性质来树dp。 但是要考虑父节点一侧的贡献极为麻烦，因此我们考虑从度数超过3的点开始dp，就可以不用管父节点的问题。 如果树是一条链，则答案为1. 否则，按照题意贪心即可。注意特殊情况：孤立节点把答案记为0，合并时要注意孤立点。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 200200;vector&lt;int&gt; G[maxn];int dp[maxn], n, _f, _t, deg[maxn], rt = -1;int dfs(int v, int fa) &#123; int ans = 0; bool nhas = true; for(auto g : G[v]) &#123; if(g == fa) continue; int son = dfs(g, v); ans += son; if(son == 0) &#123; if(nhas) nhas = false; else ans++; &#125; &#125; return ans;&#125;int main() &#123; scanf("%d", &amp;n); rep(i, n - 1) &#123; read(_f, _t); _f++, _t++; G[_f].push_back(_t); G[_t].push_back(_f); deg[_f]++, deg[_t]++; &#125; rep(i, n) if(deg[i] &gt;= 3) rt = i; if(rt == -1) &#123; puts("1"); return 0; &#125; else &#123; printf("%d\n", dfs(rt, -1)); &#125; return 0;&#125; Prob. K 有思维含量的结论，树Solution这道题还是挺有意思的。一种思路是启发式合并连通块，是 $O(n\log^2 n)$的，我场上想到的就是这种做法。可是还有更加优雅简洁的做法：（yzh想出的） 如果把每个连通块当做新图的节点的话，题中加边的过程就是一个建树的过程，而每个连通块选几个节点就是这个节点的度数。那么有 $k$ 个节点的树，每个点的度数 $deg_v$ 满足什么条件时才能保证能构造出一棵树呢？ $\sum\limits_{i=1}^k deg_i = 2 (k-1)$，这是因为要连成一棵树就需要$k-1$条边 $\forall i \in \{1,2,\cdots,n\}, deg_i \geq 0$，这是因为要保证每个点都连通。 实际上这些也已经够了。因此只需要： 把每个连通块中的最小点权加入答案，然后剩下的点权放在一起排序，一直从小到大取，直到选出的点数达到 $2(k-1)$。 感觉这个做法还是很精妙的。不过千万不要忘记特判连通图的情况，连通图答案就是0，不需要加边。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#pragma GCC optimize("-O3", "-Ofast", "inline", "-ffast-math", "-funroll-loops")using namespace std;typedef long long ll;const int maxn = 200200;vector&lt;int&gt; G[maxn];multiset&lt;int&gt; tot;int n, m, a[maxn], _f, _t, cc = 0, vis[maxn], mn;ll ans = 0;void dfs(int v, int fa) &#123; vis[v] = cc; mn = min(mn, a[v]); tot.insert(a[v]); for(auto g : G[v]) if(!vis[g]) dfs(g, v);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int need = n - 1 - m; if(need == 0) &#123; puts("0"); return 0; &#125; if(n / 2 &lt; need) &#123; puts("Impossible"); return 0; &#125; need &lt;&lt;= 1; for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;_f, &amp;_t); _f++, _t++; G[_f].push_back(_t); G[_t].push_back(_f); &#125; for(int i = 1; i &lt;= n; ++i) if(!vis[i]) &#123; cc++, mn = 0x3f3f3f3f; dfs(i, -1); tot.erase(tot.find(mn)); ans += mn; need--; &#125; while(need--) &#123; auto beg = tot.begin(); ans += *beg; tot.erase(tot.find(*beg)); &#125; cout &lt;&lt; ans; return 0;&#125; 赛后补题Prob. E 异或好题，状压dpDescription有一棵有边权的树，你可以选择其中一条链，将链中的每一条边的边权都异或上一个你指定的数 $x$ ，问至少要操作几次，才能使所有边的边权都变为 $0$。节点数 $n \leq 2 \cdot 10^5$ ，边权 $0 \leq w \leq 15 $ Solution这道题非常美妙！感觉这么好的题简直百里挑一！ 首先发现链修改比较棘手，如果是单点修改，那么问题就会变得简单不少。如何转化呢？我们先把边权转化为点权：令每个点的点权为与其相连的所有边的边权的异或和。考虑到异或的性质，链修改就变为了两个单点修改了。 于是，我们把每个点的点权求出来，得到一个点权数组。我们可以进行的操作是选择其中一个或两个数（一个对应选择从根节点开始的一条链的情况），异或上 $x$，问至少需要多少操作才能使所有数都变为0. 显然有一个贪心策略：如果某种点权 $w$ 出现了 $2$ 次以上，那么如果我们把这两个点权都异或上 $w$ ，就可以消去两个数，我们应该首先做这件事。因此对于每种点权 $w$以及出现次数 $c_w$，我们都将答案增加 $\left[\frac{c_w}{2}\right]$，然后将出现次数变为 $c_w % 2$。 之后，每一种点权都最多出现一次，而点权只有$[0,15]$这16种，因此一个枚举子集的状压dp即可在 $O(3^p)$时间复杂度内解决问题。注意需要进行一些预处理。 Bonus：最后一步的 $n$ 个数异或的问题，能否证明是NPC的？或者，有无多项式做法？ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 200200;int a[maxn], n, _f, _t, _w, cnt[maxn], dp[1 &lt;&lt; 17], ans = 0;int Xor[1 &lt;&lt; 17], popcount[1 &lt;&lt; 17];int main() &#123; scanf("%d", &amp;n); rep(i, n - 1) &#123; scanf("%d%d%d", &amp;_f, &amp;_t, &amp;_w); a[_f] ^= _w; a[_t] ^= _w; &#125; for(int i = 0; i &lt; n; ++i) cnt[a[i]]++; cnt[0] = 0; for(int i = 1; i &lt; 16; ++i) &#123; int ad = cnt[i] / 2; ans += ad, cnt[i] -= 2 * ad; &#125; int S0 = 0; for(int i = 0; i &lt; 16; ++i) if(cnt[i]) S0 += 1 &lt;&lt; i; for(int i = 1; i &lt; 1 &lt;&lt; 16; ++i) &#123; for(int j = 0; 1 &lt;&lt; j &lt;= i; ++j) if(i &gt;&gt; j &amp; 1) &#123; Xor[i] = Xor[i ^ (1 &lt;&lt; j)] ^ j; break; &#125; popcount[i] = __builtin_popcount(i); &#125; memset(dp, 0x3f, sizeof dp); dp[0] = 0; for(int S = 1; S &lt;= S0; ++S) &#123; dp[S] = popcount[S]; for(int T = S; T; T = (T - 1) &amp; S) if(Xor[T] == 0) &#123; dp[S] = min(dp[S], dp[S ^ T] + popcount[T] - 1); &#125; &#125; printf("%d\n", dp[S0] + ans); return 0;&#125; Prob. I 线段树，注意溢出情况Description你要维护一个序列，支持以下三种操作： $ADD [l, r] v$：区间 $[l, r]$中每个数加v。 $DIV [l, r] v$ ：区间 $[l,r]$ 中每个数除以 $v$，下取整。 $MAX [l,r]$：询问区间 $[l,r]$的最大值。 Solution显然这是一个线段树下传懒惰标记的题目。如何定义可以合并的标记呢？考虑更一般的情况，我们定义标记为： $$tag(x) = \left[\frac{x+a}{b}\right]$$ 这样，考虑$a=a_1,b=b_1​$ 的标记 $t_1​$ 和 $a=a_2,b=b_2​$ 的标记 $t_2​$，它们如何合并呢？这里假如先进行标记$t_1​$，后进行标记$t_2​$ $$t_2 \circ t_1(x) = \left[\frac{[\frac{x+a_1}{b_1}] + a_2}{b_2}\right] = \left[\frac{x+a_1+a_2\cdot b_1}{b_1\cdot b_2}\right]​$$ 这样，我们就在数学上解决了问题。什么？会WA？因为这么做每次都使被合并的标记的 $b$ 相乘，因此可能会使标记中的 $b$ 溢出。那怎么办呢？我们改一下标记的定义： $$tag(x) = \left[\frac{x+a}{b}\right] + c, 0 \leq a &lt; b$$ 可以看到，左边的是个近似真分数的形式。我们想要一直维持 $a\leq 10^9, b \leq 10^9$。实际上当 $b &gt; 10^9$ 时直接把左边的 分数进行修改就好了，因为左边无论代入什么 $x$ 答案都应当是0.这样我们也解决了代码中的难题。 注意：这种修改方式是很特殊的，当时使用不正确的修改方式导致WA on test 35。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;#define int llconst int BUFF_SIZE = 1 &lt;&lt; 20;char BUFF[BUFF_SIZE],*BB,*BE;#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const ll INF = 0x3f3f3f3f, maxn = 200200;int n, q, a[maxn], _op, _l, _r, _x;struct tag &#123; ll a, b, c; tag(ll aa=0, ll bb=1, ll cc=0): a(aa), b(bb), c(cc) &#123; &#125; tag operator + (const tag&amp; y) const &#123; ll tmp = a + (c + y.a) * b; ll rc = tmp / (y.b * b) + y.c; ll ra = tmp % (y.b * b); ll rb = y.b * b; assert(y.a &lt;= INF &amp;&amp; y.b &lt;= INF); if(rb &gt; INF) &#123; ra = max((ll)0, ra - rb + INF); rb = INF; &#125; assert(ra &lt; rb &amp;&amp; rb &lt;= INF); return tag(ra, rb, rc); &#125; bool operator == (const tag&amp; t) const &#123; if( a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c) return true; else return false; &#125;&#125; Empty;struct segtree &#123; #define lson (o &lt;&lt; 1) #define rson (o &lt;&lt; 1 | 1) ll maxv[maxn &lt;&lt; 2]; tag tg[maxn &lt;&lt; 2]; void pushup(int o) &#123; maxv[o] = max(maxv[lson], maxv[rson]); &#125; void pushdown(int o, int l, int r) &#123; if(tg[o] == Empty) return; tg[lson] = tg[lson] + tg[o]; tg[rson] = tg[rson] + tg[o]; maxv[lson] = (maxv[lson] + tg[o].a) / tg[o].b + tg[o].c; maxv[rson] = (maxv[rson] + tg[o].a) / tg[o].b + tg[o].c; tg[o] = Empty; &#125; void build(int o, int l, int r, int *arr) &#123; tg[o] = tag(); if(l == r) &#123; maxv[o] = arr[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid, arr); build(rson, mid + 1, r, arr); pushup(o); &#125; void modify(int o, int l, int r, int ql, int qr, tag m) &#123; if(ql &lt;= l &amp;&amp; r &lt;= qr) &#123; tg[o] = tg[o] + m; maxv[o] = (maxv[o] + m.a) / m.b + m.c; return; &#125; int mid = (l + r) &gt;&gt; 1; pushdown(o, l, r); if(ql &lt;= mid) modify(lson, l, mid, ql, qr, m); if(qr &gt; mid) modify(rson, mid + 1, r, ql, qr, m); pushup(o); &#125; ll query(int o, int l, int r, int ql, int qr) &#123; if(ql &lt;= l &amp;&amp; r &lt;= qr) return maxv[o]; pushdown(o, l, r); int mid = (l + r) &gt;&gt; 1; ll ans = 0; if(ql &lt;= mid) ans = max(ans, query(lson, l, mid, ql, qr)); if(qr &gt; mid) ans = max(ans, query(rson, mid + 1, r, ql, qr)); return ans; &#125;&#125; seg;signed main() &#123; read(n, q); rep(i, n) read(a[i]); seg.build(1, 1, n, a); rep(i, q) &#123; read(_op, _l, _r, _x); _l++, _r++; if(_op == 0) seg.modify(1, 1, n, _l, _r, tag(0, 1, _x)); else if(_op == 1) seg.modify(1, 1, n, _l, _r, tag(0, _x, 0)); else write(seg.query(1, 1, n, _l, _r)), putchar('\n'); &#125; return 0;&#125; Prob. C 构造，三角形内整点，Picks定理，Stern-Brocot树Description给你三角形三个顶点的坐标 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，要求你在里面找到任意一个整点。如果没有，输出-1。 SolutionPick定理在这道题中可以判断有解无解。 Pick定理：简单多边形内部的整点数量 $I$ 与边上整点数量 $B$ 、多边形面积 $S$ 有以下关系： $$I=A+1-B/2$$ 解法一即std做法有点毒瘤，这里不说了。 我觉得非常优美的解法是讲题时一个营员提出的做法。首先可以竖直把三角形切成两个小三角，然后解决这两个三角形的问题。如果以不在竖直边上的点为坐标原点建立坐标系，那么整点就是满足 $lo \leq \frac{y}{x} \leq hi$ and $x \leq m$ 的点的集合。如何找到其中的一个点？我学到了两种新科技： Stern-Brocot树Stern-Brocot树。用这种神奇的构造结构可以实现对有理数的二分。具体见具体数学第96页。 Stern Brocot tree是一棵二叉树，初始为 $(\frac01, \frac10)$ ，每次在$\frac mn$和$\frac {m^{‘}} {n^{‘}}$之间插入 $\frac{(m + m’)}{(n+n’)}​$，如此不断生成下一层。 Stern Brocot tree有很多神奇而优美的性质： Stern Brocot tree树可以生成所有的有理数，且每个数只会出现恰好一次 Stern Brocot tree生成的分数都是不可约的，即$gcd(m,n) = 1$ 任意两个在构造时是相邻的分数 $m/n$ 和 $ m’/n’$，有 $mn’ – m’n = 1$ 中序遍历Stern Brocot tree树可以得到有序的序列，即具有BST性质。 类欧几里得还有更加新奇的科技！又是一种类欧几里得算法！主要用来解决以下问题：找到位于 $l=\frac{m}{n}​$ 与 $r=\frac{p}{q}​$ 之间的分母最小的分数$\frac yx​$。 首先，如果 $\frac mn​$与 $\frac pq​$ 之间有整数，那么问题已经解决了； 否则，一定有$r-l\leq1$。两个数同时减去 $l$ 的整数部分 $[l]$，得到的答案也是等价的。即：问题转化为$m&lt;n,p\leq q$ 的情况。 这时，要让 $y$ 最小， $x$ 一定也要最小，因此，可以两边直接取倒数，得到：$\frac qp &lt; \frac xy &lt; \frac nm$ 这样递归下去即可。可以看到左右边界化为小于1的步骤相当于取模，分子分母量级会减小一半，因此复杂度为 $\log \min(n, q)​$。 有了这种算法，我们先找到满足$lo &lt; \frac yx&lt; hi$的分母最小的分数，然后判断是否合法即可。注意需要保证 $lo, hi$ 的正负号，因此代码中一大部分内容都是分类讨论。 相关还有很多拓展问题，请参考下面两篇论文：（在后面的附录中将会给出） 2009 国家集训队论文 金斌《欧几里得算法的应用》 2007 国家集训队作业 杨哲《一类分数问题的研究》（这篇比较难拿到手，我是在UOJ群里问到的，mathew99给了我文献资源） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;#define ABS(x) ( (x)&gt;0 ? (x) : (-(x)) )struct frac &#123; ll nu, de; frac(ll a = 0, ll b = 1): nu(a), de(b) &#123; simplify(); &#125; void simplify() &#123; if(de &lt; 0) de = -de, nu = -nu; ll g = __gcd(ABS(nu), ABS(de)); nu /= g, de /= g; &#125; void flip() &#123; swap(nu, de); &#125; frac operator + (const frac&amp; rhs) const &#123; ll d = de * rhs.de / __gcd(ABS(de), ABS(rhs.de)); ll u = nu * (d / de) + rhs.nu * (d / rhs.de); return frac(u, d); &#125; frac operator - (const frac&amp; rhs) const &#123; ll d = de * rhs.de / __gcd(ABS(de), ABS(rhs.de)); ll u = nu * (d / de) - rhs.nu * (d / rhs.de); return frac(u, d); &#125; frac operator * (const frac&amp; rhs) const &#123; frac res = frac(nu * rhs.nu, de * rhs.de); res.simplify(); return res; &#125; frac operator - () const &#123; frac ret = *this; if(de &lt; 0) ret.de = -de; else ret.nu = -nu; return ret; &#125; frac operator / (const frac&amp; rhs) const &#123; return *this * frac(rhs.de, rhs.nu); &#125; bool operator &lt; (const frac&amp; rhs) const &#123; return nu * rhs.de &lt; rhs.nu * de; &#125; bool operator == (const frac&amp; rhs) const &#123; return nu * rhs.de == rhs.nu * de; &#125; bool operator &lt;= (const frac&amp; rhs) const &#123; return nu * rhs.de &lt;= rhs.nu * de; &#125; bool operator &gt; (const frac&amp; rhs) const &#123; return nu * rhs.de &gt; rhs.nu * de; &#125; ll floor() &#123; return nu / de; &#125; ll ceil() &#123; return nu / de + (nu % de != 0); &#125;&#125;;frac SearchBetween(frac l, frac r) &#123; l.simplify(), r.simplify(); ll lb = l.floor(); if(lb &gt; 0) l.nu -= lb * l.de, r.nu -= lb * r.de; if(r.nu &gt; r.de) return frac(1 + lb, 1); frac res = SearchBetween(frac(r.de, r.nu), frac(l.de, l.nu)); res.flip(); return frac(lb, 1) + res;&#125;struct Point &#123; frac x, y; Point() &#123; &#125; void simplify() &#123; x.simplify(); y.simplify(); &#125; Point(frac a, frac b): x(a), y(b) &#123; &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x == rhs.x &amp;&amp; y &lt; rhs.y); &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x + rhs.x, y + rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x - rhs.x, y - rhs.y); &#125; Point operator * (const frac&amp; fr) const &#123; return Point(x * fr, y * fr); &#125;&#125; p[3];ll LatticeCount(Point A, Point B) &#123; // [A, B) ll dx = ABS(A.x.nu - B.x.nu); ll dy = ABS(A.y.nu - B.y.nu); return __gcd(dx, dy);&#125;ll area2(Point P, Point Q, Point R)&#123; ll res = (Q.x.nu - P.x.nu) * (R.y.nu - P.y.nu) - (Q.y.nu - P.y.nu) * (R.x.nu - P.x.nu); return ABS(res);&#125;bool check() &#123; return area2(p[0], p[1], p[2]) + 2 - LatticeCount(p[0], p[1]) - LatticeCount(p[1], p[2]) - LatticeCount(p[2], p[0]) &gt; 0;&#125;bool Solved = false;Point Count(Point A, Point B, Point P) &#123; // A and B on the same vertical line, A.y &lt; B.y assert(A.x == B.x &amp;&amp; A.y &lt; B.y); if(!(P.x == frac() &amp;&amp; P.y == frac())) &#123; return Count(A - P, B - P, Point()) + P; &#125; if(A.x &lt; frac(0, 1)) &#123; Point res = Count(Point(-A.x, A.y), Point(-B.x, B.y), P); res.x = -res.x; return res; &#125; if(A.x &lt;= frac(1, 1)) return Point(); if(A.y.nu &lt; 0) &#123; if(B.y.nu &lt;= 0) &#123; Point res = Count(Point(B.x, -B.y), Point(A.x, -A.y), P); res.y = -res.y; return res; &#125; else &#123; Solved = true; return Point(frac(1, 1), frac(0, 1)); &#125; &#125; frac answer = SearchBetween(A.y / A.x, B.y / B.x); if(answer.de * A.x.de &gt;= A.x.nu) return Point(); Solved = true; return Point(answer.de, answer.nu);&#125;Point result;void Output() &#123; result.simplify(); assert(Solved); assert(result.x.de == 1 &amp;&amp; result.y.de == 1); printf("%lld %lld\n", result.x.nu, result.y.nu);&#125;void solve() &#123; Solved = false; for(int i = 0; i &lt; 3; ++i) scanf("%lld%lld", &amp;p[i].x.nu, &amp;p[i].y.nu); sort(p, p + 3); if(!check()) &#123; puts("-1 -1"); return; &#125; if(p[0].x == p[1].x) &#123; result = Count(p[0], p[1], p[2]); Output(); return; &#125; else if(p[1].x == p[2].x) &#123; result = Count(p[1], p[2], p[0]); Output(); return; &#125; else &#123; Point proj = p[0] + (p[2] - p[0]) * ((p[1].x - p[0].x) / (p[2].x - p[0].x)); Point low = min(proj, p[1]), high = max(proj, p[1]); ll val = low.y.floor() + 1; if(frac(val) &lt; high.y) &#123; result = Point(p[1].x, frac(val)); Solved = true; Output(); return; &#125; result = Count(low, high, p[0]); if(Solved) &#123; Output(); return; &#125; else &#123; result = Count(low, high, p[2]); Output(); return; &#125; &#125;&#125;int main() &#123; #ifdef FREOPEN freopen("in.txt", "r", stdin); // freopen("out.txt", "w", stdout); #endif int T; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125; 附录欧几里得算法的应用 一类分数问题的研究]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>线段树</tag>
        <tag>类欧几里得</tag>
        <tag>思维题</tag>
        <tag>Opentrains</tag>
        <tag>交互题</tag>
        <tag>树dp</tag>
        <tag>Stern-Brocot树</tag>
        <tag>Pick定理</tag>
        <tag>异或问题</tag>
        <tag>有理数二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opentrains 10434 比赛报告]]></title>
    <url>%2F2019%2F02%2F20%2FOpentrains-10434-%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Overview Status 1 2 3 4 5 6 7 8 9 10 11 Contest 00:27 01:24 00:16 02:39 FAIL Upsolve OK AC OK OK OK AC Attempt + + +2 + +2 + Total AC 340 19 147 182 332 25 42 239 100 96 98 比赛链接 第一次开火车，后半场一直卡在第11题上，感觉体验不怎么好。。。 最后Solved 4 out of 11，Rank 174 out of 357。 Prob. 1 （模拟）模拟题意即可。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const int maxn = 120;char s[maxn];int a[maxn][maxn], n, m, len;ll ans[maxn][maxn];ll simulate(int x, int y) &#123; ll res = a[x][y]; int cx = x, cy = y; for(int i = 1; i &lt;= len; ++i) &#123; if(s[i] == 'R') cy++; if(s[i] == 'L') cy--; if(s[i] == 'U') cx--; if(s[i] == 'D') cx++; if(cx &lt;= 0 || cx &gt; n) return 0; if(cy &lt;= 0 || cy &gt; m) return 0; res += a[cx][cy]; &#125; return res;&#125;void solve() &#123; scanf("%d%d%s", &amp;n, &amp;m, s + 1); len = strlen(s + 1); rep(i, n) rep(j, m) scanf("%d", &amp;a[i][j]); rep(i, n) rep(j, m) ans[i][j] = simulate(i, j); rep(i, n) &#123; rep(j, m) printf("%lld%c", ans[i][j], " \n"[j == m]); &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125; Prob. 3 裸的网络流，注意常数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int N = 202;const int V = 1001;map&lt;string, int&gt; nameMap;map&lt;int, int&gt; verMap[N];int verMap1[N][V];int vs[N];bool isInConf[N * V];const int S = 0;const int T = 1;int n, k;struct edge &#123; int from, to, cap, flow; edge() &#123;&#125; edge(int f, int t, int c, int fl) : from(f), to(t), cap(c), flow(fl) &#123;&#125;&#125;;vector&lt;edge&gt; edges;vector&lt;int&gt; e[N * V];void addEdge(int from, int to) &#123; e[from].push_back( edges.size() ); e[to].push_back( edges.size() + 1 ); edges.emplace_back( from, to, 1, 0 ); edges.emplace_back( to, from, 0, 0 );&#125;int app (int a) &#123; return 2 + a; &#125;int appVer(int a, int v) &#123; return 2 + n + vs[a] + v; &#125;int conf (int c) &#123; return 2 + n + vs[n] + c; &#125;int it[N * V];int cur;bool dfs(int v) &#123; if (it[v] == cur) return false; it[v] = cur; if (v == T) return true; for (int i : e[v]) &#123; edge &amp;ee = edges[i]; edge &amp;er = edges[i ^ 1]; if (ee.cap - ee.flow &gt; 0) &#123; if (dfs(ee.to)) &#123; ++ee.flow; --er.flow; return true; &#125; &#125; &#125; return false;&#125;bool dfsx() &#123; ++cur; return dfs(S);&#125;int main() &#123; scanf("%d", &amp;n); for (int a = 0; a &lt; n; ++a) &#123; addEdge(S, app(a)); char name[20]; int vn; scanf("%10s%d", name, &amp;vn); nameMap[name] = a; for (int v = 0; v &lt; vn; ++v) &#123; int ver; scanf("%d", &amp;ver); verMap[a][ver] = v; verMap1[a][v] = ver; addEdge(app(a), appVer(a, v)); &#125; vs[a + 1] = vs[a] + vn; &#125; scanf("%d", &amp;k); for (int c = 0; c &lt; k; ++c) &#123; addEdge( conf(c), T ); int m; scanf("%d", &amp;m); for (int i = 0; i &lt; m; ++i) &#123; char name[20]; int ver; scanf("%10s%d", name, &amp;ver); int a = nameMap[name]; int v = verMap[a][ver]; isInConf[ appVer(a, v) ] = true; addEdge( appVer(a, v), conf(c) ); &#125; &#125; for (int a = 0; a &lt; n; ++a) &#123; for (int v = 0; v &lt; verMap[a].size(); ++v) &#123; if (!isInConf[ appVer(a, v) ]) addEdge( appVer(a, v), T ); &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (!dfsx()) &#123; printf("No\n"); return 0; &#125; &#125; printf("Yes\n"); for (int a = 0; a &lt; n; ++a) &#123; for (int i : e[app(a)]) &#123; edge &amp;ee = edges[i]; if (ee.flow == 1) &#123; printf("%d ", verMap1[a][ee.to - 2 - n - vs[a]]); break; &#125; &#125; &#125; printf("\n"); return 0;&#125; Prob. 4 并查集启发式合并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int n, m, ecnt, _x, _y;vector&lt;int&gt; ans;const int maxn = 802000;struct node &#123; vector&lt;int&gt; my; set&lt;int&gt; no; int fa, id;&#125; dsu[maxn];bool merge(int x, int y) &#123; if(dsu[x].my.size() &gt; dsu[y].my.size()) swap(x, y); node &amp;c1 = dsu[x], &amp;c2 = dsu[y]; for(auto g : c1.my) if(c2.no.count(g)) return false; for(auto g : c1.my) c2.my.push_back(g); for(auto g : c1.no) c2.no.insert(g); c1.my.clear(); c1.no.clear(); c1.fa = c2.fa; return true;&#125;int find(int x) &#123; if(dsu[x].fa == dsu[x].id) return dsu[x].fa; int fa = dsu[x].fa; int rt = find(dsu[x].fa); dsu[x].fa = rt; for(auto g : dsu[x].my) dsu[rt].my.push_back(g); for(auto g : dsu[x].no) dsu[rt].no.insert(g); dsu[x].my.clear(); dsu[x].no.clear(); return rt;&#125;int main() &#123; read(n, m, ecnt); rep(i, n) dsu[i].id = i, dsu[i].my.push_back(i), dsu[i].fa = i; rep(i, m) &#123; scanf("%d%d", &amp;_x, &amp;_y); dsu[_x].no.insert(_y); dsu[_y].no.insert(_x); &#125; rep(i, ecnt) &#123; scanf("%d%d", &amp;_x, &amp;_y); _x = find(_x), _y = find(_y); if(_x == _y) &#123; ans.push_back(i); continue; &#125; if(merge(_x, _y)) ans.push_back(i); &#125; int sz = ans.size(); printf("%d\n", sz); for(int i = 0; i &lt; sz; ++i) printf("%d%c", ans[i], " \n"[i == sz - 1]); return 0;&#125; Prob. 5 签到12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll cnt;int main()&#123; cin &gt;&gt; cnt; while (cnt--) &#123; ll y; cin &gt;&gt; y; ll a1, b1, c1, a2, b2, c2; a1 = 1; b1 = -(y + 1); c1 = (y); a2 = 1; b2 = -(y - 1); c2 = (-y); if ((b1 != 0) &amp;&amp; (abs(b1) &lt;= 1000000) &amp;&amp; (abs(c1) &lt;= 1000000)) &#123; cout &lt;&lt; a1 &lt;&lt; " " &lt;&lt; b1 &lt;&lt; " " &lt;&lt; c1 &lt;&lt; endl; continue; &#125; if ((b2 != 0) &amp;&amp; (abs(b2) &lt;= 1000000) &amp;&amp; (abs(c2) &lt;= 1000000)) &#123; cout &lt;&lt; a2 &lt;&lt; " " &lt;&lt; b2 &lt;&lt; " " &lt;&lt; c2 &lt;&lt; endl; continue; &#125; &#125;&#125; Prob. 8 繁琐，模拟1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;typedef double ld;const int maxn = 100200;const ld eps = 1e-12;int n, m, s, _x, _y, a[maxn], has[maxn], cost[maxn];ld cur, ff, ct;vector&lt; pair&lt;ld,int&gt; &gt; tim;ld calc(pair&lt;ld, int&gt; t) &#123; ff -= (t.first - ct) * cur; cur += ld(a[t.second]) * ld(cost[t.second]); ct = t.first; return ff;&#125;void solve() &#123; tim.clear(); memset(a, 0, sizeof(int) * (n + 20)); read(n, m, s); cur = 0.0, ff = s, ct = 0.0; rep(i, m) read(_x), a[_x]++; rep(i, n) read(has[i], cost[i]); tim.push_back(&#123;0, 0&#125;); rep(i, n) if(a[i]) tim.emplace_back(ld(has[i]) / ld(a[i]), i); sort(tim.begin(), tim.end()); int p = -1; ld rem = s, ans = 0.0, rr = 0.0; for(int i = 0; i &lt; int(tim.size()); ++i) &#123; if((rr = calc(tim[i])) &lt; -eps) &#123; p = i - 1; break; &#125; rem = rr; &#125; if(p &lt; 0) p = int(tim.size()) - 1; ld cst = 0.0, tt = tim[p].first; rep(i, n) if(tt * ld(a[i]) + eps &gt; ld(has[i])) cst += a[i] * cost[i]; ans = tt + rem / cst; printf("%.12f\n", ans);&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125; Prob. 11 几何12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const double PI = 3.1415926535897932384;double alpha, phi;int tim[3];double to_deg(double rad) &#123; return rad / PI * 180.0; &#125;double to_rad(double deg) &#123; return deg / 180.0 * PI; &#125;void transform(int&amp; high, int&amp; low) &#123; int cnt = low / 60; high += cnt; low -= cnt * 60;&#125;void solve() &#123; scanf("%lf %lf\n", &amp;alpha, &amp;phi); scanf("%d:%d:%d\n", &amp;tim[0], &amp;tim[1], &amp;tim[2]); int ad = 0; if(alpha &lt; phi) ad = 6 * 3600; else &#123; double ans = to_deg(asin(tan(to_rad(phi)) / tan(to_rad(alpha)))) * 240.0; ad = int(ans + 0.5); &#125; tim[2] += ad; transform(tim[1], tim[2]); transform(tim[0], tim[1]); tim[0] %= 24; printf("%02d:%02d:%02d\n", tim[0], tim[1], tim[2]);&#125;int main() &#123; int T; scanf("%d\n", &amp;T); while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>Opentrains</tag>
        <tag>并查集</tag>
        <tag>球坐标系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 60 (Div 2) 比赛报告]]></title>
    <url>%2F2019%2F02%2F19%2FEducational-Codeforces-Round-60-Div-2-%E6%AF%94%E8%B5%9B%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Overview Status A B C D E F G Contest 00:03 00:08 00:45 01:12 WA(-4) —— —— Upsolve OK OK OK OK AC AC AC Attempt + + +1 + +4 + + Difficulty 1100 1000 1800 2000 2200 2600 2500 比赛链接 打教育场被教育系列。。。Rank 144 out of 5373，Rating Change：1970 -&gt; 2025。这一场从C开始都不是那么签到了，开始把CDE都看了，自闭了一会想出了C题二分的简单做法，打表得出D题的结论之后马上证明了，写个矩阵快速幂AC了。但是到了E题之后，被题意坑了，那个the interactor is not adaptive我理解为不会卡随机化，结果想了个假的随机算法，没有分析成功率都交上去。。。赛后发现只要理解为26进制数就可以得到确定性算法，感觉亏的不行。 G题赛后补了，感觉收获还蛮多的。听cyy讲了一个区间笛卡尔树的想题新思路，又听cyy讲了一个主席树做法，以及离线排序后多次修改的树状数组的做法，后来又想到一个单调栈的做法，感觉这道题还是蛮有启发性的。 赛时错误提交的分析：C题WA，原因是 long long· 的INF开小了。E题WA，RE，原因是算法假了。 Problem AB 签到A题代码： 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 100200;int a[maxn], mx = -1, n, ans = -1, p[maxn];int main() &#123; scanf("%d", &amp;n); rep(i, n) scanf("%d", &amp;a[i]), mx = max(mx, a[i]); rep(i, n) a[i] = a[i]==mx; a[0] = 1; rep(i, n) if(a[i]) &#123; p[i] = p[i - 1] + 1; ans = max(ans, p[i]); &#125; cout &lt;&lt; ans; return 0;&#125; B题代码： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 300300;ll n, m, k, a[maxn];int main() &#123; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;k); rep(i, n) scanf("%lld", &amp;a[i]); sort(a + 1, a + n + 1, greater&lt;ll&gt;()); ll period = m / (k + 1), left = m - period * (k + 1); ll ans = a[1] * (period * k + left) + a[2] * period; cout &lt;&lt; ans; return 0;&#125; Problem C. 稍需思考的二分如果 $t$ 时间已经存在方案，那么 $t$ 之后的所有时间都能存在方案，因此可以直接二分天数。注意二分上界别开小。 复杂度$O(n+ \log(10^{18}))$ 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define ABS(x) ( (x)&gt;0 ? (x) : (-(x)) )#define max(a, b) (((a) &gt; (b)) ? (a) : (b))#define min(a, b) (((a) &lt; (b)) ? (a) : (b))const int maxn = 100200;const ll INF = 0x3f3f3f3f3f3f3f3f;char s[maxn];ll n, xf, yf, xt, yt, xpre[maxn], ypre[maxn];bool check(ll t) &#123; ll pr = t / n, lf = t - pr * n; ll cx = xf + xpre[n] * pr + xpre[lf], cy = yf + ypre[n] * pr + ypre[lf]; ll dist = ABS(cx) + ABS(cy); return dist &lt;= t;&#125;int main() &#123; scanf("%lld%lld%lld%lld%lld%s", &amp;xf, &amp;yf, &amp;xt, &amp;yt, &amp;n, s + 1); xf -= xt, yf -= yt; for(int i = 1; i &lt;= n; ++i) &#123; xpre[i] = xpre[i - 1], ypre[i] = ypre[i - 1]; if(s[i] == 'U') ypre[i]++; else if(s[i] == 'D') ypre[i]--; else if(s[i] == 'L') xpre[i]--; else if(s[i] == 'R') xpre[i]++; &#125; ll l = 0, r = INF; while(l &lt; r) &#123; ll mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; if(l == INF) &#123; puts("-1"); return 0; &#125; cout &lt;&lt; l; return 0;&#125; Problem D. 数学，打表，矩阵题意有一个长度为 $n$ 的$01$序列，已知 $0$ 如果出现，那么一定会连续出现 $ m$ 的倍数个；$1$的出现没有限制。问一共有多少种不同的$01$序列？ $( n \leq 10^{18}, m \leq 100 )$ 题解思路1：$O(n/m)$打表。记连续 $m$ 个$ 0$ 为一个团 ，我们可以考虑枚举出现了多少个团。显然答案是： $$1 + \sum\limits_{c=0}^{\left[\frac{n}{m}\right]} C_{n-c\cdot m+c}^{c}$$ 固定 $m $ 打表，可以看到在 $n$ 处的答案满足：$dp[n] = dp[n-1] + dp[n-m]$，这个转移是线性齐次递推，矩阵转移即可，复杂度$O(m^3 \log n)$ 思路2：上述想法的数学证明。其实也很简单，只需考虑长度为 $n$ 的数列最后一位是团还是1。如果是团，那么答案是$dp[n-m]$；如果是1，答案是$dp[n-1]$。根据加法原理，应当把这两者加起来，因此得到了上面的式子。 代码( 1544 ms, 400 KB ) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef long long ll;const int MOD = 1000000000 + 7;ll n, m;inline int mo(int x) &#123; while(x &gt;= MOD) x -= MOD; while(x &lt; 0) x += MOD; return x; &#125;struct Mat &#123; vector&lt; vector&lt;int&gt; &gt; m; int sz; inline void init(int N) &#123; sz = N; m.resize(N + 3); rep(i, N) m[i].resize(N + 3, 0); &#125; inline void identity() &#123; rep(i, sz) m[i][i] = 1; &#125; Mat(int N = 0) &#123; init(N); &#125; vector&lt;int&gt;&amp; operator [] (int idx) &#123; return m[idx]; &#125; Mat operator * (const Mat&amp; rhs) const &#123; Mat res(sz); for(int i = 1; i &lt;= sz; ++i) for(int j = 1; j &lt;= sz; ++j) for(int k = 1; k &lt;= sz; ++k) res[i][j] = mo(res[i][j] + (1LL * m[i][k] * rhs.m[k][j] % MOD)); return res; &#125;&#125;;Mat qpow(Mat x, ll y) &#123; Mat res(x.sz); res.identity(); for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) res = res * x; return res;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; Mat mt(m); for(int r = 2; r &lt;= m; ++r) mt[r][r-1] = 1; mt[1][1] = mt[1][m] = 1; Mat res = qpow(mt, n); cout &lt;&lt; res[1][1]; return 0;&#125; Problem E. 交互题，26进制，中国剩余定理题意一个长度为$n$的字符串被打乱了，打乱后的字符串你是知道的，但是系统隐藏了打乱方式。你可以进行三次询问，每次询问一个字符串，系统将会返回这个字符串用相同方式打乱后的字符串，要求你询问后把打乱前的原字符串找出来。( $n\leq 10000$ ) 题解思路1 利用26进制。第一次按照26进制个位字母分配字符（即下标个位为 $x$，则字符为 &#39;a&#39; +x），第二次按十位分配，第三次按百位分配。这样甚至可以完成$n\leq 26^3 = 17576$的情况。 思路2 一种挺神奇的中国剩余定理的做法。按照$\pmod {23}$, $\pmod {25}$, $\pmod {27}$ 的结果分配字符，然后按照中国剩余定理得到答案（因为 $23,25,27$ 两两互质）。这样可以完成到 $n\leq 23\cdot 25\cdot 27=15525$ 的情况，但是不像第一种那么有普适性。 代码这里实现的是思路1，代码从开始的假随机做法改编，稍微有点乱。每次gen产生，deal进行合并 (1169 ms, 131200 KB) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define int llstring s, t;vector&lt; set&lt;int&gt; &gt; possible(120020), ps2(120020);int n;set&lt;string&gt; asked;string query(const string&amp; q) &#123; string rpl; cout &lt;&lt; "? " &lt;&lt; q &lt;&lt; '\n'; cout.flush(); cin &gt;&gt; rpl; if(rpl == "0") exit(0); return rpl;&#125;string p = "";int id = 0;string gen() &#123; if(id == 0) &#123; for(int i = 0; i &lt; n; ++i) p[i] = 'a' + (i % 26); &#125; if(id == 1) &#123; for(int i = 0; i &lt; n; ++i) p[i] = 'a' + ((i / 26) % 26); &#125; else if(id == 2) &#123; for(int i = 0; i &lt; n; ++i) p[i] = 'a' + ((i / 26 / 26) % 26); &#125; id++; return p;&#125;vector&lt;int&gt; frog[28];void deal(bool first) &#123; string from = gen(), to = query(from); for(int i = 0; i &lt; 27; ++i) frog[i].clear(); for(int i = 0; i &lt; n; ++i) &#123; frog[from[i] - 'a'].push_back(i); &#125; if(first) &#123; for(int i = 0; i &lt; n; ++i) &#123; for(auto g : frog[to[i] - 'a']) possible[g].insert(i); &#125; &#125; else &#123; for(int i = 0; i &lt; 10020; ++i) ps2[i].clear(); for(int i = 0; i &lt; n; ++i) &#123; for(auto g : frog[to[i] - 'a']) &#123; if(possible[g].count(i)) ps2[g].insert(i); &#125; &#125; for(int i = 0; i &lt; 10020; ++i) possible[i] = ps2[i]; &#125;&#125;signed main() &#123; cin &gt;&gt; t; n = t.length(); int pr = n / 26, lf = n - pr * 26; for(char c = 'a'; c &lt;= 'z'; ++c) &#123; for(int i = 0; i &lt; pr; ++i) p += c; if(c - 'a' + 1 &lt;= lf) p += c; &#125; rep(i, 3) deal(i == 1); s = t; for(int i = 0; i &lt; n; ++i) &#123; s[i] = t[*possible[i].begin()]; &#125; cout &lt;&lt; "! " &lt;&lt; s &lt;&lt; endl; return 0;&#125; Problem F. 状压dp代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)using namespace std;typedef long long ll;const int maxn = 100200, maxp = 18, maxs = 1 &lt;&lt; maxp;bitset&lt; (1 &lt;&lt; 18) &gt; legal, dp, cur;int a[maxp][maxp];int cnt[maxp], n, p, pref[maxn][maxp];char s[maxn];vector&lt;int&gt; occ[maxp];int main() &#123; scanf("%d%d%s", &amp;n, &amp;p, s); rep(i, p) rep(j, p) scanf("%d", &amp;a[i][j]); int FULL = (1 &lt;&lt; p) - 1; rep(i, n) &#123; cnt[s[i] - 'a']++; occ[s[i] - 'a'].push_back(i); memcpy(pref[i], pref[i - 1], sizeof(pref[i])); pref[i][s[i] - 'a']++; &#125; legal.set(); rep(u, p) rep(v, p) if(a[u][v] == 0) &#123; cur.set(); for(int i = 0, j = 0; i &lt; int(occ[u].size()) &amp;&amp; j &lt; int(occ[v].size()); ) &#123; int mask = 0; if(occ[u][i] == occ[v][j]) &#123; ++j; continue; &#125; else if(occ[u][i] &gt; occ[v][j]) &#123; rep(c, p) if(pref[occ[u][i]-1][c] - pref[occ[v][j]][c] &gt; 0) mask |= 1 &lt;&lt; c; j++; &#125; else if(occ[u][i] &lt; occ[v][j]) &#123; rep(c, p) if(pref[occ[v][j]-1][c] - pref[occ[u][i]][c] &gt; 0) mask |= 1 &lt;&lt; c; i++; &#125; if(mask &gt;&gt; u &amp; 1) continue; if(mask &gt;&gt; v &amp; 1) continue; cur[mask ^ FULL] = false; cout &lt;&lt; bitset&lt;17&gt;(mask) &lt;&lt; endl; &#125; for(int st = FULL; st; --st) if(!cur[st]) &#123; rep(c, p) if(c != u &amp;&amp; c != v &amp;&amp; (st &gt;&gt; c &amp; 1)) cur[st ^ (1 &lt;&lt; c)] = false; &#125; legal &amp;= cur; &#125; rep(st, FULL + 1) if(legal[st]) printf("%x legal\n", st); dp[FULL] = true; for(int st = FULL; st; --st) if(dp[st]) &#123; rep(c, p) if(st &gt;&gt; c &amp; 1) &#123; if(dp[st ^ (1 &lt;&lt; c)]) continue; dp[st ^ (1 &lt;&lt; c)] = legal[st ^ (1 &lt;&lt; c)]; &#125; &#125; int res = n; rep(st, FULL + 1) if(dp[st]) &#123; printf("dp[%x] = true\n", st); int ans = 0; rep(c, p) if(st &gt;&gt; c &amp; 1) ans += cnt[c]; res = min(res, ans); &#125; cout &lt;&lt; res; return 0;&#125; Problem G. 笛卡尔树, 主席树, 树状数组, 单调栈题意You are given a permutation $p_1,p_2,\cdots,p_n$. You should answer $q$ queries. Each query is a pair $(l_i,r_i)$, and you should calculate $f(l_i,r_i)$. Let’s denote $m_{l, r}$ as the position of the maximum in subsegment $p_l,p_{l+1},\cdots,p_r$. Then $$f(l,r)=(r−l+1)+f(l,m_{l,r}−1)+f(m_{l,r}+1,r) if l\leq r$$ 数据范围：$$n,q\leq 10^6$$ 题解这个题解的详细版明天再补吧QAQ 观察1 $f(l,r)$即把区间$[l,r]$建成笛卡尔树（大根堆性质）之后，每个节点的深度的和。（根节点深度为1） 观察2 上面的性质等价于找到$[l,r]$中的两个位置$c,d$满足$a_c &lt; a_d$且$[c,d]$之中没有比$a_d$更大的数。这样的两个位置会对答案造成$d-c$的贡献。（这个观察来自于笛卡尔树祖先的性质） 观察3 对于每个位置$i$，找到其左边、右边第一个大于$a_i$的位置，记为 $l-1,r+1$，则如果选择$i$位置，区间$[l,i], [i,r]$中的任意一个位置都会产生贡献。左边右边也可以分开解决，因此问题就变成了这样的一个区间问题。 做法1 在线做法，用主席树维护，时间空间都是$O(n\log n)$，可惜这道题空间开不下。 做法2 单调栈+树状数组的离线做法。 代码做法2，1107 ms, 98500KB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)#pragma GCC optimize("-O3", "-ffast-math", "-Ofast", "-funroll-loops", "inline")using namespace std;using ll = long long;const int BUFF_SIZE = 1 &lt;&lt; 20;char BUFF[BUFF_SIZE],*BB,*BE;#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int const N = 1e6 + 20;int n , q , a[N] , l[N] , r[N];ll ans[N];vector &lt;int&gt; L[N] , R[N];int stk[N] , sz;ll sum[N];ll tree[N];inline void add (int p , int val) &#123; for (p++; p &lt; N; p += p &amp; -p) tree[p] += val;&#125;inline ll get (int p) &#123; ll sum = 0; for (; p; p -= p &amp; -p) sum += tree[p]; return sum;&#125;int main() &#123; read(n, q); rep(i, n) read(a[i]); rep(i, q) read(l[i]); rep(i, q) &#123; read(r[i]); l[i]-- , r[i]--; L[l[i]].push_back(i); R[r[i]].push_back(i); &#125; sz = 0; memset(tree , 0 , sizeof tree); for(int i = 0; i &lt; n; i++) &#123; while (sz &amp;&amp; a[stk[sz - 1]] &lt; a[i]) &#123; sz--; add(stk[sz] , i - stk[sz] - 1); &#125; stk[sz] = i; sum[sz] = (sz ? sum[sz - 1] : 0) + i; sz++; for (int id : R[i]) &#123; ans[id] += get(i + 1) - get(l[id]); int vv = lower_bound(stk , stk + sz , l[id]) - stk; ll val = sum[sz - 1] - (vv ? sum[vv - 1] : 0); ans[id] += 1ll * (sz - vv) * i - val; &#125; &#125; sz = 0; memset(tree , 0 , sizeof tree); for(int i = n - 1; i &gt;= 0; i--) &#123; while (sz &amp;&amp; a[-stk[sz - 1]] &lt; a[i]) &#123; sz--; add(-stk[sz] , -stk[sz] - i - 1); &#125; stk[sz] = -i; sum[sz] = (sz ? sum[sz - 1] : 0) + i; sz++; for (int id : L[i]) &#123; ans[id] += get(r[id] + 1) - get(i); int vv = lower_bound(stk , stk + sz , -r[id]) - stk; ll val = sum[sz - 1] - (vv ? sum[vv - 1] : 0); ans[id] += -1ll * (sz - vv) * i + val; &#125; &#125; rep(i, q) &#123; ans[i] += r[i] - l[i] + 1; write(ans[i]); putchar(' '); &#125; printf("\n");&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>Codeforces</tag>
        <tag>矩阵</tag>
        <tag>打表</tag>
        <tag>笛卡尔树</tag>
        <tag>主席树</tag>
        <tag>状压dp</tag>
        <tag>树状数组</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 539 (Div. 1) 解题报告]]></title>
    <url>%2F2019%2F02%2F17%2FCodeforces-Round-539-Div-1-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Overview Status A B C D E F Contest 00:05 00:44 —— —— —— —— Upsolve OK OK AC Attempt + + + Difficulty 1600 1800 2800 2600 2700 3200 这一场比赛打的是Virtual，按照原始排名的话是Rank 269 out of 551。打得好自闭啊！前期A和B通过得还算迅速，B题开始写了个考虑不周全作法，后来过不了第三个样例，打了好多补丁，怀着试一试的态度交了一发，没想到直接就AC了，感觉还行。大致看了一眼剩下的题目，C是个不太可做的复杂数据结构，D是个组合数学，和有标号无根树有关，当时过的人不少，而E是看上去非常简单，但是细节肯定不少的线段树。于是决定硬钢D题，结果之后对着D题自闭了两个小时。。。D题基本思路什么的和题解一模一样，但是有一个小问题我不会解决：有 $N$ 个节点，$M$ 个连通块的有根森林如何计数？百度上搜了搜也搜不到相关结论（但是CF社区说好像用谷歌就能搜到了。。。）最后看到题解是一模一样的推导步骤，到了我不会的子问题的地方直接摆了个结论。 Problem A. 异或相关，签到这道题比较简单，只需要求出有多少个长度为偶数的异或和为0的子串就可以了。复杂度 $O(n\log n)$ Code: 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;#define gc() getchar()template&lt;typename T&gt; void read(T &amp;x)&#123; x = 0; int f = 1; char ch = gc(); while(!isdigit(ch) ) &#123; if(ch == '-') f = -1; ch = gc();&#125; while( isdigit(ch) ) &#123;x = x * 10 + ch - 48; ch = gc();&#125; x *= f;&#125;template&lt;typename T, typename... Args&gt; void read(T&amp; x, Args&amp;... args)&#123; read(x), read(args...); &#125;template&lt;typename T&gt; void write(T x) &#123; if(x &lt; 0) putchar('-'), write(-x); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxn = 500500;int a[maxn], pre[maxn], n;map&lt;int, int&gt; mp[2];int main() &#123; read(n); rep(i, n) read(a[i]), pre[i] = pre[i - 1] ^ a[i], mp[i&amp;1][pre[i]]++; ll ans = 0; mp[0][0]++; for(auto g : mp[0]) ans += 1LL * g.second * (g.second - 1) / 2; for(auto g : mp[1]) ans += 1LL * g.second * (g.second - 1) / 2; cout &lt;&lt; ans; return 0;&#125; Problem B. 字符串，回文串，构造题意给你一个回文串，你需要把它切 $k$ 刀切成 $k+1$ 段，使得这 $ k+1$ 段重新组合得到一个和原串不一样的新回文串。问最小的 $k$ 是多少。 题解考察这个字符串有哪些长度不超过 $n/2$ 的后缀也是前缀。 如果没有的话 如果字符串长度是偶数，那么这个串必定全是同一个字母，答案为不可能。 如果字符串长度为奇数，那么这个串一定是 $AcA$ 的形式，，其中 $A$ 是由同一个字母组成的串，答案显然也是不可能。 否则，交换这一对前缀后缀，得到的字符串一定和原串不同，并且是回文串，因此答案至多是$2$ 。 再看哪些情况答案会是1 。长度为奇数的串一定不能一次完成，而对于一个长度为偶数的串，如果前一半和后一半字符串不同，那么答案可以是1。答案为1的字符串拼接形成的字符串答案也为1，因此可以通过递归来判断答案是否是1. 很容易看出这个做法用Hash或KMP或Z-algorithm都可以做到 $O(n)$ ，当时比较懒，就暴力匹配了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 5050;char s[maxn];int n;bool brute(int p, int end = n) &#123; for(int i = 1, j = p; j &lt;= end &amp;&amp; i &lt;= end; ++i, ++j) if(s[i] != s[j]) return false; return true;&#125;bool solve(int x) &#123; if(x &amp; 1) return false; if(!brute(x / 2 + 1, x)) return true; else return solve(x / 2);&#125;int main() &#123; scanf("%s", s + 1); n = strlen(s + 1); if(solve(n)) &#123; puts("1"); return 0; &#125; if((n &amp; 1) == 0) &#123; if(!brute(n / 2 + 1)) &#123; puts("1"); return 0; &#125; &#125; int lim; if(n &amp; 1) lim = n / 2 + 2; else lim = n / 2 + 1; for(int p = n; p &gt;= lim; --p) &#123; if(!brute(p)) &#123; puts("2"); return 0; &#125; &#125; puts("Impossible"); return 0;&#125; Problem D. 组合数学，拓展Cayley定理，好题题意选定节点 $s ,t$ 给出最大边权 $m$，问有多少棵两两不同的$n$个节点的有标号带权无根树满足 $dist(s,t)=m$。要求每个边的边权是$[1,m]$之间的整数，两棵树相同当且仅当形态相同并且所有边的边权也相同。 题解我们集中注意力在$s,t$之间的路径上，按照$s,t$之间一共有多少个节点来分类进行计数。假如$s,t$之间有$p$个节点，我们按照以下步骤得到此时的方案数： 首先是这$p$个节点的选择。这等价于求不定方程$x_0+x_1+\cdots+x_p=m， (x_i\geq1)$的解数，插板原理得答案是$p \choose {m-1}$。 接着是分配这 $p$个点的编号。显然这就是排列数 $P_{n-2}^{p}$。 对于剩下的边，边权已经不重要了。无论剩下的节点怎么摆放，剩下的边权都会带来这个因数：$m^{n-2-p}$。 之后就到了这道题的重头戏了。我们现在需要考虑的问题就是把剩下的 $n-2-p$ 个节点组成 $p+2$棵有根树（这$p+2$棵树是有序的），然后依次把这些有根树插入到路径上，一共有多少种方案。实际上，把链上的点加进来，这就相当于问$n$个点， $p+2$ 个连通块的有根森林一共有多少种。记这个问题的答案是$f(n,p+2)$（注意有根森林的说法，一种定义是$v$个点，$1,\cdots,k$号顶点分别属于不同连通块的无向无环图）。这个问题是不是和Cayley定理研究的问题有点类似？事实上用一个dp可以 $O(n^2)$ 预处理， $O(1)$ 解决这个问题，但是对这道题显然是不行的。这就要请出我们的大杀器了：拓展Cayley定理： $$f(n,k)=k\cdot n^{n-k-1}$$ 由此，问题就解决了，我们可以在$O((n+m)\log n)$的复杂度完成这道题目。 附：$O(n^2)$的递推公式，这是通过枚举与1号点相邻的点的度数实现的，可以用来验证结论： $$f(n,s)=\sum\limits_{j=0}^{n-s} C_{n-s}^{j} f(n-1,s+j-1)$$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)using namespace std;typedef long long ll;const int maxn = 1002000, MOD = 1000000007;int fac[maxn], ifac[maxn];inline int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;inline int qpow(int x, int y) &#123; if(y &lt; 0) return qpow(qpow(x, -y), MOD - 2); int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;inline int inv(int x) &#123; return qpow(x, MOD - 2); &#125;inline int init() &#123; fac[0] = ifac[0] = 1; for(int i = 1; i &lt;= 1000000; ++i) &#123; fac[i] = muln(fac[i - 1], i); ifac[i] = inv(fac[i]); assert(muln(fac[i], ifac[i]) == 1); &#125;&#125;int C(int n, int m) &#123; if(n &lt; m) return 0; return muln(fac[n], muln(ifac[n-m], ifac[m]));&#125;int P(int n, int m) &#123; assert(n &gt;= m); return muln(fac[n], ifac[n-m]);&#125;int n, m, lim;ll ans = 0;int f(int n, int k) &#123; return muln(k, qpow(n, n - k - 1));&#125;signed main() &#123; init(); scanf("%d%d", &amp;n, &amp;m); for(int p = 0; p &lt;= n-2; ++p) &#123; ans += muln(muln(C(m-1,p), P(n-2,p)), muln(qpow(m,n-2-p),f(n,p+2))); ans %= MOD; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树的计数</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[博客建好了！这个博客将会记录我之后学习过程中遇到的点点滴滴。这一篇博客就用来测试一下博客的$\LaTeX$和代码块的显示是否正常吧。Hello world! 数学公式：$$e^{i\theta} = \cos{\theta} + i\sin{\theta}$$ $$\iint\limits_{D}(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}) \mathrm{d}x \mathrm{d}y = \oint\limits_{L}P\mathrm{d}x+Q\mathrm{d}y$$ $$X(k) = \sum\limits_{j=1}^{n}x(j) \cdot \omega_n^{(j-1)(k-1)}, \omega = e^{-\frac{2\pi i}{n}}$$ 空心字母打法： \mathbb{Q} ，如 $\mathbb{N}$ markdown 打对齐公式，显示标号用 \begin{align} ，不显示用 \begin{aligned} ，千万不要用 \begin{align*} ！因为 hexo 会把星号渲染成斜体符号。 代码块放个树状数组模板吧，我认为最简洁优美的数据结构之一 123456789101112131415#define lowbit(x) ((x) &amp; (-(x)))struct BIT &#123; int c[200200] = &#123;&#125;; inline int sum(int x) &#123; int ret = 0; while(x) ret += c[x], x -= lowbit(x); return ret; &#125; inline void add(int x, int d) &#123; while(x &lt;= n) c[x] += d, x += lowbit(x); &#125; inline int query(int x, int y) &#123; return sum(y) - sum(x - 1); &#125;&#125;;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
