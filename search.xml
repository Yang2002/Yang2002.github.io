<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ICPC2019 回忆录]]></title>
    <url>%2F2019%2F12%2F15%2FICPC2019-%E5%9B%9E%E5%BF%86%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最终，还是没能成为英雄呢。 这就算是，暂时退役了吗？ 回忆起整个大一上的 ICPC 生涯，也是感慨万千呢。 季尾结算Team Dodo Kindergarten From Xi’an Jiao Tong University 2019.10.12-13 CCPC 哈尔滨 Rank 3 2019.11.09-10 ICPC 南昌 Rank 20 2019.11.17-17 ICPC 沈阳 Rank 10 2019.12.14-15 ICPC EC Final Rank 10+ 没想到首战 CCPC 哈尔滨真的就成为了本赛季发挥最好的赛区。最后还是无缘 World Finals 了呢。回忆起整个大一上的 ICPC 生涯，也是感慨万千呢。 吹响号角：暑期集训2019年的暑假是我最忙碌的一个暑假。当时我们队伍已经确认下来了，而作为入坑时间较短、底子相对薄弱的选手，我也深知自己前进的道路任重道远。看到暑假网上举办的有牛客、杭电的多校训练赛，我便决定好好参加。7 月 18 日，我的暑假就结束了。回到学校，和业元一起一周参加四场训练，打比赛。每天我的生活就是临时宿舍-机房-食堂三点一线，想起来也算十分充实。每天我们都会尽力把前一天所有题目都搞懂，并且代码实现，忙得不亦乐乎，而最让我欣喜的是我也时常能 A 掉一些相对较难的题，以及在比赛中“捡漏”。而在坤上完托福课和我们一起打比赛时，在牛客多校取得的一次第五名更是使我们感到兴奋不已。通过自己的实力拿到了奖励的 bilibili 抱枕和购物卡，我们真是感觉开心极了~我们也因此把出线 World Finals 作为区域赛的一大目标。 踏上征程：CCPC 哈尔滨欢乐的暑假，轻松的军训终于结束，新学期开始了。新来的同学们许多都沉醉在这自由开放的新环境中，可是我们队可不能这样，要继续保持例行训练。转眼间就开始选赛区了，就要为了不和期中考试冲突，我们放弃了徐州与银川；由于香港动乱，自然没有考虑香港；由于一些原因以及数学竞赛，我们没有考虑南京。于是我们选择了南昌和沈阳，并且把和 CCPC Final 冲突的沈阳视为希望之花，视为保底赛区。在所有比赛之前，我们参加听说“高手如云”的 CCPC 哈尔滨站，对我们的实力找个定位。 9 月和 10 月，对我们来说一定就如同一部缤纷多彩的交响曲吧。坤拿到了托福超级高分，和我翘课在上海银联参加比赛，快乐旅游。我和业元参加了大学生数学竞赛，也意外地获得了一等奖。平时训练仿佛也是顺风顺水，哈尔滨之旅也颇有梦幻色彩。凌晨 4 点起来，换上羽绒服赶飞机，在东北林业大学博物馆参观，就连正式赛也是顺风顺水，多线程、高效率、完全没卡题的前三个半小时使我们坐稳了季军的位置，而最后一个半小时有两道题可以做，不幸由于我写挂了以及策略问题都没能通过。但这并没有影响这交响曲的主旋律：原来区域赛也没那么难！在首战捧杯的欢呼声，在五彩缤纷的交响曲中，我们踏上了征程。 首度受挫：ICPC 南昌自哈尔滨之后，我们觉得在区域赛拿下奖杯也不是难事，坤表示只想尽快去打一场区域赛。可是，10 月终于还是过去了。南昌 ICPC，我们最终以 116 分钟离场、连卡三题的一片混乱中收场。 B 题简单问题复杂化，简单 dp ，甚至暴力可过，可是我却提出了网络流的奇慢无比的做法，最后荣获 TLE K 题启发式合并，而我们却选择写极为麻烦的点分治做法，最后也没写完 D 题坤写了复杂度稍微有点高的做法，惨遭 TLE 赛后：A 题不是可撤销并查集裸题吗？M 题规律不是很显然，不是自然数幂次和裸题？可做题太多了，可是我们为什么会卡在这几道上，想用如此大常数的算法过题？我也成功打出了后期零贡献，也没有进行平常喜闻乐见的捡漏工作。 魔鬼在人间：ICPC 沈阳经过一周的紧张训练，调整状态，我们又踏上了沈阳的旅途。 尽管发挥还算稳定，可是最后不明不白，就输了。各种偏题模板题，假题错题，算法导论原题遍布试题册。最后一题暴力可过，标程和假算法可过，可是我们吸取南昌教训，不愿写假算法。实际上回文级数的真做法也可以通过，可是当时不会。于是，尽管封榜后过了两题，我们仍然输在这一假题上。赛后复盘，我们认为由于当时我们不会回文级数，只要那道假题出现在试题中，就注定我们要输一道题或者输罚时。我们输在运气和科技上。 最后一搏：EC Final终于，也只得来 EC 血拼出线名额了呢。 有很多强队，但这和我们发挥得怎样又有什么关系呢？ 前期依然发挥稳定，还抢了签到题一血。 后期 D 较难写的 dp，G 麻烦模拟， J 小思维题。做出其中两道即可出线，可 D 题代码有小 bug，G 来不及改，J 又没仔细想，再次 148 分钟离场。 于是，ICPC2019，就这么结束了呢。 一周以来，我都仿佛不在状态。看到 EC 的结果，我也仿佛早已预料到一般，不知道现在自己是一种什么心态。我个人的问题究竟出在哪儿了呢？水平低，过于依赖队友。在逆风条件下没有想题能力，代码水平也不够。检查代码不仔细。我发现逆风时，我经常会处于不自信状态，不由自主地思想弃疗，总觉得题目很麻烦而不去想怎么做，总觉得自己做不出来。 提高水平，自然就可以提高自信。 ICPC2019 赛季，终究还是结束了。由于期末临近，终于还是要和 ICPC 暂别了。明年六月，只能仰望各大强队在 WF 的精彩表现了。 但是，从哪里跌倒，就从哪里爬起来。人在这里，信心还有，希望还在！ICPC2020 ，拭目以待！]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯二项式系数小结]]></title>
    <url>%2F2019%2F09%2F03%2F%E9%AB%98%E6%96%AF%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[高斯二项式系数是二项式系数的 “q-analog” ，对于处理求所有排列逆序数指数和的问题往往可以产生“降维打击”的效果。 前言在牛客多校训练赛 9 中，我们队第一次遇到了高斯二项式系数的题目，当时并没有学过相关的理论，cyy 用一种高级的 dp 过掉了那道题。看到题解上“高斯二项式系数”这个名词之后，我们就学习了一番。之后又碰到了一道 Opencup 题，发现它正是 01 序列所有排列逆序对指数之和这一问题，于是很快在前中期秒杀了。看到题解的朴素 dp 的方法，顿时感觉这一工具的强大，这里做一总结。维基百科链接 定义与性质定义1 定义 q number 如下：$$[k]_q = \sum_{0\leq i &lt; k} q^i = 1+q+q^2+\ldots+q^{k-1} = \begin{cases} \frac{1-q^k}{1-q} &amp; q \neq 1,\\k &amp; q = 1\end{cases}$$ 定义2 定义高斯二项式系数如下：$$\binom{m}{r}_q = \frac{[m]_q [m-1]_q \cdots [m-r+1]_q}{[1]_q [2]_q \cdots [r]_q} \text{ }(r \leq m)$$一种等价定义如下，不过好像没有什么用：$${m \choose r}_q= \begin{cases}\frac{(1-q^m)(1-q^{m-1})\cdots(1-q^{m-r+1})} {(1-q)(1-q^2)\cdots(1-q^r)} &amp; r \le m \\0 &amp; r&gt;m \end{cases}$$类似组合数，可以定义 q factorial 如下：$$[n]_q! = [1]_q [2]_q \cdots [n]_q$$这样，我们就有一个漂亮简洁、易于编程的类似组合数的高斯二项式系数公式了：$$\binom nr _q = \frac {[n]_q!}{[r]_q! [n-r]_q!}$$ 例子$${0 \choose 0}_q = {1 \choose 0}_q = 1$$ $${m \choose 0}_q = {m \choose m}_q =1$$ $${4 \choose 2}_q = \frac{[4]_q[3]_q}{[1]_q[2]_q} = \frac{(1+q+q^2+q^3)(1+q+q^2)}{1\cdot (1+q)}=(1+q^2)(1+q+q^2)=1+q+2q^2+q^3+q^4$$ 性质1 （高斯二项式系数的组合意义）考虑 $n$ 个数组成的数列，其中有 $r$ 个 1 ，$n-r$ 个 0，那么组成的数列恰好有 $d$ 个逆序对数的方案数就是关于 $q$ 的多项式 $\displaystyle \binom nr _q = \frac {[n]_q!}{[r]_q! [n-r]_q!}$ 的 $q^d$ 项系数。 例如：$m=4,r=2$ 时，$\displaystyle \binom 42_q = 1+q+2q^2+q^3+q^4$ ，而 0011 的 6 种排列恰好有 1,1,2,1,1 种方式逆序数分别为 0,1,2,3,4。 性质 1 就是解决很多题目的利器。最典型的题目就是下面的了：给定长度为 $n$ 的 01 序列 $a$ ，记序列 $a$ 的所有排列的集合为 $F(a)$，序列 $b$ 的逆序对数为 $r(b)$ ，求 $\displaystyle \sum_{b \in F(a)} q^{r(b)}$ ，答案直接就是高斯二项式系数。 可是如果序列 $a$ 不止有 01 这两种元素，怎么办呢？我们有下面的推广： 性质1‘ （多重高斯二项式系数）设 $a$ 是由 $n$ 个数组成的数列，假设 $a$ 中有 $m$ 种元素，其中元素 $x_i$ 有 $c_i$ 个 $(1\leq i \leq m)$。类比组合数与多重组合数的关系，答案就是下面的“多重”高斯二项式系数：$$\binom{n}{c_1,c_2,\cdots,c_m} = \frac{[n]_q!}{[c_1]_q! [c_2]_q! \cdots [c_m]_q!}$$值得一提的是，在这个公式里，我们只关心 $c_i$ 的大小，而不关心 $x_i$ 的取值、大小关系等等。 例题Inversions of all permutations题意给定任意可重序列 $a$ ，记序列 $a$ 的所有排列的集合为 $F(a)$，序列 $b$ 的逆序对数为 $r(b)$ ，求 $\displaystyle \sum_{b \in F(a)} q^{r(b)}$ 。 题目来源：2019牛客暑期多校训练营（第九场） 题解直接使用性质 1b 即可，复杂度 $O(n\log n)$。 性质1b （多重高斯二项式系数）设 $a$ 是由 $n$ 个数组成的数列，假设 $a$ 中有 $m$ 种元素，其中元素 $x_i$ 有 $c_i$ 个 $(1\leq i \leq m)$。类比组合数与多重组合数的关系，答案就是下面的“多重”高斯二项式系数： $$\binom{n}{c_1,c_2,\cdots,c_m} = \frac{[n]_q!}{[c_1]_q! [c_2]_q! \cdots [c_m]_q!}$$ Do I Wanna Know题意有 $n$ 只编号分别为 $1,2,\ldots,n$ 的猴子两两打架，任意编号小的猴子打赢编号大的猴子的概率均为 $p$ ，输掉概率均为 $q=1-p$ 。问对于所有 $k=1,2,\ldots,n-1$ ，下面的局面出现的概率是多少：存在方案可以将猴子分为包含 $k$ 只猴子的强者组和包含 $n-k$ 只的弱者组，使得强者组的每只猴子都打赢了弱者组的每只猴子。 题解显然如果存在，那么强者组的选取是唯一的。将强猴子记为1，弱猴子记为 0 ，对每个 k 相当于求 k 个 1 与 $n-k$ 个 0 的所有排列出现概率之和。考虑如果给定一种排列 $P$，记其逆序数为 $c$ ，那么它出现的概率就是 $p^c q^{k(n-k) - c}$ 。将这个式子求和，整理得到：$$q^{k(n-k)}\sum_{b \in F(a)} (\frac pq )^{r(b)} = q^{k(n-k)} \binom{n}{k}_\frac pq$$点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * Author : YangDavid * Created Time : 2019年09月03日 星期二 14时03分22秒 */#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1; i &lt;= n; ++i)#define eprintf(...) fprintf(stderr, __VA_ARGS__)using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int maxn = 666666, MOD = 998244353;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, ll y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int inv(int x) &#123; return qpow(x, MOD - 2); &#125;int add(int x, int y) &#123; return x+y&gt;=MOD ? x+y-MOD : x+y; &#125;int sub(int x, int y) &#123; return x-y&lt;0 ? x-y+MOD : x-y; &#125;int qn[maxn], iqn[maxn];int main() &#123; int n, a, b, p, q, r, g = 1, ans = 0, binom = 1; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); p = muln(a, inv(b)), q = sub(1, p), r = muln(p, inv(q)); qn[0] = 0; for(int i = 1; i &lt;= n; ++i) &#123; qn[i] = add(muln(qn[i - 1], r), r); iqn[i] = inv(qn[i]); &#125; for(int k = 1; k &lt; n; ++k) &#123; binom = muln(binom, muln(qn[n - k + 1], iqn[k])); ans = add(ans, muln(muln(qpow(q, 1LL*k*(n-k)), binom), g)); g = add(muln(g, g), 2); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高斯二项式系数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数拆分知识集锦]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[如果看到了下面的数列，就要保持警惕了！！！ 1, 1, 2, 3, 5, 7, 11, 15, 22, 30 有关整数拆分如果看到了下面的数列，就要保持警惕了！！！ 11, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135, 176, 231, 297, 385, 490, 627, 792, 1002, 1255, 1575, 1958, 2436, 3010, 3718, 4565, 5604, 6842, 8349, 10143, 12310, 14883, 17977, 21637, 26015, 31185, 37338, 44583, 53174, 63261, 75175, 89134, 105558, 124754, 147273, 173525 首先，是整数拆分的定义。 定义1 给定 $n$，求不同数组 $\displaystyle (a_{1},a_{2},…,a_{k})$ 的数目，符合下面的条件： ${\displaystyle a_{1}+a_{2}+…+a_{k}=n}$ （${\displaystyle k}$ 的大小不定） ${\displaystyle a_{1}\geq a_{2}\geq …\geq a_{k}&gt;0}$ 其他附加条件（例如限定“k是偶数”，或“${\displaystyle a_{i}}$ 不是 1 就是 2 ”等） 分割函数 $p(n)$ 是求符合以上第一、二个条件的数组数目。为了方便起见，我们首先讨论的是忽略条件 3 的情况。 引理1：$$\varphi(x) = \prod_{i=1}^\infty (1-x^i)$$引理2：设 $f(x) = \text{(将}x\text{分成偶数个不同正整数的方法数)} - \text{(将}x\text{分成奇数个不同正整数的方法数)}$ ，则 $f$ 的生成函数 $F(x)$ 就是：$$F(x) = \prod_{i=1}^\infty (1-x^i)$$定理1：$$\varphi(x) = \prod _{i=1}^\infty (1-x^i) = \sum_{k=-\infty}^\infty (-1)^k x^{\frac{k(3k-1)}{2}}$$证明：根据引理2 的组合意义进行证明。考虑划分的 Ferrers 图，我们构造一种配对方案，将大部分 Ferrers 图两两配对（数学上又称这种方法为构造一个 involution，即满足 $f(f(x)) = x$ 的函数）。详见 wiki (https://en.wikipedia.org/wiki/Pentagonal_number_theorem)。 一些性质： 分拆成若干奇数的方案数 = 分拆成若干互不相同的数的方案数 Ferrers 图的转置通常可以构造出新的分拆，成为分拆的共轭。共轭为自身的分拆如何计数呢？沿着主对角线看去，一层层拆开，那么共轭为自身的分拆个数就是拆分成互不相同的奇数的方案数，两者一一对应。 另一个有趣发现：因数和函数 $\sigma(n)$ 也可以和拆分数一样递推，只是规定考虑 $\sigma(n)$ 时，如果后面的项里有 $\sigma(0)$ ，就视为 $n$ ，而不是 1 。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019年ACM-ICPC陕西省赛游记]]></title>
    <url>%2F2019%2F06%2F02%2F2019%E5%B9%B4ACM-ICPC%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[游记夺冠了！作为和 nocriz，hdmmblz 一起组队打的第一场比赛，这也算是一个开门红吧，这次的解题策略与团队合作等诸多方面都做得还不错，出的锅也不算特别多。不过这也仅仅是一个省赛，仅仅是一个起点，以后的路还长，以后的目标需要远大！我们有了方向，有了动力，更有了顶天立地的决心。 不过这次去除两个高中打星队我们才夺的冠，那两个队一个 11 题，一个 10 题，还是被高中省队爷吊打了啊，感觉还是要提高啊。（被“丁教练”教育了qaq） 准备上午 06:40 就早早地起床，集合，前往 XDU。路上水掉了 wzk 讲的一个张好风出的构造题，感觉海星。 到了 XDU ，拿好衣服之后打了一个极为自闭的热身赛。首先是发现电脑的 Ubuntu 双系统里面居然没有 vim，没有各种常见编辑器，打算换用 gedit 之后，发现居然没有网络，无法查看题面。一阵忙乱之中我们又改用 windows + Dev-cpp，结果发现电脑又没有 python，g++也没有加入 PATH 环境变量里。这时开始看热身赛的题目，wzk 几分钟秒掉了 A ，我提出了 B 题最短路+欧拉回路的做法，然而没有人熟悉欧拉回路怎么写！！！稍微讨论回忆了一下，构思好代码之后 wzk 开始写。cyy 和我思博了，一直对着 C 题自闭。最后 B 没写出来， C 也没做出来。结果 wzk 赛后直接一眼秒掉了 C。总的来看，热身赛什么环境也没来得及测，题目也只 A 了一道，感觉主要就是用来 rp++ 了。 下图是我们比赛的机位： 正赛参加完豪华（简单）的露天开幕式之后马上就要正赛了，感觉心里还蛮没底的。稍微调整了下状态，比赛开始了（喂，比赛没开始为什么大家都开始启封试题册了啊！）。wzk 悄悄以惊人的手速 10 分钟 1A 了三道签到题EFL 并拿到了 E 题的一血，简直太强了，这三道题我场上甚至根本没看。 之后开始多线程， wzk 看 C 写 C，结果 wa 了；这大概经过了 20 分钟，与此同时我和 cyy 互相交换了 H，I，J 三道题的题意。I 题稍微讨论了一下就会了，wzk 打印了 C 题代码，cyy 给 wzk 讲了 I ，wzk 开始写。我发现 H 是擅长的构造，我又发现这题和华东师大校赛的 C 题极为相似，于是决定仔细想 H，过了一会儿就会做了，给 cyy 讲了做法，cyy 觉得很正确，于是我仔细构思了下代码，觉得很好写。wzk 写好 I了，可是 wa 了，找出了好几个细节错误。打印代码后，我上机写 H。cyy 和 wzk 一起小黄鸭，发现了所有错误，改了之后提交，总算通过了 I 题，并拿到了一血。过了一会儿，我写完了 H ，测了测样例，手测几组数据，觉得稳得很，于是提交，1A了 H 题，并且还拿到了这道题一血。这时我们的士气很高涨，排在 rank 1，I，H 题仅仅有我们队通过，第二名仅仅才 4 道题，拿了两个一血，时间也才仅仅过去 74 分钟。 继续多线程，wzk 发现交大“免费赠送AC帽”队拿到了 B 题的一血，于是跟了下榜，发现是思博题，于是开始写。cyy 提出几种 J 做法，感觉找到了靠谱做法了，于是又屯下一题。wzk A掉了 B 题，cyy 开始给 wzk 讲 J 题，我把没看的题目都看了一遍，主要在想 D 题。wzk 开写 B 了，cyy 提出 K 题解法，但是我有点怀疑正确性。wzk J 题神秘地 TLE 了，在我强烈要求下不辞辛劳把 cin 改为了 fread+getchar ，又手动开了 O3，Ofast，然后就神奇通过了 J 题。wzk 确认了 cyy K 题解法的正确性，cyy 上机写 K 题，用了 20 多分钟也写好过掉了 K 题 。 与此同时，我一直在试图对 D 题进入大型分类讨论。我分了一维三种情况以及二位的六种情况，都将思路整理到之上了。wzk 建议看一看 C ，这时我们才意识到 WA 了很久扔在那里的题目。wzk 打算写 A 题试一试，我和 cyy 想了 C 的一些假做法，最后得到的结论 wzk 说就是当时 wa 的代码的思路。我发现有个小情况忘记考虑了，加上去之后大家不太相信正确性，可是我觉得很稳，结果交上去就 AC 了C题。 这时已经封榜了，我们手上有DAG三道题，有 40 分钟的时间。D题所有情况已经讨论完成了，A 题wzk写好了，但是交上去铁定会 TLE。wzk 试图优化 A ，可是没什么头绪。 D 题代码量巨大，细节繁琐，我硬着头皮上去写，cyy 在旁别即时检查。结果最后 2 分钟终于写完了代码，可是没时间调试了，直接交上去 WA 了，本地测了下也过不了样例，没有办法了，被高中生吊打了。 比较幸运的是，正式选手中我们还是拿到了 rank 1，拿到了冠军奖杯。（免费赠送AC帽队第四，他们差点就也 9 题了，真为他们可惜 qwq） 总的来看： Solved during contest: 9/12 Upsolved: 9/12 Orally upsolved: 9/12 Rank: 1/105 (Official), 3/111 (Full rank) 出现的问题集锦： （热身赛）没有人会熟练实现欧拉回路 大数据读入时仍使用 cin C 题 wzk 开始想的是正解，结果因为小情况 wa 而误以为算法假了 最后一个小时还是划了，D 讨论得还是不全面，主要是没有信心，写代码的时候中途我掉线了。 A 题写好后以为会 TLE 就没有提交，但实际上复杂度是正确的。 做得比较好的地方集锦： 基本做到了多线程 让 wzk 去签到 快速做出了构造题 cyy 力排众议，写了 K 题看似无脑的做法通过了 每次提交前的检查还算仔细 附录Practice Link Score Board：]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合幂级数、FMT、FWT学习笔记]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0-FMT-FWT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[受这几天看到的不少高维前缀和题目的影响，我决定系统地学习一下集合幂级数的一套理论了。内容主要来自2015年吕凯风（VFleaKing）国家集训队论文《集合幂级数的性质与应用及其快速算法》（pdf版本会放在附录里），包括集合并卷积、集合对称差卷积、子集卷积、快速莫比乌斯变换、快速莫比乌斯反演、快速沃尔什变换及逆变换等，以及附带进行的一些练习。 [TODO] 把练习第一题搞清楚[TODO] 把第三道论文题学会 引言及定义类似数列的生成函数，对于集合，我们引入集合幂级数来解决一些有关集合的动态规划问题。 定义：设 $F$ 是一个域，则称函数 $f:2^U\to F$ 是 F 上的一个形式幂级数，记 $f_S=f(S)$ 为集合幂级数第 $S$ 项的系数。 我们记为：$$f=\sum_{S\subseteq 2^U} f_S x^S$$显然可以定义集合幂级数的加法：$(f+g)(S) = f(S)+g(S)$ ，减法也类似。这两种运算都是 $O(2^n)$ 的。 如何定义乘法？为了保证乘法对加法的分配律，若 $h=f\cdot g$ ，我们应该有：$$\sum_{S\in 2^U} h_S x^S = \big(\sum_{L\in2^U}f_Lx^L\big) \cdot (\sum_{R\in 2^U} g_R x^R) = \sum_{L\in 2^U} \sum_{R\in 2^U} (f_L x^L) \cdot (g_R x^R)$$因此我们只需要规定 $(f_L x^L) \cdot (g_R x^R)$ 的运算结果，我们希望它是以某种集合运算乘起来的。我们设一个 $2^U$ 中满足交换律、结合律、空集是单位元的二元运算 $\ast$ ，那么我们就可以定义 $(f_L x^L) \cdot (g_R x^R) = (f_L g_R) x^{L\ast R}$ 。至此集合幂级数形成了一个交换环，并且包含了整个 $F$ 作为子环。 常见定义 $\ast$ 为集合并运算、集合对称差运算以及子集卷积，我们一一解决。 集合并卷积（FWT_or）原理即给出两个集合幂级数 $f,g$ ，求 $h = f\ast g$ 满足：$$h_S = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cup R = S] f_L g_R \tag{1}$$怎么做呢？暴力做是 $O(4^n)$ 的，一种做法是分治乘法，可是总感觉在理论价值上面会逊色一些。有没有类似 FFT 的一种变换，使得变换后将卷积直接变成点乘呢？莫比乌斯变换做到了这一点。 我们定义集合幂级数 $f$ 的莫比乌斯变换 $\hat{f} $为：$$\hat{f_S} = \sum_{T\subseteq S} f_T$$反过来，如何求莫比乌斯逆变换呢（常常称为莫比乌斯反演）？有关反演看这里：《炫酷反演魔术》。很容易由容斥原理，我们又有：（这一步建议在纸上推导一下，要不然可能会觉得不直观）$$f_S = \sum_{T\subseteq S} (-1)^{|S|-|T|} \hat{f_T}$$现在，我们可以解决 (1) 中的问题了。对 (1) 式的左右两边同时做莫比乌斯变换$$\begin{aligned}\hat{h_S} &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cup R \subseteq S] f_L g_R\\&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\subseteq S][ R \subseteq S] f_L g_R\\&amp; = (\sum_{L\subseteq S}f_L) (\sum_{R\subseteq S}g_R)\\&amp; = \hat{f_S}\hat{g_S}\end{aligned}$$因此，我们想要的性质是成立的。只需要把 $f,g$ 做莫比乌斯变换，点乘起来，然后再做莫比乌斯反演即可得到集合并卷积。 如何进行莫比乌斯变换呢？可以使用递推，设 $\hat f^{(i)}_S$ 表示只考虑 $S\oplus T\subseteq \{1,\cdots,i\}$ 的子集 $T$ 时的莫比乌斯变换第 $S$ 项，令 $\hat f_S^{(0)} = f_S$ ，那么对于每个不包含 $i$ 的 $S$ 有：$$\hat{f_S^{(i)}} = \hat{f_S}^{(i-1)}\\\hat{f}_{S\cup\{i\}} ^{(i)} = \hat f_{S\cup\{i\}}^{(i-1)} + \hat f _S ^{(i-1)}$$由此递推计算即可。复杂度 $O(n2^n)$ 实现代码非常简短，dmt 变量为 1 时表示正变换，为 -1 时表示逆变换。 123456vector&lt;int&gt; fmt_or(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) A[S|(1&lt;&lt;i)] = mo(A[S|(1&lt;&lt;i)] + dmt*A[S]); return A;&#125; 集合交卷积（FWT_and）由于 $S\cap T = C_U(\bar S \cup \bar T)$，因此将S、T翻转之后，可以直接用FWT_or导出。可是实际上还有更简洁的实现，如下面代码所示。 复杂度 $O(n2^n)$ 123456vector&lt;int&gt; fmt_and(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) A[S] = mo(A[S] + dmt*A[S|(1&lt;&lt;i)]); return A;&#125; 集合对称差卷积（FWT_xor）原理这一回把 $\ast$ 定义为集合对称差。即给出两个集合幂级数 $f,g$ 求 $h = f\ast g$ ：$$h_S = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\oplus R=S] f_L g_R \tag 2$$分治乘法在这里也是可行的，但是对应的变换方法是什么呢？这次我们使用快速沃尔什变换及其逆变换（本质上是高维 FFT）。 快速沃尔什变换：$$\hat{f_S} = \sum_{T\subseteq 2^U} f_T (-1) ^{|S\cap T|}$$其逆变换为：（我没有找到靠谱证明）$$f_S = \frac {1}{2^n}\sum_{T\subseteq 2^U} \hat{f_T}(-1)^{|S\cap T|}$$沃尔什变换是具体如何解决（2）式的问题的呢？我们基于下面的事实：$$\frac {1}{2^n}\sum_{T\subseteq 2^U} (-1)^{|S\cap T|} = [S=\oslash]$$化简过程如下：$$\begin{aligned}h_S &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\oplus R\oplus S = \oslash] f_L g_R\\&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|S\cap (L\oplus R \oplus S)|} f_l g_R\\&amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|T\cap L|} (-1)^{|T\cap R|}(-1)^{|T\cap S|} f_l g_R\\&amp; = \frac{1}{2^n} \sum_{T\subseteq 2^n} (-1)^{|T\cap S|} \Big(\sum_{L\subseteq 2^U} (-1)^{|T\cap L|} f_L\Big)\Big(\sum_{R\subseteq 2^U} (-1)^{|T\cap R|} g_R\Big)\\&amp; = \frac{1}{2^n} \sum_{L\subseteq 2^U} (-1)^{|L\cap S|} \hat{f_S} \hat{g_S}\end{aligned}$$即： $\hat{h_S} = \hat{f_S} \cdot \hat{g_S}$ 注：在理论上，这种变换还有一个小问题，就是特征为2的 $F$ 上上述算法会失效，因为上述算法涉及乘以 $\frac {1}{2^n}$ 。不过一般情况下不会成问题。 接下来考虑如何计算快速沃尔什变换。依然可以使用递推，设 $\hat f^{(i)}_S$ 表示只考虑 $S\oplus T\subseteq \{1,\cdots,i\}$ 的子集 $T$ 时的沃尔什变换第 $S$ 项，令 $\hat f_S^{(0)} = f_S$ ，那么对于每个不包含 $i$ 的 $S$ 有：$$\hat{f_S^{(i)}} = \hat{f_S}^{(i-1)}+\hat{f}_{S\cup\{i\}}^{(i-1)}\\\hat{f}_{S\cup\{i\}} ^{(i)} = \hat f _S ^{(i-1)} - \hat f_{S\cup\{i\}}^{(i-1)}$$由此递推计算即可。复杂度 $O(n2^n)$ 实现123456789101112131415vector&lt;int&gt; fwt_xor(vector&lt;int&gt; A, int dmt = 1) &#123; int l, r; for(int i = 0; i &lt; n; ++i) for(int S = 0; S &lt; m; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = A[S], r = A[S|(1&lt;&lt;i)]; A[S] = mo(l + r); A[S|(1&lt;&lt;i)] = mo(l - r); &#125; if(dmt==-1) &#123; int inv2 = qpow(qpow(2, MOD-2), n); for(int S = 0; S &lt; m; ++S) A[S] = muln(A[S], inv2); &#125; return A;&#125; 子集卷积这一部分感觉论文讲得有点自闭，推荐 Dance Of Faith 的这篇博客 。 原理考虑这种形式的卷积如何处理：$$h_S = \sum_{T\subseteq S} f_T g_{S-T} \tag 3$$实际上，这种卷积等价于定义 $\ast$ 为不相交集合的并，即$$L \ast R =\begin{cases} \varnothing, &amp; L \cap R \neq \varnothing \\ L \cup R, &amp; \text{otherwise}\end{cases}$$我们稍微改写一下 （3） 式：$$\begin{aligned}h_S &amp; = \sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [L\cap R = \varnothing] [L\cup R = S] f_L g_R \\&amp; =\sum_{L\subseteq 2^U} \sum_{R\subseteq 2^U} [|L| + |R| = |S|][L\cup R = S] f_L g_R\end{aligned}$$我们只需要处理掉 $|L|+|R| = |S|$ 这一项。实际上我们直接加一维表示集合的大小，暴力处理即可。 具体来讲，初始时，我们先只把 $f_{pc(S),S}$ （pc(S) 表示 popcount ，即 S 二进制表示中有多少位是 1 ）的值赋成原来的 $f_{S}$（$g$ 也使用同样的操作），然后对每一个 $f_i$ 做一遍FMT，点值相乘时这么卷积：$h_{i, S} = \sum\limits_{j = 0}^{i} f_{j,S} * g_{i - j, S}$ 。代码很简洁，如下所示： 1234567891011121314151617vector&lt;int&gt; subset_conv(vector&lt;int&gt; A, vector&lt;int&gt; B) &#123; vector&lt;int&gt; H(Len); vector&lt; vector&lt;int&gt; &gt; siga(Base+1, vector&lt;int&gt;(Len,0)), sigb = siga, sigh = siga; for(int S = 0; S &lt; Len; ++S) siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S]; for(int i = 0; i &lt;= Base; ++i) &#123; fmt_or(siga[i], 1); fmt_or(sigb[i], 1); for(int S = 0; S &lt; Len; ++S) for(int j = 0; j &lt;= i; ++j) sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i-j][S])); fmt_or(sigh[i], -1); &#125; for(int S = 0; S &lt; Len; ++S) H[S] = sigh[pc[S]][S]; return H;&#125; 小结FWT_OR 12if FMT : f[S|(1&lt;&lt;i)] += f[S]if IFMT: f[S|(1&lt;&lt;i)] -= f[S] FWT_AND 12if FMT : f[S] += f[S|(1&lt;&lt;i)]if IFMT: f[S] -= f[S|(1&lt;&lt;i)] FWT_XOR： 12345l = f[S], r = f[S|(1&lt;&lt;i)]f[S] = l + rf[S|(1&lt;&lt;i)] = l - rif IFMT: f[S] /= qpow(2, n) 子集卷积： 123456789for i in range(0, n + 1): F[i] = FWT_OR(f[i]) G[i] = FWT_OR(g[i]) for S in range(0, Len): for j in range(0, i + 1): H[i][S] += F[j][S] * G[i-j][S] H[i] = IFWT_OR(H[i])for S in range(0, Len): h[S] = H[bc[S]][S] 完整板子代码如下，由于没有采用类似 FFT 蝴蝶操作的优化，效率不是很高，在LOJ的子集卷积模板题上跑了 4500/5000 ms。Luogu 4717 点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 0, i##_end_ = (n); i &lt; i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;// Template starts hereconst int MOD = 1000000009;inline int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;inline int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;int Len, Base; // Ensure these values are calculated!!!!vector&lt;int&gt; fmt_or(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) A[S|(1&lt;&lt;i)] = mo(A[S|(1&lt;&lt;i)] + dmt*A[S]); return A;&#125;vector&lt;int&gt; fmt_and(vector&lt;int&gt; A, int dmt = 1) &#123; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) A[S] = mo(A[S] + dmt*A[S|(1&lt;&lt;i)]); return A;&#125;vector&lt;int&gt; fwt_xor(vector&lt;int&gt; A, int dwt = 1) &#123; int l, r; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = A[S], r = A[S|(1&lt;&lt;i)]; A[S] = mo(l + r); A[S|(1&lt;&lt;i)] = mo(l - r); &#125; if(dwt==-1) &#123; int inv2 = qpow(Len, MOD-2); for(int S = 0; S &lt; Len; ++S) A[S] = muln(A[S], inv2); &#125; return A;&#125;vector&lt;int&gt; conv(const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B, vector&lt;int&gt;(*fn)(vector&lt;int&gt;,int)) &#123; vector&lt;int&gt; aa = fn(A, 1), bb = fn(B, 1); for(int i = 0; i &lt; Len; ++i) aa[i] = muln(aa[i], bb[i]); aa = fn(aa, -1); return aa;&#125;vector&lt;int&gt; pc;void get_popcount(int sz) &#123; pc.resize(sz, 0); for(int i = 1; i &lt; sz; ++i) pc[i] = pc[i &gt;&gt; 1] + (i &amp; 1);&#125;vector&lt;int&gt; subset_conv(vector&lt;int&gt; A, vector&lt;int&gt; B) &#123; get_popcount(Len); vector&lt;int&gt; H(Len); vector&lt; vector&lt;int&gt; &gt; siga(Base+1, vector&lt;int&gt;(Len,0)), sigb = siga, sigh = siga; for(int S = 0; S &lt; Len; ++S) siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S]; for(int i = 0; i &lt;= Base; ++i) &#123; siga[i] = fmt_or(siga[i], 1); sigb[i] = fmt_or(sigb[i], 1); for(int S = 0; S &lt; Len; ++S) for(int j = 0; j &lt;= i; ++j) sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i-j][S])); sigh[i] = fmt_or(sigh[i], -1); &#125; for(int S = 0; S &lt; Len; ++S) H[S] = sigh[pc[S]][S]; return H;&#125;// Template ends herevoid show(vector&lt;int&gt; v) &#123; int first = true; for(auto g : v) &#123; if(first) first = false; else putchar(' '); printf("%d", g); &#125; putchar('\n');&#125;int n, m;vector&lt;int&gt; a, b;int main() &#123; scanf("%d", &amp;n); m = Len = 1 &lt;&lt; n, Base = n; a.resize(m), b.resize(m); rep(i, m) scanf("%d", &amp;a[i]); rep(i, m) scanf("%d", &amp;b[i]); show(conv(a, b, fmt_and)); show(conv(a, b, fmt_or)); show(conv(a, b, fwt_xor)); show(subset_conv(a, b)); return 0;&#125; 练习[HAOI2015] 按位或Description刚开始你有一个数字0，每一秒钟你会随机选择一个 $[0,2^n-1]$ 的数字，与你手上的数字进行按位或操作。选择数字 $i$ 的概率是 $p_i$。保证 $0\leq p_i \leq1$，$\sum p_i = 1$。问期望多少秒后，你手上的数字变成 $2^n-1$。无穷输出 INF 数据范围：$n\leq 20$ Source: BZOJ4036 vfk论文第一道例题。 Solution留坑。 Day8 I. 岸边露伴的人生经验Description岸边露伴是一个天才漫画家，他经常用自己的替身天堂之门来查看别人的人生经历，为自己的漫画积累素材。最近他学会了将一个人的人生经历编码成一个 $10$ 维的向量，每一维取值为 $\{0,1,2\}$ 中的一个元素。定义向量$\overrightarrow{V}=(x_1,x_2,\cdots,x_{10})$ 的模长 $|\overrightarrow{V}|$ 为 $\sqrt{x_1^2+x_2^2+\cdots+x_{10}^2}$。令第 $i$ 个人的人生经历对应的向量为$\overrightarrow{V_i}$，则第ii个人和第 $j$ 个人的人生轨迹的差别可以用 $|\overrightarrow{V_i}-\overrightarrow{V_j}|$ 衡量。岸边露伴收集了 $n$ 个人的向量，他想要知道这些人里，人生轨迹差别相同的二元组有多少对，即有多少个四元组 $(i,j,k,l)(1 \le i,j,k,l \le n)$ 满足 $|\overrightarrow{V_i}-\overrightarrow{V_j}|=|\overrightarrow{V_k}-\overrightarrow{V_l}|$ 数据范围：$n\leq 10^5$ Source: CCPC-Wannafly Winter Camp Day8 (Div1, onsite) Day 8 Problem I Solution考虑每个向量取值只有 $\{0,1\}$ 的情况，每个人的向量为一个二进制数，装进桶里，直接进行自己卷积自己的异或 FWT ，这时集合幂级数的每一项都代表这个集合被异或出来的 可能方式。再扫一遍每一个状态，按照 bitcount 统计距离，加入另一个数组，平方一下即可。 考虑这道题，多了一个 $2$ ，我们只需要把每一个向量中一个数位拆成两个字符即可，将 1 变为 01 ，2 变为 10 ， 0 变为 00 ，然后把上一种做法求 bitcount 统计距离的方式稍微改一下就可以了。 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* Generated by powerful Codeforces Tool * Author: YangDavid * Time: 2019-04-28 19:15:38*/#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 202000, maxs = 1 &lt;&lt; 20, BB = 20, MOD = 998244353;int n, dif[10200];vector&lt;int&gt; a(maxs, 0), val(maxs, 0);int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x;&#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;void fwt(int dwt) &#123; int l, r; for(int i = 0; i &lt; BB; ++i) &#123; int mask = (maxs-1) ^ (1&lt;&lt;i); for(int S = mask; S &gt;= 0; S = (S-1)&amp;mask) &#123; l = a[S], r = a[S | (1&lt;&lt;i)]; a[S] = mo(l + r); a[S|(1&lt;&lt;i)] = mo(l - r); if(S == 0) break; &#125; &#125; if(dwt == -1) &#123; int fac = qpow(qpow(2, MOD - 2), BB); for(int i = 0; i &lt; maxs; ++i) a[i] = muln(a[i], fac); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; ++i) &#123; int msk = 0, x; rep(j, 10) &#123; scanf("%d", &amp;x); msk &lt;&lt;= 2; if(x == 1) msk += 1; else if(x == 2) msk += 2; &#125; a[msk]++; &#125; fwt(1); for(int i = 0; i &lt; maxs; ++i) a[i] = muln(a[i], a[i]); fwt(-1); val[0] = 0, val[1] = 1, val[2] = 4, val[3] = 1; for(int S = 4; S &lt; maxs; S += 4) &#123; int t = val[S &gt;&gt; 2]; val[S] = t; val[S+1] = t + 1; val[S+2] = t + 4; val[S+3] = t + 1; &#125; for(int S = 0; S &lt; maxs; ++S) &#123; dif[val[S]] += a[S]; &#125; ll res = 0; for(int i = 0; i &lt;= 100; ++i) &#123; res = mo(res + 1LL * dif[i] * dif[i] % MOD); &#125; printf("%lld\n", res); return 0;&#125; CF1119 H. 难题，精妙的 FWTDescription给定 $a,b,c$ ，以及 $n$ 个 $k$ 位 bitmask $A_i,B_i,C_i$ ，求下面 $n$ 个集合幂级数的异或 FWT，即：$$\prod_{1\leq i\leq n} (ax^{A_i}+bx^{B_i}+cx^{C_i})$$数据范围：$n\leq 10^5,k\leq 17,0\leq A_i,B_i,C_i &lt; 2^k,$ Source: Codeforces Global Round 2 Problem H Solution按照正常的 FWT 思路，就是把这 $n$ 个集合幂级数分别求出 FWT，然后再点乘起来，然后再做 IFWT。复杂度是 $O(nk2^k)$ 的，无法通过此题。 但是这道题需要注意的一点是每一个集合幂级数都只有三项，并且 $a,b,c$ 是固定的。回顾 FWT 的公式：$$\hat{f}(S) = \sum_{T\subseteq 2^U} f(T) (-1)^{|S\cap T|}$$因此每个集合幂级数 FWT 之后也仅仅会有 $\pm a \pm b \pm c$ 这么 8 种项。为了使问题更加简单，我们进行这样的变换： $B_i:=B_i \oplus A_i,C_i := C_i \oplus A_i, A_i := 0$ 。变换之后我们得出的结果的第 $S$ 项就等价于答案的第 $S\oplus xorsum$ 项，其中 $xorsum = \oplus_{i=1}^n A_i$。可以发现，这样做之后只剩下 $a\pm b \pm c$ 这四项了。 我们的一个重要观察是，将 FWT 之后的这 $n$ 个集合幂级数乘起来的结果中，对于一个固定的位置 $S$ ，这一项的系数一定是 $(a+b+c)^x (a+b-c)^y (a-b+c)^z (a-b-c)^w$ 的形式。如果我们能够把 $x,y,z,w$ 解出来，整个问题就解决了。首先，我们有一个最朴素的关系式：$$x+y+z+w = n$$之后有两种说法，一种是官方题解所说的考虑所有 $n$ 个 FWT 之后的幂级数的第 $S$ 项之和，然后再多考虑一个条件即可得到四个方程；另一种则非常简洁、对称、优美，可是我对这种方法还没有简洁优美的证明。这种方法是这样的： 将 $A_i\oplus B_i$ 的值统计入一个数组 $f$，对 $f$ FWT之后，对于其第 $S$ 项有：$x+y-z-w=f[S]$。 将 $A_i\oplus C_i$ 的值统计入一个数组 $g$，对 $g$ FWT之后，对于其第 $S$ 项有：$x-y+z-w=g[S]$。 将 $B_i\oplus C_i$ 的值统计入一个数组 $h$，对 $h$ FWT之后，对于其第 $S$ 项有：$x-y-z+w=h[S]$。 然后消元法即可。 Code点击显示/隐藏代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* Generated by powerful Codeforces Tool * Author: YangDavid * Time: 2019-05-02 16:57:53*/#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 102000, MS = (1 &lt;&lt; 17) + 2, MOD = 998244353;int A[maxn], B[maxn], C[maxn], n, k, full;int AB[MS], AC[MS], BC[MS], ans[MS], out[MS];int mo(int x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;const int inv2 = qpow(2, MOD - 2), inv4 = qpow(4, MOD - 2);void fwt(int* arr, int dwt = 1) &#123; int l, r; for(int i = 0; i &lt; k; ++i) for(int S = 0; S &lt; full; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = arr[S], r = arr[S|(1&lt;&lt;i)]; arr[S] = mo(l + r); arr[S|(1&lt;&lt;i)] = mo(l - r); &#125; int iv = qpow(full, MOD - 2); if(dwt == -1) for(int S = 0; S &lt; full; ++S) arr[S] = muln(arr[S], iv);&#125;int gg[4], a, b, c, xorsum;int gett(ll s, ll t, ll u, ll v) &#123; int x = muln(mo(mo(s+t)+mo(u+v)), inv4); int y = mo(muln(mo(s+t), inv2) - x); int z = mo(muln(mo(s+u), inv2) - x); int w = mo(muln(mo(s+v), inv2) - x); return muln( muln(qpow(gg[0],x),qpow(gg[1],y)) , muln(qpow(gg[2],z),qpow(gg[3],w)) );&#125;int main() &#123; scanf("%d%d%d%d%d", &amp;n, &amp;k, &amp;a, &amp;b, &amp;c); full = (1 &lt;&lt; k); gg[0] = mo(mo(a+b)+c), gg[1] = mo(mo(a+b)-c), gg[2] = mo(mo(a-b)+c), gg[3] = mo(mo(a-b)-c); for(int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;A[i], &amp;B[i], &amp;C[i]); AB[A[i]^B[i]]++, AC[A[i]^C[i]]++, BC[B[i]^C[i]]++; xorsum ^= A[i]; &#125; fwt(AB), fwt(AC), fwt(BC); for(int S = 0; S &lt; full; ++S) &#123; ans[S] = gett(n, AB[S], AC[S], BC[S]); &#125; fwt(ans, -1); for(int S = 0; S &lt; full; ++S) out[S] = ans[S ^ xorsum]; for(int S = 0; S &lt; full; ++S) printf("%d%c", out[S], " \n"[S==full-1]); return 0;&#125; CF662C 超级好题Description你有一个 $n$ 行 $m$ 列的 01 矩阵，你可以进行翻转行与翻转列两种操作（翻转即 0 变 1，1 变 0）任意多次，问最后得到的矩阵的 1 的个数最少是多少。 数据范围：$n\leq 20,m\leq 100000$ Source: CROC 2016 - Final Round Problem C. Binary Table Solution注意 $n\leq 20$ 的条件。先考虑 $O(m2^n )$ 暴力怎么做。记第 $j$ 列的数的 bitmask 为 $A_j$ ，我们枚举行的翻转状态的 bitmask为 $S$ ，然后对于每一种状态 $S$，我们查看每一列，第 $j$ 列被变为了 $A_j \oplus S$。考虑这一列是否翻转，显见答案增加了 $\min\{pop(A_j \oplus S), n-pos(A_J\oplus S)\}$，其中 $pop(S)$ 是指 $S$ 二进制表示中 1 的个数。我们记$f(S) = \min\{pop(S),n-pop(S)\}$ ，那么对于行的枚举状态 $S$ 我们得到的答案就是这个：$$\sum_{i=1}^m f(S\oplus A_i)$$由于 $A_j$ 的值域也是 $2^n$，我们记 $A$ 中 $x$ 这个值出现的次数为 $c(x)$，那么上式可以改写为：$$\sum_{T \subseteq 2^n} f(T \oplus S) \cdot c(T)$$是不是有点 FWT 的形式了？进一步地：$$\begin{aligned}ans(S) &amp;= \sum_{T \oplus U = S} f(T) c(U)\end{aligned}$$这不正是 FWT 吗？于是我们求出 $f$ 与 $c$ 的异或 FWT，然后扫一边 ans 数组找最小值即可。 Code点击显示/隐藏代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxs = (1 &lt;&lt; 20) + 2333, MOD = 998244353;int c[maxs], g[maxs], n, m, full , pop[maxs];char s[22][101010];inline int mo(int x) &#123; if(x &gt;= MOD) return x-MOD; if(x &lt; 0) return x+MOD; return x; &#125;inline int muln(int x, int y) &#123; return (ll)x * y % MOD; &#125;inline int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int Base, Len;int* fwt(int* A, int dwt = 1) &#123; int l, r; for(int i = 0; i &lt; Base; ++i) for(int S = 0; S &lt; Len; ++S) if(~S&gt;&gt;i&amp;1) &#123; l = A[S], r = A[S|(1&lt;&lt;i)]; A[S] = mo(l + r); A[S|(1&lt;&lt;i)] = mo(l - r); &#125; if(dwt==-1) &#123; int inv2 = qpow(Len, MOD-2); for(int S = 0; S &lt; Len; ++S) A[S] = muln(A[S], inv2); &#125; return A;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); full = (1 &lt;&lt; n) - 1; for(int i = 0; i &lt; n; ++i) scanf("%s", s[i]); for(int i = 0; i &lt; m; ++i) &#123; int res = 0; for(int j = 0; j &lt; n; ++j) res = 2 * res + s[j][i] - '0'; c[res]++; &#125; for(int S = 1; S &lt;= full; ++S) &#123; pop[S] = pop[S&gt;&gt;1] + (S&amp;1); g[S] = min(pop[S], n - pop[S]); &#125; Len = 1&lt;&lt;n, Base = n; fwt(c, 1); fwt(g, 1); for(int S = 0; S &lt;= full; ++S) c[S] = muln(c[S], g[S]); fwt(c, -1); int ans = 0x3f3f3f3f; for(int S = 0; S &lt;= full; ++S) ans = min(ans, c[S]); printf("%d\n", ans); return 0;&#125; [HDU5909] [WC2018]州区划分]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速沃尔什变换系列（FMT，FWT等）</tag>
        <tag>集合幂级数</tag>
        <tag>子集卷积</tag>
        <tag>高维前缀和（FMT）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小圆（球）覆盖学习笔记]]></title>
    <url>%2F2019%2F04%2F21%2F%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最小圆覆盖问题给出 $N$ 个点，让你画一个最小的包含所有点的圆。输出圆心、半径。 数据范围 $N\leq 10^5$ 模板提交链接：[Luogu 1742] [BZOJ 1337] 解法一般有两种做法：随机增量法与模拟退火法。随机增量法是一种确定性算法，随机意义下均摊复杂度 $O(n)$ ，而且可以达到很高的精度（可达到 $10^{-10}$ 量级）；而模拟退火法是启发式算法，需要结合调整参数从而得到一定精度，精度一般只可以可达到 $10^{-5}$ 量级。 随机增量法为了保证随机情况下的均摊性质，我们首先将给出的点随机打乱。 然后基于下面的事实进行操作： 如果点 $p$ 不在集合 $S$ 的最小覆盖圆内，则 $p$ 一定在 $S\cup\{p\}$ 的最小覆盖圆上。 根据这个定理，我们可以分三次确定前 $i$ 个点的最小覆盖圆。 1.令前 $i-1$ 个点的最小覆盖圆为 $C$ 2.如果第 $i$ 个点在 $C$ 内，则前 $i$ 个点的最小覆盖圆也是 $C$ 3.如果不在，那么第 $i$ 个点一定在前 $i$个点的最小覆盖圆上，接着确定前 $i-1$ 个点中还有哪两个在最小覆盖圆上。因此，设当前圆心为 $P_i$，半径为 $0$，做固定了第 $i$ 个点的前 $i$ 个点的最小圆覆盖。 4.固定了一个点：不停地在范围内找到第一个不在当前最小圆上的点 $P_j$，设当前圆心为 $(P_i+P_j)/2$，半径为 $\frac{1}{2}|P_iP_j|$，做固定了两个点的，前 $j$ 个点外加第 $i$ 个点的最小圆覆盖。 5.固定了两个点：不停地在范围内找到第一个不在当前最小圆上的点 $P_k$，设当前圆为 $P_i,P_j,P_k $ 的外接圆。 核心代码非常简洁： 123456789101112131415161718mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());Circle MinCircle(vector&lt;Point&gt; pt) &#123; int sz = pt.size(); shuffle(pt.begin(), pt.end(), rng); Circle cc(pt[0], 0.0); for(int i = 0; i &lt; sz; ++i) if(cc.out(pt[i])) &#123; cc = Circle(pt[i], 0.0); for(int j = 0; j &lt; i; ++j) if(cc.out(pt[j])) &#123; cc = Circle((pt[i] + pt[j]) / 2.0, length(pt[i]-pt[j]) / 2.0); for(int k = 0; k &lt; j; ++k) &#123; if(cc.out(pt[k])) &#123; cc = Circle(pt[i], pt[j], pt[k]); &#125; &#125; &#125; &#125; return cc;&#125; 这种做法乍一看是 $O(n^3)$ 的，可是实际上均摊意义下他就是 $O(n)$ 的。证法我现在还不会，留坑。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int maxn = 102000;const double eps = 1e-10;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; Point turn(double rad) &#123; return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); &#125; Point turn90() &#123; return Point(-y, x); &#125; void scan() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125;double angle(Vector A, Vector B) &#123; return acos(dot(A, B) / length(A) / length(B)); &#125;Point LLIntPV(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; assert(cross(v, w) != 0); double t = cross(w, u) / cross(v, w); return P + v * t;&#125; // Line: Point + Vector// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125; Circle(Point A, Point B, Point C) &#123; assert(sgn(cross(B-A, C-A)) != 0); Point mab = (A + B) / 2.0, ab = (B - A).turn90(); Point mbc = (B + C) / 2.0, bc = (C - B).turn90(); o = LLIntPV(mab, ab, mbc, bc); r = length(A - o); &#125; Point at(double theta) &#123; return o + Point(cos(theta)*r, sin(theta)*r); &#125; bool out(Point pt) &#123; return sgn(length(o-pt) - r) == 1;&#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());Circle MinCircle(vector&lt;Point&gt; pt) &#123; int sz = pt.size(); shuffle(pt.begin(), pt.end(), rng); Circle cc(pt[0], 0.0); for(int i = 0; i &lt; sz; ++i) if(cc.out(pt[i])) &#123; cc = Circle(pt[i], 0.0); for(int j = 0; j &lt; i; ++j) if(cc.out(pt[j])) &#123; cc = Circle((pt[i] + pt[j]) / 2.0, length(pt[i]-pt[j]) / 2.0); for(int k = 0; k &lt; j; ++k) &#123; if(cc.out(pt[k])) &#123; cc = Circle(pt[i], pt[j], pt[k]); &#125; &#125; &#125; &#125; return cc;&#125;int n;int main() &#123; scanf("%d", &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) p[i].scan(); Circle ans = MinCircle(p); printf("%.10f\n%.10f %.10f\n", ans.r, ans.o.x, ans.o.y); return 0;&#125; 模拟退火法原理模拟退火算法 ( Simulated annealing ) 是一种寻找函数全局最优解的一种算法，它的出发点是物理中固体物质的退火过程与一般组合优化问题之间的相似性。 寻找全局最优解是一个很麻烦的事情。有人可能说，在一个位置看到哪个方向函数上升，就走向哪个方向不就行了吗？这种方法称为爬山法，爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此可能会局限于局部的最优值。如何跳出局部最优呢？ 模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。 模拟退火算法描述： 若 $J( Y(i+1) ) \geq J( Y(i) )$ (即移动后得到更优解)，则总是接受该移动 若 $J( Y(i+1) )&lt; J( Y(i) )$ (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定），随着能量差的增大而降低。具体来说： 在温度为 $T$ 时，出现能量差为 $\Delta E$ 的降温的概率为 $P(\Delta E)$，表示为：$$P(\Delta E) = e^{\frac {\Delta E} {kT}}$$这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。 关于爬山算法与模拟退火，有一个有趣的比喻： 爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。 模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。 实现注意这么几件事情： 模拟退火一般需要进行调参，平衡运行时间、迭代次数、精度等因素 实现模拟退火时更是要注意各种精度损失。最小圆覆盖问题中，如果不考虑精度问题，求距离时多次调用 sqrt 函数将会损失非常多的精度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const double eps = 1e-12;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double xp=0, double yp=0): x(xp), y(yp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0; &#125; Point turn(double rad) &#123; return Point(x*cos(rad)-y*sin(rad), x*sin(rad)+y*cos(rad)); &#125; Point turn90() &#123; return Point(-y, x); &#125; void scan() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double dist2(Point A, Point B) &#123; return dot(A - B, A - B); &#125;double cross(Vector A, Vector B) &#123; return A.x*B.y - A.y*B.x; &#125;double angle(Vector A, Vector B) &#123; return acos(dot(A, B) / length(A) / length(B)); &#125;// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125; Point at(double theta) &#123; return o + Point(cos(theta)*r, sin(theta)*r); &#125; bool out(Point pt) &#123; return sgn(length(o-pt) - r) == 1;&#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());double Eval(const vector&lt;Point&gt;&amp; pt, Point o) &#123; double res = 0; for(auto g : pt) res = max(res, dist2(g, o)); return res;&#125;uniform_real_distribution&lt;double&gt; rgen(0.0, 1.0);double Rand()&#123; return rgen(rng); &#125;Circle MinCircleAnneal(const vector&lt;Point&gt;&amp; pt, double T, double dec, double ed) &#123; Point pcur(0.0, 0.0), pbest, pnew; int sz = pt.size(); for(auto g : pt) pcur = pcur + g; pbest = pcur = pcur / sz; double vcur = Eval(pt, pcur), vnew, vbest = vcur; while(T &gt; ed) &#123; pnew = pcur + Point((Rand()*2.0-1) * T, (Rand()*2.0-1.0) * T); vnew = Eval(pt, pnew); if(vnew &lt;= vbest) vbest = vcur = vnew, pbest = pcur = pnew; if(vnew &lt;= vcur || Rand() &lt; exp(-(vnew-vcur)/T)) vcur = vnew, pcur = pnew; T *= dec; &#125; return Circle(pbest, sqrt(vbest));&#125;int n;int main() &#123; scanf("%d", &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) p[i].scan(); Circle ans = MinCircleAnneal(p, 100000.0, 0.997, 3e-11); printf("%.10f\n%.10f %.10f\n", ans.r, ans.o.x, ans.o.y); return 0;&#125; 应用Opentrains 1519 GDescription给你了 $n$ 个定义在区间 $[0,T]$ 上的一次函数 $f_i(x) = a_ix+b_i$ ，定义两个一次函数的距离为：$$dist(f,g) = \left(\max_{0\leq i\leq T} (f(i)-g(i))\right)^2 + \left(\min_{0\leq i\leq T}(f(i)-g(i))\right)^2$$你现在要找一个一次函数 $g(x) = cx+d$ 使得下面的值最小：$$\max_{1\leq i\leq n} dist(f_i, g)$$你只需要输出最小值就可以了。 数据范围 $1\leq n \leq 200000$ Solution乍一看，貌似要想一想。那个最大值与最小值一定在定义域的两个端点或者两个函数相交的地方取到。。。等等，不对啊，看清楚之后，我们会发现，那个平方是加在外面的，因此要我们求最值的函数就是 $f(x)-g(x)$ ，两个一次函数之差还是一次函数！那么最值一个在 $x=0$ 处取得，一个在 $x=T$ 处取得。 我们用 $f(0)$ 与 $f(T)$ 两个值来表征一个一次函数，可以发现，如果把 $\big(f(0),f(T)\big)$ 作为点画在二维平面上， $dist(f,g)$ 即为这两个点的欧几里得距离。把题中 $n$ 个点都画出来，我们要找一个点使得这个点到其他点的距离的最大值最小，这不就是最小圆覆盖吗！ 最小球覆盖那么考虑三维的情况，会是什么样子的呢？2018 ACM-ICPC 南京区域赛的 D 题正是最小球覆盖的裸题。 大致有两种方法，模拟退火法和三分套三分套三分。（我很奇怪为什么没有随机增量类似的方法了，不过很可能是三维情况下四点定球不是非常好写）。 模拟退火代码：（2018南京D） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const double eps = 1e-12;int sgn(double x) &#123; if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y, z; Point(double xp=0, double yp=0, double zp=0): x(xp), y(yp), z(zp) &#123; &#125; Point operator + (const Point&amp; rhs) const &#123; return Point(x+rhs.x, y+rhs.y, z+rhs.z); &#125; Point operator - (const Point&amp; rhs) const &#123; return Point(x-rhs.x, y-rhs.y, z-rhs.z); &#125; Point operator * (const double&amp; k) const &#123; return Point(x*k, y*k, z*k); &#125; Point operator / (const double&amp; k) const &#123; return Point(x/k, y/k, z/k); &#125; bool operator &lt; (const Point&amp; rhs) const &#123; return x &lt; rhs.x || (x==rhs.x &amp;&amp; y&lt;rhs.y) || (x==rhs.x&amp;&amp;y==rhs.y&amp;&amp;z&lt;rhs.z); &#125; bool operator == (const Point&amp; rhs) const &#123;return sgn(x - rhs.x) == 0 &amp;&amp; sgn(y - rhs.y) == 0 &amp;&amp; sgn(z-rhs.z)==0; &#125; void scan() &#123; scanf("%lf%lf%lf", &amp;x, &amp;y, &amp;z); &#125;&#125;;typedef Point Vector;double dot(Vector x, Vector y) &#123; return x.x*y.x + x.y*y.y + x.z*y.z; &#125;double length(Vector x) &#123; return sqrt(dot(x, x)); &#125;double dist2(Point A, Point B) &#123; return dot(A - B, A - B); &#125;// Circlestruct Circle &#123; Point o; double r; Circle(Point O, double R): o(O), r(R) &#123; &#125;&#125;;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());double Eval(const vector&lt;Point&gt;&amp; pt, Point o) &#123; double res = 0; for(auto g : pt) res = max(res, dist2(g, o)); return res;&#125;uniform_real_distribution&lt;double&gt; rgen(0.0, 1.0);double Rand()&#123; return rgen(rng); &#125;Circle MinCircleAnneal(const vector&lt;Point&gt;&amp; pt, double T, double dec, double ed) &#123; Point pcur, pbest, pnew; int sz = pt.size(); for(auto g : pt) pcur = pcur + g; pbest = pcur = pcur / sz; double vcur = Eval(pt, pcur), vnew, vbest = vcur; while(T &gt; ed) &#123; pnew = pcur + Point((Rand()*2.0-1) * T, (Rand()*2.0-1.0) * T, (Rand()*2.0-1) * T); vnew = Eval(pt, pnew); if(vnew &lt;= vbest) vbest = vcur = vnew, pbest = pcur = pnew; if(vnew &lt;= vcur || Rand() &lt; exp(-(vnew-vcur)/T)) vcur = vnew, pcur = pnew; T *= dec; &#125; return Circle(pbest, sqrt(vbest));&#125;int n;int main() &#123; scanf("%d", &amp;n); vector&lt;Point&gt; p(n); for(int i = 0; i &lt; n; ++i) p[i].scan(); double ans = 1e13; rep(i, 40) &#123; Circle cir = MinCircleAnneal(p, 100000.0, 0.999, 3e-7); ans = min(ans, cir.r); &#125; printf("%.10f\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小圆覆盖</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个有趣的期望问题]]></title>
    <url>%2F2019%2F04%2F21%2F%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9C%9F%E6%9C%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述一个长度为 $1$ 的线段上随机撒 $n-1$ 个点，形成了 $n$ 条线段，那么这 $n$ 条线段中第 $k$ 短（$k\leq n$）的线段期望长度是多少呢？答案是：$$\frac 1n \sum_{i=0}^{k-1} \frac 1{n-i}$$例如， $n$ 条线段中最短的线段期望长度是 $\frac 1 {n^2}$，第二短的期望是 $\frac 1n (\frac 1n + \frac 1{n-1})$ ，依此类推。 事实上，这 $n$ 条线段期望的长度分布是指数分布，可以类比玻尔兹曼分布，少数较长的线段占据了大部分长度。而如果按照从左往右的顺序的话，每条线段长度都服从相同的概率分布，概率密度函数都是 $\displaystyle f(x) = (n-1) \cdot (1-x)^{n-2}$ 。 这里只证明第 $k$ 短的期望。推导过程很大一部分借鉴了这篇博客。当然北航也写过类似的题解： 2015-2016 Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest cz_xuyixuan的题解 ccosi的题解 证明我们采用数学归纳法的思路。 当 $k=1$ 时，我们先证明 $n$ 条线段中最短的线段期望长度是 $\frac 1 {n^2}$ 。 不妨考虑最短长度不小于 $x$ 时的概率如何求解。实际上相当于把每条线段都预留上 $x$ 的长度，剩下的就是一个随机分配的问题了，每条线段都有 $(1-nx)$ 的概率，即：$$P(L_{1} \geq x) = P(L_1\geq x,L_2\geq x,\cdots,L_n\geq x,L_1+L_2+\cdots+L_n=1) = (1-nx)^{n-1}$$求最短线段的期望长度就是这样一个积分：$$\begin{align}E(L_{1}) &amp; = \int_0^{\frac 1n} xP(L_{1} = x) \textrm{d}x\\ &amp; = \int_0^{\frac 1n} P(L_{1} \geq x) \textrm{d}x \\ &amp; = \int_0^{\frac 1n} (1-nx)^{n-1} \textrm{d}x\\ &amp; = \frac 1{n^2}\end{align}$$由此， $k=1$ 的情况得到了证明。 假设 $k=d$ 的情况，上述结论成立，我们考虑 $k=d+1$ 的情况。 求第 $d+1$ 短的期望长度，我们只需要先把最短的一段截走，之后就是对于 $n-1$ 条线段的第 $d$ 短的问题了。$$\begin{align}E(L_{d+1}) &amp; = E(L_1)+(1-n\cdot E(L_1)) \cdot \frac{1}{n-1}\sum_{i=1}^d\frac 1{n-i} \\ &amp; = \frac{1}{n^2} + \frac{1}{n}\sum_{i=1}^d \frac 1{n-i} \\ &amp; = \frac 1n \sum_{i=0}^{d}\frac 1{n-i}\end{align}$$由此，命题得证。 例题 AGC 032F你有一个大小为 $1$ 的圆形比萨，你首先将会切 $n$ 刀，每一刀都是随机一个 $[0,2\pi)$ 的角度 $\theta$，然后从圆心沿着水平方向逆时针 $\theta$ 的角度切下去。$n$ 刀过后，比萨被切成了 $n$ 份。 之后，你可以选取面积之和最接近 $\frac 13$ 的连续的若干份比萨作为你的食物。问你吃到的比萨大小与 $\frac 13$ 的距离的期望是多少，即 $|x-\frac 13|$ 的期望。 题目链接 解答：$$ans = \sum_{i=1}^m \frac{1}{3^i \cdot n(n-i+1)}$$ AC代码 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define rep(i, n) for(int i = 1, i##_end_ = (n); i &lt;= i##_end_; ++i)using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;const int MOD = 1000000007, maxn = 1020000;int muln(int x, int y) &#123; return 1LL * x * y % MOD; &#125;int qpow(int x, int y) &#123; int ret = 1; for(; y; y &gt;&gt;= 1, x = muln(x, x)) if(y &amp; 1) ret = muln(ret, x); return ret;&#125;int inv(int x) &#123; return qpow(x, MOD - 2); &#125;int n, ans, i3 = inv(3), in, p3 = 1;int main() &#123; scanf("%d", &amp;n); in = inv(n); for(int i = 1; i &lt;= n; ++i) &#123; p3 = muln(p3, i3); ans += muln(p3, muln(in, inv(n - i + 1))); if(ans &gt;= MOD) ans -= MOD; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论之旅1：同余方程]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%95%B0%E8%AE%BA%E4%B9%8B%E6%97%85%E4%B9%8B%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近我一直在刷潘承洞、潘承彪的《初等数论》，感觉还是学到了不少东西呢。从现在我就来做一个数论之旅系列专题笔记吧，顺便也记录一下我的学习历程。 这一次笔记对应的是《初等数论》第四章同余方程 4.5 到 4.9 的内容，主要介绍二次剩余理论，包括欧拉判别法，勒让德符号，二次互反律，雅克比符号等，以及高次同余方程简介，给出了 $n$ 次剩余的判别公式。 在开始之前约定一下我的记号吧。未经说明的任何字母都代表自然数，小写字母 $p$ 始终代表奇素数，而大写的 $P$ 则不一定。 二次剩余知识与定理首先我们最初是想要解决二次同余方程 $ax^2+bx+c\equiv 0\pmod p$ 。我们经过配方等操作之后，可以发现这种方程化简之后唯一不平凡的形式就是 $x^2\equiv d \pmod p$ 这个样子。这个形式看似简单，不就是模意义下开根号么，可是里面藏着不少玄机。我们先给出一些定义： 模素数的二次剩余、二次非剩余的定义： 若关于 $x$ 的同余方程 $x^2\equiv d \pmod p$ 有解（$p\nmid d$），则称 $d$ 是模 $p$ 的二次剩余； 否则，称 $d$ 是模 $p$ 的二次非剩余。 注意：我们一般不谈 $\pmod 2$ 的二次剩余，也不谈 $0$ 是不是二次剩余。 显然，$\pmod p$ 的二次剩余一共有 $\frac{p-1}{2}$ 个，且方程 $x^2\equiv d \pmod p$ 要么无解，要么恰好有两个解。 欧拉判别法 设素数 $p&gt;2, p\nmid d$ ，那么，$d$ 是模 $p$ 的二次剩余的充分必要条件是：$$d^{(p-1)/2} \equiv 1 \pmod p$$$d$ 是模 $p$ 的二次非剩余的充分必要条件是：$$d^{(p-1)/2} \equiv -1 \pmod p$$ 这个定理是一个比较重要的定理，我们可以轻易在 $O(\log p)$ 的时间内计算出一个数是不是二次剩余，而在大部分ACM竞赛中对于二次剩余也只需要了解这么多。这个地方我暂时不给出证明，以后提到的原根之后，我们将给出一种统一的证明方式，这种证法同时能证明之后提到的 $n$ 次剩余的结论。 由欧拉判别法，根据其只有-1，1这两种取值特点，结合乘方的性质，我们可以很轻易地发现下面的性质： 二次剩余 $\times$ 二次剩余 = 二次剩余 二次剩余 $\times$ 二次非剩余 = 二次非剩余 二次非剩余 $\times$ 二次非剩余 = 二次剩余 模 $p$ 意义下，这种二次剩余的关系满足一种积性性质！那么，我们就引入一种一种完全积性函数来表示二次剩余吧，由此勒让德符号应运而生。 勒让德符号 定义整变量 $d$ 的函数（ $p$ 是素数）$$\left(\frac{d}{p}\right) =\begin{cases}1 &amp; \text{d是模p的二次剩余} \\-1 &amp; \text{d是模p的二次非剩余}\\0 &amp; p\mid d\end{cases}$$我们把 $\left(\frac{d}{p}\right)$ 称为模 $p$ 的勒让德符号。 勒让德符号满足下面的性质: $\left(\frac dp \right) = \left( \frac{p+d}{p}\right)$ ；即：勒让德符号有周期性。 $\left(\frac{d}{p}\right) \equiv d^{(p-1)/2} \pmod p$ 这是因为欧拉判别法 $\left(\frac{dc}{p}\right) = \left(\frac{d}{p}\right) \left(\frac{c}{p}\right)$ 有了第一、第三点，我们称勒让德符号是模 $p$ 的Dirichlet特征，勒让德符号因此具有良好的性质；而有了第二点，我们可以方便地使用快速幂来计算勒让德符号。 二次剩余这么就完全解决了吗？从理论上讲，还有很多非常优美的性质没有挖掘呢！下面我们就引出初等数论最重要的成果之一：高斯的二次互反律。首先我们介绍高斯引理： 高斯引理 设 $p \nmid d$；再设 $1\leq j \leq (p-1)/2$，令$$t_i \equiv jd \pmod p,\text{ } 0 &lt; t_j &lt; p$$以 $n$ 表示这 $(p-1)/2$ 个 $t_i$ 中大于 $p/2$ 的数的个数，那么：$$\left(\frac{d}{p}\right) = (-1)^n$$事实上，当 $\gcd(d,2p)=1$ 时，我们还有 $n$ 的精确表达式：$$n = \sum_{i=1}^{(p-1)/2} \left[\frac{jd}{p}\right]$$ 这个定理还是蛮有用的，有了高斯引理，我们就可以解决一部分勒让德符号计算的问题了：（读者可以自己验证） $\left( \frac{1}{p} \right) \equiv 1$ 这个根据定义显然； $\left( \frac{-1}{p} \right) \equiv (-1)^{\frac{p-1}{2}}$ 根据定义显然，$4k+1$ 型素数-1是二次剩余； $\left( \frac{2}{p} \right) \equiv (-1)^{\frac{p^2-1}{8}}$ 用高斯引理易得。这说明对于 $8k\pm 1$ 型素数 $2$ 是二次剩余； 那么如何证明呢？高斯引理的证明是挺精妙的，我们只证明前一半部分。我们考虑 $t_i$ 的乘积，一方面：$$\prod_{i=1}^{(p-1)/2} t_i = d^{(p-1)/2} \prod_{i=1}^{(p-1)/2} i$$另一方面，把 $t_i$ 中所有大于 $(p-1)/2$ 的数 $r$ 换成 $p - r$ ，即可使这些 $t_i$ 形成 $1,2,\cdots,(p-1)/2$ 的一个排列，这个过程中一共有 $n$ 个数被调换，因此乘积中会出现 $(-1)^n$ 的因子。由此：$$\prod_{i=1}^{(p-1)/2} t_i = (-1)^n \prod_{i=1}^{(p-1)/2} i$$综合上面两个式子，即可得到这个定理。 如果稍微进行一些分析，就可以得到 $n$ 的表达形式了，这里不再展开。可是我们能够注意到， $n$ 的形式不是类欧几里得算法的形式么？我们自然要考虑它的几何意义。如下图，这个值就是阴影三角形 $\triangle OCB$ 内部格点的数目。为什么说是内部呢？很好证明，这个三角形斜边上不会出现格点。 二次互反律在上面的图片里面，我们不禁要问还有没有别的几何意义。我们观察 $\triangle OCB$ ，这个三角形就是 $\left(\frac{p}{d}\right)$ 啊！（注意我们之前约定过 $d$ 是奇数）。那么这两个三角形的格点数目之和正好就是整个矩形的格点数目 $\frac{p-1}{2} \cdot \frac{d-1}{2}$ ！由此我们就证明了二次互反律： 设 $p,q$ 为奇素数，$p\neq q$ ，则有：$$\left(\frac qp\right) \cdot \left( \frac pq \right) = (-1)^{\frac{p-1}{2} \cdot \frac{q-1}{2}}$$ 二次互反律的理论价值和实用价值都很高，可以证明很多命题，下面举几个《初等数论》上的例题吧，读者可以想一想怎么解决，之后可能会更新解答。 证明有无穷多个 $8k+1$ 型质数 求以 $11$ 为其二次剩余的所有奇素数 $p$ 证明：若$\left(\frac dp\right) = -1$ ，则 $p$ 必然不能表示为 $x^2-dy^2$ 的形式。 我们再说一说二次互反律的另一个重要价值——计算勒让德符号。有了二次互反律，我们可以设计一种类欧几里得算法！回想我们是如何使用欧几里得算法求最大公约数的： 我们知道 $\gcd(a,0)=a$ 这一种平凡情况 否则，利用 $\gcd(a,b) = \gcd(b,a\%b)$ ，我们可以将问题规模缩小一半，从而让问题可以化为平凡情况 对于勒让德符号的计算，我们不也可以这样吗？我们有这么几个条件： 当勒让德符号上面的数 $d=1,2 \text{ or } -1$ 时，可以直接给出答案； 否则，根据互反律，我们可以交换上下两个数，$O(1)$ 计算那个多出来的 $(-1)^{\frac {p-1}{2} \cdot \frac{q-1}2}$ 因子，然后用Legendre符号的周期性进行取模，使得问题规模缩小一半。 这不是挺完美的吗？别高兴得太早！别忘记，勒让德符号要求符号下面的数 $p$ 可要是质数！正因为这一点，互反律成立需要 $p,q$ 是奇素数才可以！这样才能保证勒让德符号有意义！这可麻烦了，这样的话，就是计算个勒让德符号，还要必须将数分解质因数！分解质因数可不是个简单的事情，当数比较大的时候这个开销是花不起的。那么我们怎么办呢？我们可以拓展勒让德符号的定义，我们来定义雅克比符号： 雅克比符号 设奇数 $P&gt;1$，$P=p_1p_2\cdots p_s$ ，则定义雅克比符号为：$$\left( \frac dP \right) = \prod_{i-1}^{s} \left(\frac d{p_i}\right)$$其中乘积项中的符号是勒让德符号。 可以验证，雅克比符号满足勒让德符号的一切性质，并且满足互反律，因此可以辅助计算勒让德符号。 可是有一点必须强调：雅克比符号 $\left( \frac dP \right)=1$ 绝不保证 $x^2\equiv d \pmod P$ 一定有解！例如：$\left(\frac 2 {3599}\right) = 1$ ，可是 $x^2\equiv 2 \pmod {3599}$ 无解！ 其实雅可比符号还有拓展，叫做Kronecker符号，甚至还可以拓展到有理数范围，叫做Hilbert符号。这里给出维基百科的链接吧 Legendre，此处不再详细说明了。（其实是因为我也不会） 下面是一个雅克比符号的模板。使用二次互反律计算，复杂度 $O(\log \min \{a,n\})$ 。Accepted on HDU3589 12345678910int Jacobi(int a, int n) &#123; a %= n; if(a == 0 || (a%2==0 &amp;&amp; n%2==0)) return 0; if(a == 1) return 1; if(a == 2) return (((n&amp;7) == 1) || ((n&amp;7) == 7)) ? 1 : -1; if((a &amp; 1) == 0) return Jacobi(2, n) * Jacobi(a / 2, n); if(n % 2 == 0) return Jacobi(a, 2) * Jacobi(a, n / 2); int sgn = ((a - 1) / 2 * (n - 1) / 2) &amp; 1; return Jacobi(n, a) * (sgn ? -1 : 1);&#125; Cipolla算法上面主要是在讲如何判断二次剩余存不存在的问题，可是如果知道存在了，到底应当怎样构造呢？Cipolla算法即可解决这个问题。这个算法感觉数学背景还是蛮深厚的，是一个挺有趣的算法。 推荐博客 czy ，下面内容是从他的博客上抄的。 模板题： Timus 1132 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define Type intnamespace ModOp &#123; Type MOD; inline Type mo(Type x) &#123; if(x &gt;= MOD) x -= MOD; if(x &lt; 0) x += MOD; return x; &#125; struct MF &#123; Type v; MF(Type x = 0): v(mo(x)) &#123; &#125; operator Type() &#123; return v; &#125; MF operator + (const MF&amp; f) const &#123; return mo(v + f.v); &#125; MF operator - (const MF&amp; f) const &#123; return mo(v - f.v); &#125; MF operator * (const MF&amp; f) const &#123; return 1LL * v * f.v % MOD; &#125; MF operator / (const MF&amp; f) const &#123; return v / f.v; &#125; MF operator - () const &#123; return MOD - v; &#125; MF operator &gt;&gt; (int idx) const &#123; return v &gt;&gt; idx; &#125; MF operator &lt;&lt; (int idx) const &#123; return v &lt;&lt; idx; &#125; bool operator == (const MF&amp; f) const &#123; return v == f.v; &#125; bool operator != (const MF&amp; f) const &#123; return v != f.v; &#125; bool operator &gt; (const MF&amp; f) const &#123; return v &gt; f.v; &#125; bool operator &lt; (const MF&amp; f) const &#123; return v &lt; f.v; &#125; bool operator &gt;= (const MF&amp; f) const &#123; return v &gt;= f.v; &#125; bool operator &lt;= (const MF&amp; f) const &#123; return v &lt;= f.v; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; out, MF f) &#123; return out &lt;&lt; f.v; &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, MF f) &#123; return in &gt;&gt; f.v; &#125; bool scan() &#123; return scanf("%d", &amp;v) != -1; &#125; void print() &#123; printf("%d", v); &#125; &#125;;&#125;#undef Typetemplate&lt;typename T&gt; T qpow(T x, int y) &#123; T ret = T(1); for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) ret = ret * x; return ret;&#125;using ModOp::MF;namespace qres &#123; MF a, n; int p; struct F &#123; MF x, y; // x+yw F(MF _a = 0, MF _b = 0): x(_a), y(_b) &#123; &#125; F operator + (F f2) const &#123; return F(x + f2.x, y + f2.y); &#125; F operator * (F f2) const &#123; return F(x*f2.x + y*f2.y*(a*a-n), x*f2.y+y*f2.x); &#125; &#125;; MF Legendre(MF d) &#123; return qpow(d, (p-1)/2); &#125; void Cipolla(int qn, int qp) &#123; // p is a prime, gcd(n, p) = 1 qn %= qp; if(qp == 2 &amp;&amp; qn == 1) &#123; puts("1"); return; &#125; ModOp::MOD = p = qp; n = qn; if(Legendre(n) != MF(1)) &#123; puts("No root"); return; &#125; a = rng() % p; while(Legendre(a * a - n) != MF(-1)) a = rng() % p; F w(a, 1), res = qpow(w, (p + 1) / 2); MF ans = res.x, ans2 = -ans; if(ans &gt; ans2) swap(ans, ans2); cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; "\n"; &#125;&#125; 例题题解允许我先咕一下QAQ [CF1091G] New Year and the Factorisation Collaboration 蛮有意思的CF题，在Goodbye 2018里出的。 BZOJ1406 [AHOI2007]密码箱题意：求下面同余方程的所有解：$(n\leq 2\cdot 10^9)$$$x^2\equiv 1 \pmod n$$解法： 对于方程 $x^2\equiv 1 \pmod{p^\alpha}$ ，只需要进行分类讨论，然后Hensel引理升幂。对于任意模数的情况，只需要再用CRT合并。 [SCOI2018] Numazu的蜜柑模素数的高次同余方程模意义下的因式定理现在我们要解决更加困难的问题了：给定整系数多项式 $f(x)$，求解 $f(x)\equiv 0 \pmod p$ 。对于实数域，有因式定理，即如果 $f(x)$ 有根 $c$，则 $f(x)$ 有因式 $(x-c)$。对于模意义下有没有类似性质呢？答案是肯定的。 设 $p\nmid a_n$ ，若 $n$ 次同余方程 $f(x) \equiv 0 \pmod p$ 有 $k$ 个不同的解 $x\equiv c_1,\cdots,c_k \pmod p$ ，则一定存在唯一一对整系数多项式 $g_k(x), r_k(x)$，使得：$$f(x) = (x-c_1)\cdots(x-c_k)g_k(x) + p \cdot r_k(x)$$ 这个定理还有一种等价表述，即Lagrange定理： $f(x) \equiv 0 \pmod p$ 的解数 $k \leq \min(n,p)$ 结合上面定理，我们可以得到一个强有力的结论，即判别 $n$ 次方程恰有 $n$ 个解的方法： 设 $a_n=1$ ，那么 $f(x) \equiv 0 \pmod p$ 的解数等于 $n$ 的充分必要条件是：存在整系数多项式$q,r$ ，且$r$ 次数小于 $n$，使得：$$x^p-x = f(x)q(x) + p\cdot r(x)$$ $n$ 次剩余由此，我们就具有了解决 $n$ 次剩余的理论基础。我们称 $x^n\equiv a \pmod p (p\nmid a)$ 为二项同余方程，而如果这个方程有解，则称 $a$ 为模 $p$ 的 $n$ 次剩余，否则为 $n$ 次非剩余。可以利用原根证明下面两个定理： 若 $n\mid p-1$ ，则 $x^n\equiv a \pmod p (p\nmid a)$ 的充要条件是：$$a^{(p-1)/n} \equiv 1 \pmod p$$ 若 $n\nmid p-1$ ，令 $k=\gcd(n,p-1)$ 则 $x^n\equiv a \pmod p (p\nmid a)$ 的充要条件是：$x^k\equiv a \pmod p $ 有解，且解数相同。即有解的充分必要条件是：$$a^{(p-1)/k} \equiv 1 \pmod p$$ 这样我们就找到了欧拉判别法的推广！我们也可以快速解决判断 $n$ 次剩余的问题了！可是还有没有类似勒让德符号的定义了呢，有没有互反律之类的东西了呢？在自然数范围内是没有了，如果使用代数数论的观点来看，应该还是有的，可是超出了我们的讨论范围。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>二次剩余</tag>
        <tag>n次剩余</tag>
        <tag>数论之旅系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[p进数 (p-adic) 、牛顿迭代与Hensel引理]]></title>
    <url>%2F2019%2F03%2F10%2Fp%E8%BF%9B%E6%95%B0-p-adic-%E4%B8%8EHensel%E5%BC%95%E7%90%86%2F</url>
    <content type="text"><![CDATA[你敢相信 $\sum\limits^{\infty}_{i=0}2^i = -1$ 吗？数论中一个长相奇怪的定理到底有什么直观意义？牛顿迭代法作为常用的数值方法，和p进数又会有什么联系？ 上面的几个问题似乎毫不相关，我当时分别听说这几个知识的时候也没有发现它们之间的联系。可是这几天偶然了解到有关p进数（p-adic）的一套理论，我顿时感觉如同醍醐灌顶：换一种角度看问题，它们之间的联系居然如此简单明了！下面我就来介绍一下我认识的这几个知识的联系吧。 这一块内容有很多涉及代数数论甚至泛函分析的相关内容，我都没有太深入的了解，可能会出不少问题，也希望大家能给我进行一些补充吧。 TL;DR（Too long; Don’t read） （这是简述，看完简述剩下的就可以不看了） 简而言之，这篇文章数论中一个形式古怪的提高模数次数的定理（Hensel定理，2.1中有定义描述与证明）说起，目的是阐明它的直观意义，即说明与牛顿迭代法的相似性： 一方面，从定理形式的表面出发，这个定理的变形之后和牛顿迭代法是极为相似的 另一方面，从更深层次的意义来说，它解决的问题是在p进度量下用有理数逼近多项式的零点的过程。 第一点在2.2会有解释，而第二点则更为关键。本质上说，牛顿迭代法那样在绝对值度量下用有理数估计多项式零点，用的是是从数位高的地方向数位低的地方逼近的方法，即类似$1,1.4,1.41,1.414,\cdots$ 的过程。可是Hensel定理是从恰恰相反的方向逼近的，即从数位低的地方向数位高的地方递进的，如在7-adic下逼近 $\sqrt{2}$，则逼近的数列是这样的： $\{3, (13)_7, (213)_7,\cdots\}$ 。 这么做靠谱吗？怎么感觉都没有任何收敛的感觉呢，简直玄学！可是你为什么说这个数列不收敛？你会说，因为相邻两项之间的距离，即差的绝对值，越来越大了呗。但是你说的这个距离为什么就是差的绝对值？如果我巧妙定义另一套距离，说不定我就可以说这个数列是逐步收敛的了。这就引出了一套有趣的数学理论，即p进度量和p进数 。 首先，我们定义了有理数集上一种独特的范数和距离 然后，我们引入完备的概念。在绝对值度量下，比如数列$1,1.4,1.41,1.414,\cdots$ ，这个数列存在极限（因为单调有界），并且数列每一项都是有理数，但是这个极限就不在有理数集里。因此我们称有理数集是不完备的，称这样的数列就是在对无理数进行逼近。 从这个观点来看， Hensel引理相当于在p进度量下，给出了用有理数逼近多项式零点的数列的构造。 牛顿迭代法给出了在绝对值度量下用有理数逼近多项式零点的数列的构造。 因此从目的的角度看来，牛顿迭代和Hensel引理是在不同度量下，解决同一个问题，因此形式相似。这可真的是殊途同归啊！这不得不赞叹数学的魅力了。 P.S. 强烈推荐3blue1brown的这个视频，讲的是p进数：3blue1brown的视频 非常直观易懂，让大家瞬间能对p进数有个概念。可以先看视频，再看本文。 Hensel引理一切的一切，都要从潘承洞、潘承彪《初等数论》第186页的一个定理说起。（第四章第四节） 如果你求出了一个整系数多项式同余方程 $f(x)\equiv 0 \pmod p$ 的一些解 $x\equiv c_1,c_2,\cdots\pmod p$ ，但是我要求你再求出 $\mod {p^2}$ 的解，你该怎么做呢？直接重新求一遍？太麻烦了吧！有什么简单方法吗？这个定理给出了答案。只是。。。这个定理的形式有点诡异，无法直观理解： 定理的描述与证明定理描述定理 设 $p$ 是素数，整系数多项式 $f(x)=a_n x^n+a_{n-1}x^{n-1} +\cdots + a_1x+a_0, n \geq 2$ ；再设整数$\alpha \geq 2$， $c$ 是同余方程 $f(x) \equiv 0 \pmod {p^{\alpha-1}}$ 的解，那么，同余方程 $f(x) \equiv 0 \pmod{p^\alpha}$ 满足 $x\equiv c\pmod{p^{\alpha-1}}$ 的解是形式一定是$x\equiv c+y_j p^{\alpha - 1}, j=1,2,\cdots, l$ ，这里$y\equiv y_1,\cdots,y_l \pmod p$ 是关于 $y$ 的一次同余方程：$$f’(c) \cdot y\equiv -f(c) \cdot p^{1-\alpha} \pmod p \tag{1}$$的全部解，其中 $f’(x)$ 即表示 $f(x)$ 的导函数。 （这个定理据说是代数数论重要定理Hensel引理的初等描述。） 一些解释与思考这个定理好诡异啊！到底是什么意思呢？我们一步一步来。首先 $x\equiv c\pmod{p^{\alpha-1}}$ 这个解在模数升幂之后的形式一定是 $x\equiv c+y p^{\alpha - 1} \pmod{p^\alpha}$ ，这一点可以理解，因为如果把 $x$ 写成 $p$ 进制数，那么 $x$ 的后$\alpha - 1$ 位（从个位开始数）已经确定为 $c$ ，只有第 $\alpha$ 位这一个位置可以任取，不妨设这一位的数是 $y $，( $0\leq y&lt; p$ )，则解的形式就是 $x\equiv c+y\cdot p^{\alpha -1}$ 。 可能有同学会问：为什么拓展之后的解形式中 $y$ 还要分这么多种？这是因为同余方程 (1) 是一次同余方程，根据 $f’(c)$ 和 $-f(c)\cdot p^{1-\alpha}$ 是否模 $p$ 余 $0$ 进行讨论的话，可能有一个解，可能无解，也可能任何 $0\leq y&lt;n$ 的数都是解，即：拓展之后可能有 $0,1$ 或 $p$ 个解，这么写是一种不失一般性的写法。 然后。。。就到了最鬼畜的(1)式了。这里怎么莫名出现了导数？为什么它的形式如此诡异？二潘在书里也给出了一个初等的证明，但同样无法让人感受这个定理的直观意义。 定理证明证明 将拓展之后的解的形式 $x\equiv c+y_j p^{\alpha - 1}$ 代入方程 $f(x) \equiv 0 \pmod{p^{\alpha}}$ ：$$\begin{align}f(x) &amp; \equiv &amp; a_n(c+p^{\alpha-1}y)^n + a_{n-1} (c+p^{\alpha-1}y)^{n-1} +\cdots+a_0\\ &amp; \equiv &amp; f(c)+p^{\alpha-1}f’(c)y+A_2p^{2(\alpha-1)}y^2+\cdots+A_n p^{n(\alpha-1)}y^n\ &amp; \equiv &amp; 0 \pmod {p^\alpha}\end{align}$$其中 $A_2, A_3,\cdots,A_n$ 是整数，由于 $\alpha \geq 2$ ，从上式可知 $f(x) \equiv 0 \pmod{p^{\alpha}}$ 等价于：$$p^{\alpha-1} f’(c) y \equiv -f(c) \pmod{p^\alpha}$$由于 $f(c)$ 是 $p^{\alpha-1}$ 的倍数（因为 $f(c)\equiv 0 \pmod {p^{\alpha-1}}$），所以两边同时除以 $p^{\alpha - 1}$ 即可得到我们要证明的式子。 评论 说实话。。。这个证明也挺平凡的，并没有给我对于定理的直观感受。那么下面我们就从直观感觉出发，探究这个定理究竟是在解决什么问题。 与牛顿迭代法形式上的相似之处其实，式 (1) 和牛顿迭代法本质是完全相同的。 先做一个约定，这里的牛顿迭代法为了和Hensel引理相对应，采用非常狭义的定义。要求初始值为有理数，而求零点的函数也是多项式函数，这样迭代的每一步也都是有理数了。 我们知道，在求连续函数 $f(x)$ 的零点时，牛顿迭代法的递推公式是：$$c’ = c - \frac{f(c)}{f’(c)} \tag{2}$$而我们的式 (1) 也可以写作（假设只有一个拓展后的解）：$$c’ \equiv c-\big(\frac{f(c)/p^{k-1}}{f’(c)} \bmod p\big) \cdot p^{k-1} \pmod{p^k}$$如果不严格地把取模号全部丢弃，我们会发现这个式子和 (2) 是完全一样的。事实上，在同余运算下因为有取模操作，式 (1) 已经做到和牛顿迭代保持最大程度的相似了。 那么我们来考虑这两者在目的上有什么相似之处：牛顿迭代实际上在不断逼近一个使得函数值为0的点，这里的“逼近”指的是迭代值和真实值的距离（即差的绝对值）逐渐缩小，是一个收敛的过程；而Hensel引理的让幂次升高的迭代是否也是在”逼近“某个数呢？不过这里的逼近好像会导致迭代值之间差的绝对值越来越大，这个过程是还能是收敛的吗？ 事实上，这就引出了有理数的另一种度量：$p$ 进度量（或 $p$ 进赋值）。 $p$ 进数$p$ 进制数首先明确一点的是 $p$ 进数中的 $p$ ，指的是素数，因为素数情况下的性质比较优雅。 什么是 $p$ 进数（p-adic）？我们先从 $p$ 进制数一步一步说起。 我们都熟悉十进制数，我们可以类似十进制表示法那样，写出 $p$ 进制数的形式：$$\begin{align}x&amp;=&amp;\cdots\alpha_i \alpha_{i-1}\cdots\alpha_1\alpha_0.\alpha_{-1}\cdots\alpha_{-k+1}\alpha_{-k}\\&amp; = &amp; \cdots + \alpha_i p^i+\cdots + \alpha_1p +\alpha_0 + \frac{\alpha_{-1}}{p} + \cdots\frac {\alpha_{-k}}{p_k}\end{align}$$一些常见的结论就是，一个分母是 $p$ 的整数幂的分数在 $p$ 进制下为有限小数；其他有理数一定会是循环小数，无理数则是无限不循环小数。 在我们通常的认识中，如果 $x$ 是正数，那么 $x$ 小数点左边的数位越多，这个数就会越大（称为范数越大）。但是这一点是为什么呢？像刚才的问题，那我能不能定义右数字越多，这个数越大呢？ 为了探寻上面数论定理的意义，我们采用这种反着来定义范数的方法，可是我们还需要做一些准备工作，即我的这种定义需要满足距离的性质。 范数与度量范数是绝对值概念的推广。由上面的例子看出，范数也是需要公理化的。那么范数需要有哪些性质呢？ 若 $X$ 是数域上的线性空间，泛函 $\left| \cdot \right|:X \rightarrow R$ 满足： (1) 正定性：$\left|x\right|\geq0$，且 $\left|x\right|=0\Leftrightarrow x=0$； (2) 正齐次性： $\left|cx\right|=|c|\left|x\right|$; (3) 次可加性（三角不等式）：$\left|x+y\right|\leq \left|x\right|+\left|y\right|$ ； 那么，$\left|\cdot\right|$ 称为 $X$ 上的一个范数。 我们定义 $v_p(x)=\max \{\alpha \in N: p^\alpha \mid x \} $，则 $|x|_p = p^{-v_p(x)}$ 就可以作为正整数域 $N^*$ 的一个范数（注意指数上的符号！这就是上面小数点后数字越多，数越大的体现）。这个概念还可以推广到有理数域 $\mathbb{Q}$。定义 $|\frac ab|_p = \frac{|a|_p}{|b|_p}$ 即可。 有了范数的概念，定义距离就是很显然的了。$d(x,y)=\left|x-y\right|$ 。 例如，$p=3$ 时$$d(5, \frac 59) = p^{-v_p(\frac {40}{9})}=p^{-2}=\frac 19$$ $$d(6,735) = p^{-v(729)} = p^{-6} = \frac{1}{729}$$ 因此，最开头说的这个式子在2-adic的左边就不再是那么不可理解了：$$\sum_{i=0}^\infty 2^i = -1$$ 在绝对值度量下，我们认为“越来越小”的数组成的级数可能收敛，可是在这里不也一样吗？在2-adic下，$2^i$ 随着 $i$ 的增大，不就是在减小吗？还有一个问题，右边为什么是 $-1$？这就要思考在 2-adic 下怎么表示负数了。 这确实又引出了问题。 和绝对值度量一样，我们从大到小考虑这个p进数的每一位进行近似。这里要注意，$p$ 是比 $p^2$ 大的，因此从大到小就是对应这一个升幂的过程。 以 $x=-1$ 的表示为例，首先考虑第0位。这一位应当满足：$$x\equiv -1 \pmod 2$$显然这一位是1。然后考虑第一位后这个数一定是 $1+t\cdot2$形式的，那么：$$1+t\cdot 2\equiv -1 \pmod {2^2}$$由此， $t\equiv 1 \pmod 2$ 。那么考虑第二位。这个数现在变成了 $1+2+t\cdot2^2$形式，然后我们要解：$$1+2+t\cdot 2^2\equiv -1 \pmod{2^3}$$逐渐进行下去，我们发现这里的每一位都是 $1$ ，因此 $-1$ 在2-adic下的表示就是 $\sum\limits_{i=0}^\infty 2^i$ 这个例子是不是很有启发性？这个过程是不是和上面的定理很相似？ 像这样，我们可以利用p进度量求得 p-adic 下所有的有理数 $\frac ab$ 的表示。我们只需要将方程 $bx\equiv a\pmod{p^k}$ 不断用类似的过程升幂，而升幂的过程就是一个渐进的过程。 有理数域的完备化还有更疯狂的呢！如果我对 $x^2\equiv 2\pmod {7^k}$ 不断升幂，那我又能得到什么呢？我甚至能得到 $\sqrt{2}$ 在7-adic下的表示！这可是一件了不起的事情！我们的p进度量可没办法处理无理数啊！在无理数中怎么谈 $v_p(x)$ 这个函数呢？可是无理数就这样能够在p进数中出现了。 实际上这种过程就是一个将有理数域完备化的过程。 设 $x_n$ 是距离空间 $X$ 中的点列，如果对于任意的 $\epsilon&gt;0$，存在自然数 $N$，当 $m,n&gt;N$ 时，$|x_n−x_m|&lt;\epsilon$，称 $\{x_n\}$ 是一个 Cauchy 列。 完备空间或者完备度量空间是具有下述性质的空间：空间中的任何柯西序列都收敛在该空间之内。 有理数集就不是完备的，因为在绝对值度量下， $\sqrt{2}$ 的有限位小数表示 $\{1,1.4,1.41,1.414,1.4142,\cdots\}$ 是一个柯西序列，但是其极限 $\sqrt{2}$ 不在有理数集内；而我们的例子相当于说在7-adic度量下的序列 $\{3, (13)_7, (213)_7\}$ 也是一个柯西序列，但是极限 $\sqrt{2}$ 不在有理数集中。 将不完备集合中添加元素使之完备的过程称为完备化。所有将有理数集按照绝对值完备化，即可得到实数集；而按照p进赋值完备化就得到了p进数。 殊途同归！现在我们可以讨论最开始的定理的意义了。总结一下： 首先，我们定义了一种与绝对值恰恰相反的范数：p进赋值 由此，我们也定义了有理数集的两种不同的距离 然后，我们发现，对于这两种距离，有理数集都不是完备的，都能存在柯西序列，使得序列的极限不在有理数集中。 按照绝对值距离，有理数集拓展为了实数集；按照p进赋值，有理数集完备化为p进数集。 我们上面说有理数集直接就“完备化”了，可是还没说到底怎么趋近一个这样的无理数呢。考虑特殊的情况：对于整系数多项式零点的寻找。正好，相对应的，两种度量方式给出了两种逼近方式： 绝对值度量给出了牛顿迭代法，逐渐使得答案精确的小数点位数增多。 p进度量给出了Hensel引理，逐渐给答案升幂。 因此，解决的问题都相同，解决的方式也相同。在截然不同的两种度量下，它们最终的公式居然能够完全一致，这不得不赞叹数学的魅力了。 注 事实上，在有理数域上定义范数只有上面两种本质不同的不平凡定义方式。这个结论成为奥斯特洛夫斯基定理（Ostrowski’s theorem） 实际上由于p 进数是完备的，甚至可以继续在p进数上定义微积分！ 还未搞清楚的问题 牛顿迭代法的几何意义是切线，可是Hensel引理有没有几何意义呢？ 网上有人说LTE引理（升幂引理）和 p 进数有关系，有什么关系呢？ Hensel定理的代数数论表述如何理解？ 都说p进数集是被实数集所包含的，这是为什么？哪些实数不能被p进估计？ 相关推荐推荐的视频资料： 3blue1brown的视频 （这个在开头已经推荐过了）很清晰易懂，非常有启发性。 Hensel引理与p-adic（youtube） 这个视频专业性更强一些，和本文的内容更是息息相关。这个视频的uploader，Harpreet Bedi 是个专业数学知识的科普作者，他上传的视频往往是有关深刻的数学知识的。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>p-adic</tag>
        <tag>数论</tag>
        <tag>牛顿迭代法</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[博客建好了！这个博客将会记录我之后学习过程中遇到的点点滴滴。这一篇博客就用来测试一下博客的$\LaTeX$和代码块的显示是否正常吧。Hello world! 数学公式：$$e^{i\theta} = \cos{\theta} + i\sin{\theta}$$ $$\iint\limits_{D}(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}) \mathrm{d}x \mathrm{d}y = \oint\limits_{L}P\mathrm{d}x+Q\mathrm{d}y$$ $$X(k) = \sum\limits_{j=1}^{n}x(j) \cdot \omega_n^{(j-1)(k-1)}, \omega = e^{-\frac{2\pi i}{n}}$$ 空心字母打法： \mathbb{Q} ，如 $\mathbb{N}$ markdown 打对齐公式，显示标号用 \begin{align} ，不显示用 \begin{aligned} ，千万不要用 \begin{align*} ！因为 hexo 会把星号渲染成斜体符号。 代码块放个树状数组模板吧，我认为最简洁优美的数据结构之一 123456789101112131415#define lowbit(x) ((x) &amp; (-(x)))struct BIT &#123; int c[200200] = &#123;&#125;; inline int sum(int x) &#123; int ret = 0; while(x) ret += c[x], x -= lowbit(x); return ret; &#125; inline void add(int x, int d) &#123; while(x &lt;= n) c[x] += d, x += lowbit(x); &#125; inline int query(int x, int y) &#123; return sum(y) - sum(x - 1); &#125;&#125;;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
